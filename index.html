<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>

<!-- DaisyUI and Tailwind CSS CDN -->
<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    touch-action: pan-x pan-y;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
}
.touch-indicator { animation: pulse 0.5s; }
@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}
.dynamic-block-input::-webkit-outer-spin-button, .dynamic-block-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.dynamic-block-input { -moz-appearance: textfield; }
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Men√º umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">‚ò∞</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergr√∂√üe anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10√ó10√ó10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe w√§hlen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzuf√ºgen (Linie/Fl√§che)</span>
    <button id="clearBtn" aria-label="Alles l√∂schen" class="btn btn-sm btn-neutral">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen" class="btn btn-sm btn-neutral">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export" class="btn btn-sm btn-neutral">OBJ Export</button>

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <label class="text-base-content">Feste Blockgr√∂√üe:</label>
    <button id="block-size-1x1" class="block-size-btn btn btn-sm btn-neutral active" aria-label="Blockgr√∂√üe 1x1x1">1x1x1</button>
    <button id="block-size-4x4" class="block-size-btn btn btn-sm btn-neutral" aria-label="Blockgr√∂√üe 4x4x4">4x4x4</button>
    <button id="block-size-8x8" class="block-size-btn btn btn-sm btn-neutral" aria-label="Blockgr√∂√üe 8x8x8">8x8x8</button>
    <button id="block-size-10x10" class="block-size-btn btn btn-sm btn-neutral" aria-label="Blockgr√∂√üe 10x10x10">10x10x10</button>

    <label class="text-base-content">Dynamische Blockgr√∂√üe:</label>
    <div class="dynamic-block-input-group flex items-center gap-2">
        <input type="number" id="dynamic-block-x" class="dynamic-block-input input input-bordered input-sm w-20 bg-base-300 border-base-content/20 text-base-content text-center" value="1" min="1" max="180" aria-label="Dynamische Blockbreite (X)">
        <span class="text-base-content">x</span>
        <input type="number" id="dynamic-block-y" class="dynamic-block-input input input-bordered input-sm w-20 bg-base-300 border-base-content/20 text-base-content text-center" value="1" min="1" max="180" aria-label="Dynamische Blockh√∂he (Y)">
        <span class="text-base-content">x</span>
        <input type="number" id="dynamic-block-z" class="dynamic-block-input input input-bordered input-sm w-20 bg-base-300 border-base-content/20 text-base-content text-center" value="1" min="1" max="180" aria-label="Dynamische Blocktiefe (Z)">
    </div>
    <button id="setDynamicBlockSizeBtn" aria-label="Dynamische Gr√∂√üe festlegen" class="btn btn-sm btn-neutral">Gr√∂√üe festlegen</button>

    <button id="measureDistanceBtn" aria-label="Abstand messen" class="btn btn-sm btn-neutral">Abstand messen</button>

    <button id="helpToggleBtn" aria-label="Hilfe umschalten" class="btn btn-sm btn-neutral">Hilfe</button>
    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen" class="btn btn-sm btn-neutral">Zur Szene zur√ºckkehen</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <div id="infoBox" class="info-box absolute bottom-4 left-4 p-3 rounded-lg text-sm bg-base-300 text-base-content shadow-lg pointer-events-none"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus ‚Üí Kamera drehen (Fly Mode)<br>
    WASD / E / Q ‚Üí bewegen<br>
    Linke MT ‚Üí Voxel hinzuf./l√∂schen/zeichnen<br>
    **Alt + Mausrad ‚Üí Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad ‚Üí Zeicheneben Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad ‚Üí Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel Aktion auf aktiver Ebene (Hinzuf√ºgen (Linie/Fl√§che) / L√∂schen / Zeichnen)**<br>
    **Control + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel ziehen zum Hinzuf√ºgen (Stapeln, nur im Hinzuf√ºgen (Linie/Fl√§che)-Modus)**<br>
    **Linke MT gedr√ºckt + Maus ziehen (Freihand-Modi) ‚Üí Kontinuierliche Voxel-Aktion**<br>
    Mausrad ‚Üí Kamera Geschwindigkeit anpassen<br>
    **Tab ‚Üí Modus wechseln (Hinzuf√ºgen (Linie/Fl√§che) / Hinzuf√ºgen (Freihand) / L√∂schen / Zeichnen / Messen)**<br>
    **1, 2, 3 ‚Üí Voreingestellte Farbe w√§hlen**<br>
    **Strg + Z ‚Üí R√ºckg√§ngig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z ‚Üí Wiederholen (Redo)**<br>
    **NEU: Abstand messen (Modus "Messen")**<br>
    **Linke MT ‚Üí Erster Klick setzt Startpunkt, Zweiter Klick setzt Endpunkt und zeigt Distanz**
    </div>
    <div id="touch-indicator" class="touch-indicator absolute w-10 h-10 rounded-full bg-blue-500/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden z-[2000]"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
    <div id="distanceDisplay" class="absolute bottom-4 right-4 p-2 bg-base-300 text-base-content rounded-md text-sm hidden z-[900]">Distanz: 0.00 mm</div>
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt l√∂schen</h3>
        <p class="py-4">M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekr√§ftiger Titel f√ºr Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie ausw√§hlen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Geb√§ude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> √ñffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schlie√üen</button>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-camera" aria-label="Kamera wechseln">üì∑</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-assist" aria-label="Touch-Assist umschalten">üß≤</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">üîë</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth,setPersistence,   browserLocalPersistence,  signInWithCustomToken, onAuthStateChanged, signOut,
             GoogleAuthProvider, GithubAuthProvider, signInWithPopup, signInAnonymously,
             createUserWithEmailAndPassword, signInWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence,
        browserLocalPersistence, signOut, GoogleAuthProvider, GithubAuthProvider, signInWithPopup,
        createUserWithEmailAndPassword, signInWithEmailAndPassword, getFirestore, doc, getDoc, collection,
        addDoc, serverTimestamp
    };

    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA",
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJ5CNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
const VS = 1, HALF = VS * 0.5;
const CHUNK_SIZE = 16;
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;
const SHIFT_X  = VOX_BITS * 2;
const SHIFT_Y  = VOX_BITS;

function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1; 
const PINCH_ZOOM_MULT = 40;
const TAP_DIST_TH = 10;
const MOVE_PX = 10;
const DT_MS = 250;
const PAN_PIX_TH = 10;
const PINCH_REL_TH = 0.08;
const ROTATE_SPEED_TOUCH = 0.004;
const PAN_SPEED_TOUCH = 0.1;

let activePointers = new Map();
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null;
let doubleTapDragActive = false;
let touchIndicator;

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;
let euler;
const voxels = new Map();
const chunks = new Map();

let cvs, containerDiv;
let activeDrawingLevel = { x: 0, y: 0, z: 0 };
let currentDrawingAxis = 'y';

let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1');
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');

activeDrawingLevel.x = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
activeDrawingLevel.y = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
activeDrawingLevel.z = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';
let currentBlockSize = parseInt(localStorage.getItem('voxelEditorCurrentBlockSize') || '1');

let dynamicBlockDim = {
    x: parseInt(localStorage.getItem('voxelEditorDynamicBlockDimX') || '1'),
    y: parseInt(localStorage.getItem('voxelEditorDynamicBlockDimY') || '1'),
    z: parseInt(localStorage.getItem('voxelEditorDynamicBlockDimZ') || '1')
};
let useDynamicBlockDim = localStorage.getItem('voxelEditorUseDynamicBlockDim') === 'true';

const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#E4002B', // Mario Red
    localStorage.getItem('voxelPresetColor2') || '#00A040', // Luigi Green
    localStorage.getItem('voxelPresetColor3') || '#0057B8'  // Nintendo Blue
];
let activePresetIndex = -1;
let presetBoxes = [];

let mainDirectionalLight, fillDirectionalLight, hemisphereLight;
let isShiftDragging = false;
let isControlDragging = false;
let isPointerLocked = false;
let lastActionVoxelCoords = null;
let initialClickPos = null;
let firstMoveAfterLock = true;
let mouseMovementX = 0;
let mouseMovementY = 0;

const dummy = new THREE.Object3D();
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial);

const Modes = {
    LINE_ADD: 'Hinzuf√ºgen (Linie/Fl√§che)',
    FREE_ADD: 'Hinzuf√ºgen (Freihand)',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
    MEASURE: 'Messen',
};
let currentMode = Modes.LINE_ADD;

let history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100;

let currentStrokeVoxels = new Map();
let voxelsAtDragStart = null;

let previewLineInstancedMesh;
const maxPreviewInstances = 180 * 3;
let previewLineVoxels = [];

let templateImageMesh = null;
let templateImageData = null;

let isMobile = window.matchMedia('(max-width: 768px)').matches;
let touchAssistEnabled = false;

let distanceDisplay;
let initialDragVoxelWorldPos = null;
let dragAxisLock = null;

let measurementStartPoint = null;
let measurementEndPoint = null;

let projectTitle = '';
let projectDescription = '';
let projectCategory = 'Allgemein';
let projectTags = [];
let projectRemixOf = '';
let projectSourceJsonUrl = '';
let projectVisibility = 'public';

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"];

let auth, db, currentUserId, currentUser;
let infoBox, helpToggleBtn;

// Minimal VoxelShaperIO for OBJ export
const VoxelShaperIO = {
    voxToOBJ: function(voxModel, voxelSize) {
        let obj = '# VoxelShaper OBJ Export\n';
        let mtls = '# VoxelShaper MTL Export\n';
        let vertexCount = 0;
        const materials = new Map(); // Map color hex to material name

        // Collect unique colors and assign material names
        voxModel.voxels.forEach(v => {
            if (!materials.has(v.color)) {
                const matName = `material_${materials.size + 1}`;
                materials.set(v.color, matName);
                const c = new THREE.Color(v.color);
                mtls += `newmtl ${matName}\n`;
                mtls += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`; // Diffuse color
                mtls += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`; // Ambient color
                mtls += `Ks 0.0 0.0 0.0\n`; // Specular color (no shininess)
                mtls += `Ns 0.0\n`; // Shininess
                mtls += `d 1.0\n`; // Dissolve (alpha)
                mtls += `illum 1\n\n`; // Illumination model
            }
        });

        obj += `mtllib voxel_model.mtl\n`;

        voxModel.voxels.forEach(v => {
            const x = v.x * voxelSize;
            const y = v.y * voxelSize;
            const z = v.z * voxelSize;

            // Vertices for a unit cube
            const verts = [
                [x, y, z], [x + voxelSize, y, z], [x, y + voxelSize, z], [x + voxelSize, y + voxelSize, z],
                [x, y, z + voxelSize], [x + voxelSize, y, z + voxelSize], [x, y + voxelSize, z + voxelSize], [x + voxelSize, y + voxelSize, z + voxelSize]
            ];

            verts.forEach(vert => {
                obj += `v ${vert[0].toFixed(4)} ${vert[1].toFixed(4)} ${vert[2].toFixed(4)}\n`;
            });

            const matName = materials.get(v.color);
            obj += `usemtl ${matName}\n`;

            // Faces (assuming standard cube faces)
            const faces = [
                [1, 2, 4, 3], // Front
                [5, 6, 8, 7], // Back
                [1, 5, 7, 3], // Left
                [2, 6, 8, 4], // Right
                [3, 4, 8, 7], // Top
                [1, 2, 6, 5]  // Bottom
            ];

            faces.forEach(idx => {
                obj += `f`;
                idx.forEach(vIdx => {
                    obj += ` ${vertexCount + vIdx}`;
                });
                obj += `\n`;
            });
            vertexCount += 8;
        });

        return { obj: obj, mtl: mtls };
    },
    saveBlob: function(data, filename) {
        const objBlob = new Blob([data.obj], { type: 'text/plain' });
        const mtlBlob = new Blob([data.mtl], { type: 'text/plain' });

        const objUrl = URL.createObjectURL(objBlob);
        const mtlUrl = URL.createObjectURL(mtlBlob);

        const aObj = document.createElement('a');
        aObj.href = objUrl;
        aObj.download = filename;
        document.body.appendChild(aObj);
        aObj.click();
        document.body.removeChild(aObj);
        URL.revokeObjectURL(objUrl);

        const aMtl = document.createElement('a');
        aMtl.href = mtlUrl;
        aMtl.download = filename.replace('.obj', '.mtl');
        document.body.appendChild(aMtl);
        aMtl.click();
        document.body.removeChild(aMtl);
        URL.revokeObjectURL(mtlUrl);
    },
    VoxModel: function(width, height, depth, voxels) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.voxels = voxels; // Array of {x, y, z, c}
    }
};


function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
    }
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex }); this.updateInstanceColor(instanceId, newColorHex);
    }
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

function handleGesture() {
    const pointers = [...activePointers.values()]; if (pointers.length === 0) return;
    if (pointers.length === 1 && gestureState.type === 'rotate') {
        const p = pointers[0];
        euler.y -= (p.x - gestureState.lastMid.x) * ROTATE_SPEED_TOUCH;
        euler.x += (p.y - gestureState.lastMid.y) * ROTATE_SPEED_TOUCH;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y }; return;
    }
    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) gestureState.type = 'pinch';
            else if (dMid > PAN_PIX_TH) gestureState.type = 'pan';
            return;
        } else if (gestureState.type === 'pinch') {
            const zoomDelta = (dist / gestureState.lastDist - 1) * PINCH_ZOOM_MULT * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panFactor = PAN_SPEED_TOUCH * moveSpeed;
            const dx = (midX - gestureState.lastMid.x) * panFactor;
            const dy = (midY - gestureState.lastMid.y) * panFactor;
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            cam.position.addScaledVector(right, -dx);
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy);
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (gestureState.initialPointerCount >= 3 && activePointers.size === 0 && initialClickPos && eventType.pointerType === 'touch') {
        const dx = eventType.clientX - initialClickPos.x; if (Math.abs(dx) > 50) { if (dx > 0) redo(); else undo(); }
    }
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null; touchIndicator.style.display = 'none';
        if (currentMode !== Modes.MEASURE || (currentMode === Modes.MEASURE && measurementStartPoint === null && measurementEndPoint === null)) {
            distanceDisplay.classList.add('hidden');
        }
        initialDragVoxelWorldPos = null; dragAxisLock = null;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); return;
    }
    switch (currentMode) {
        case Modes.LINE_ADD: currentMode = Modes.FREE_ADD; break;
        case Modes.FREE_ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.MEASURE; break;
        case Modes.MEASURE: currentMode = Modes.LINE_ADD; measurementStartPoint = null; measurementEndPoint = null; distanceDisplay.classList.add('hidden'); break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
    }
}

function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            document.getElementById('color-picker').value = colorValue;
            localStorage.setItem('voxelEditorColor', colorValue);
        }
    }
}

function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear();
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

function addCommand(type, oldState = null, newState = null, commandData = null) {
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData }); historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) { history.shift(); historyPointer--; }
}

function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': applyVoxelState(reverse ? oldState : newState); break;
        case 'clearAll': clearAllInternal(true); if (reverse) applyVoxelState(oldState); break;
        case 'fillLevel': applyVoxelState(reverse ? oldState : newState); break;
        case 'resizeGrid':
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState); break;
    }
    rebuildHelpers();
}

function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey); chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) { chunk.dispose(); chunks.delete(cKey); }
    }
}

function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(gx, gy, gz, newColorHex);
}

function performVoxelModification(gx, gy, gz, mode, color) {
    const gKey = key(gx, gy, gz); const hasVoxel = voxels.has(gKey);
    switch (mode) {
        case Modes.LINE_ADD: case Modes.FREE_ADD: if (!hasVoxel || voxels.get(gKey).color !== color) _addSingleVoxel(gx, gy, gz, color); break;
        case Modes.DELETE: if (hasVoxel) _removeSingleVoxel(gx, gy, gz); break;
        case Modes.DRAW: if (hasVoxel && voxels.get(gKey).color !== color) _recolorSingleVoxel(gx, gy, gz, color); else if (!hasVoxel) _addSingleVoxel(gx, gy, gz, color); break;
    }
}

function updatePreviewVoxel(x, y, z, visible, dimX = 1, dimY = 1, dimZ = 1) {
    if (previewVoxelMesh) {
        if (visible) {
            // Ensure dimension parameters are positive
            dimX = Math.max(1, dimX);
            dimY = Math.max(1, dimY);
            dimZ = Math.max(1, dimZ);

            // Recreate geometry only if dimensions change
            if (previewVoxelMesh.geometry.parameters.width !== dimX * VS ||
                previewVoxelMesh.geometry.parameters.height !== dimY * VS ||
                previewVoxelMesh.geometry.parameters.depth !== dimZ * VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(dimX * VS, dimY * VS, dimZ * VS);
            }
            previewVoxelMesh.position.set(x * VS + (dimX * VS) / 2, y * VS + (dimY * VS) / 2, z * VS + (dimZ * VS) / 2);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

function calculateTargetVoxelCoords(clientX, clientY, mode, pointerType) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    const intersects = raycaster.intersectObjects(objectsToIntersect);

    let targetVoxelCoords = null;

    if (intersects.length > 0) {
        // Intersection with an existing voxel
        const hit = intersects[0];
        const hitNormal = hit.face.normal.clone();
        const hitPointInside = hit.point.clone().sub(hitNormal.multiplyScalar(0.001)); // Move slightly inside the hit face

        const hitVx = Math.floor(hitPointInside.x / VS);
        const hitVy = Math.floor(hitPointInside.y / VS);
        const hitVz = Math.floor(hitPointInside.z / VS);

        if (mode === Modes.LINE_ADD) {
            // Add mode: place on the face normal
            targetVoxelCoords = {
                gx: hitVx + Math.round(hit.face.normal.x),
                gy: hitVy + Math.round(hit.face.normal.y),
                gz: hitVz + Math.round(hit.face.normal.z)
            };
        } else {
            // Delete, Draw, Free_Add, Measure mode: target the hit voxel itself
            targetVoxelCoords = { gx: hitVx, gy: hitVy, gz: hitVz };
        }
    } else {
        // No intersection with existing voxels
        if (mode === Modes.LINE_ADD || mode === Modes.FREE_ADD || mode === Modes.DRAW) {
            // Try to intersect with the active drawing plane
            let planeNormal = new THREE.Vector3();
            let planeConstant = 0;

            if (currentDrawingAxis === 'y') {
                planeNormal.set(0, 1, 0);
                planeConstant = -(activeDrawingLevel.y * VS);
            } else if (currentDrawingAxis === 'x') {
                planeNormal.set(1, 0, 0);
                planeConstant = -(activeDrawingLevel.x * VS);
            } else if (currentDrawingAxis === 'z') {
                planeNormal.set(0, 0, 1);
                planeConstant = -(activeDrawingLevel.z * VS);
            }

            const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
            const intersectionPoint = new THREE.Vector3();

            if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
                let gx = Math.floor(intersectionPoint.x / VS);
                let gy = Math.floor(intersectionPoint.y / VS);
                let gz = Math.floor(intersectionPoint.z / VS);

                // Snap to the active drawing level for the respective axis
                if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

                targetVoxelCoords = { gx, gy, gz };
            } else {
                // If no intersection with drawing plane, default to center of the grid at current drawing level
                targetVoxelCoords = {
                    gx: Math.floor(GRID / 2),
                    gy: Math.floor(GRID / 2),
                    gz: Math.floor(GRID / 2)
                };
                if (currentDrawingAxis === 'y') targetVoxelCoords.gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') targetVoxelCoords.gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') targetVoxelCoords.gz = activeDrawingLevel.z;
            }
        }
        // For DELETE or MEASURE mode, if no voxel is intersected, there's no target.
    }

    // Clamp coordinates to grid boundaries (this is a raw target, dimensions handled later)
    if (targetVoxelCoords) {
        targetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gx));
        targetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gy));
        targetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gz));
    }
    
    // Touch assist (snapping to nearest voxel center)
    if (targetVoxelCoords && pointerType === 'touch' && touchAssistEnabled) {
        // Recalculate based on the snapped world position if touch assist is on
        const snappedPos = getNearestVoxelCenter(new THREE.Vector3(targetVoxelCoords.gx * VS + HALF, targetVoxelCoords.gy * VS + HALF, targetVoxelCoords.gz * VS + HALF));
        targetVoxelCoords.gx = Math.round(snappedPos.x / VS - HALF);
        targetVoxelCoords.gy = Math.round(snappedPos.y / VS - HALF);
        targetVoxelCoords.gz = Math.round(snappedPos.z / VS - HALF);
    }

    return targetVoxelCoords;
}


function getNearestVoxelCenter(worldPos) {
    const vx = Math.round(worldPos.x / VS - HALF); const vy = Math.round(worldPos.y / VS - HALF); const vz = Math.round(worldPos.z / VS - HALF);
    return new THREE.Vector3(vx * VS + HALF, vy * VS + HALF, vz * VS + HALF);
}

function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
        addCommand('clearAll', oldState, []);
    }
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers();
}
function clearAll() { clearAllInternal(false); }

function fillActiveLevel() {
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        const k = key(gx, gy, gz); if (voxels.has(k)) voxelsToRemove.push(k);
    }}
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });
    const newState = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        _addSingleVoxel(gx, gy, gz, currentColor); newState.push({ gx, gy, gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
    }}
    addCommand('fillLevel', oldState, newState);
}

function saveJSON() {
    const data = {}; voxels.forEach((value, k) => { const [gx,gy,gz] = parseKey(k); data[`${gx},${gy},${gz}`] = value.color; });
    const settings = {
        gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
        presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
        currentBlockSize: currentBlockSize, dynamicBlockDim: dynamicBlockDim, useDynamicBlockDim: useDynamicBlockDim,
        templateImageData: templateImageData
    };
    const projectData = {
        title: projectTitle, description: projectDescription, category: projectCategory, remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl, tags: projectTags, visibility: projectVisibility, downloads: 0,
        rating: 0, ratingCount: 0, verified: false, fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date(), uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
        uploaderPhotoURL: currentUser?.photoURL || "",
        projectData: {
            description: projectDescription, remixOf: projectRemixOf, sourceJsonUrl: projectSourceJsonUrl,
            settings: settings, activeDrawingLevel: activeDrawingLevel, activePresetIndex: activePresetIndex,
            cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            currentAnchorPoint: { x: "start", y: "start", z: "start" }, currentBlockSize: currentBlockSize,
            currentColor: currentColor, currentDrawingAxis: currentDrawingAxis, dynamicBlockDim: dynamicBlockDim,
            gridSize: GRID, moveSpeed: moveSpeed, presetColors: presetColors, templateImageData: templateImageData,
            useDynamicBlockDim: useDynamicBlockDim, voxels: data
        }
    };
    const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'voxel_project.json';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success');
}

function resetToDefaultProject() {
    clearAllInternal(true); GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    currentColor = '#ffffff'; document.getElementById('color-picker').value = currentColor; localStorage.setItem('voxelEditorColor', currentColor);
    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x); localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y); localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z); localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    currentBlockSize = 1; setFixedBlockSize(currentBlockSize); localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
    dynamicBlockDim = { x: 1, y: 1, z: 1 }; useDynamicBlockDim = false;
    localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x); localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y); localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z); localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);
    document.getElementById('dynamic-block-x').value = dynamicBlockDim.x; document.getElementById('dynamic-block-y').value = dynamicBlockDim.y; document.getElementById('dynamic-block-z').value = dynamicBlockDim.z; updateBlockSizeButtonsActiveState();
    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1; removeImageTemplate(true); history.length = 0; historyPointer = -1;
    measurementStartPoint = null; measurementEndPoint = null; distanceDisplay.classList.add('hidden');
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';
    rebuildHelpers(); resetCameraPosition(); showToast('Projekt zur√ºckgesetzt', 'Das Projekt wurde auf den Standardzustand zur√ºckgesetzt.', 'info');
}

function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        clearAllInternal(true); removeImageTemplate(true);
        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0]; const gy = parts[1]; const gz = parts[2];
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) _addSingleVoxel(gx, gy, gz, colorValue);
            }
        }
        if (loadedSettings) {
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) { activeDrawingLevel = { ...loadedSettings.activeDrawingLevel }; localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x); localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y); localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z); }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#ffffff'; document.getElementById('color-picker').value = currentColor;
            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; document.getElementById(`color-preset-${i + 1}`).value = presetColors[i]; localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            if (loadedSettings.currentBlockSize !== undefined) { setFixedBlockSize(loadedSettings.currentBlockSize); localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize); }
            if (loadedSettings.dynamicBlockDim) {
                dynamicBlockDim = { ...loadedSettings.dynamicBlockDim };
                document.getElementById('dynamic-block-x').value = dynamicBlockDim.x; document.getElementById('dynamic-block-y').value = dynamicBlockDim.y; document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;
                localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x); localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y); localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z);
            }
            if (loadedSettings.useDynamicBlockDim !== undefined) { useDynamicBlockDim = loadedSettings.useDynamicBlockDim; localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim); }
            updateBlockSizeButtonsActiveState();
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { console.error('Error loading template image texture:', err); templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1; measurementStartPoint = null; measurementEndPoint = null; distanceDisplay.classList.add('hidden');
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        console.error('Error loading JSON file:', error);
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error');
        resetToDefaultProject();
    }
}

async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info');
    try {
        const docSnap = await window.firebase.getDoc(window.firebase.doc(db, "models", modelId));
        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;
            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; projectSourceJsonUrl = window.location.href;
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success');
                } else { showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error'); resetToDefaultProject(); }
            } else { showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error'); resetToDefaultProject(); }
        } else { showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning'); resetToDefaultProject(); }
    } catch (error) {
        console.error("Error loading project from model ID:", error);
        if (error.code === 'permission-denied') showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell √∂ffentlich ist oder Sie der Eigent√ºmer sind.`, 'error');
        else showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error');
        resetToDefaultProject();
    }
}

function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            console.error('Error parsing file JSON:', error);
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error');
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

function exportSTL() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning'); return; }
    const geometriesToMerge = []; const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF); dummy.updateMatrix();
        const instanceGeometry = tempBoxGeometry.clone(); instanceGeometry.applyMatrix4(dummy.matrix);
        const c = new THREE.Color(data.color);
        const vtxColorArr = []; for (let j = 0; j < instanceGeometry.attributes.position.count; j++) vtxColorArr.push(c.r, c.g, c.b);
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
        geometriesToMerge.push(instanceGeometry);
    });
    const mergedGeometry = geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    const tempMesh = new THREE.Mesh(mergedGeometry);
    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error'); return; }
    const exporter = new THREE.STLExporter(); const result = exporter.parse(tempMesh);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'voxel_model.stl';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    tempBoxGeometry.dispose(); if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success');
}

function exportOBJ() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning'); return; }
    const voxelsToExport = []; let maxX = 0, maxY = 0, maxZ = 0;
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k); voxelsToExport.push({ x, y, z, c: 1, color: data.color }); // Pass color for OBJ export
        maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); maxZ = Math.max(maxZ, z);
    });
    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    VoxelShaperIO.saveBlob(VoxelShaperIO.voxToOBJ(voxModel, VS), 'voxel_model.obj');
    showToast('Export erfolgreich', 'OBJ-Modell erfolgreich exportiert!', 'success');
}

function showToast(title, message, type = 'info', duration = 3000) {
    const toastContainer = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

function loadImageTemplate() { document.getElementById('imageFileInput').click(); }
function handleImageFileSelect(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height; const planeWidth = GRID * VS; const planeHeight = planeWidth / aspectRatio;
            if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);
            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.5 * VS);
            templateImageMesh.rotation.y = Math.PI; templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = { src: base64Image, position: templateImageMesh.position.toArray(), rotation: templateImageMesh.rotation.toArray(), scale: [1, 1, 1], scaledWidth: planeWidth, scaledHeight: planeHeight };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden'); showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success');
        };
        img.src = base64Image;
    };
    reader.readAsDataURL(file);
}
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info');
    }
}

function getCurrentBlockDimensions(isDragging = false, isShiftOrControl = false) {
    // For freehand modes (FREE_ADD, DELETE, DRAW), always operate on 1x1x1 voxels.
    // The Shift/Ctrl keys are ignored in these modes for simplicity and intuitive freehand drawing.
    if (currentMode === Modes.FREE_ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
        return { dimX: 1, dimY: 1, dimZ: 1 };
    }

    // For LINE_ADD mode, or when Shift/Ctrl is held (for line/stack drawing in LINE_ADD mode)
    let dimX = 1, dimY = 1, dimZ = 1;
    if (useDynamicBlockDim) {
        dimX = dynamicBlockDim.x;
        dimY = dynamicBlockDim.y;
        dimZ = dynamicBlockDim.z;
    } else {
        // For fixed block sizes, the dimensions depend on the drawing axis
        if (currentDrawingAxis === 'y') {
            dimX = currentBlockSize;
            dimZ = currentBlockSize;
        } else if (currentDrawingAxis === 'x') {
            dimY = currentBlockSize;
            dimZ = currentBlockSize;
        } else { // currentDrawingAxis === 'z'
            dimX = currentBlockSize;
            dimY = currentBlockSize;
        }
    }
    return { dimX: Math.max(1, dimX), dimY: Math.max(1, dimY), dimZ: Math.max(1, dimZ) };
}

async function loginLogout() {
    if (auth.currentUser) { try { await window.firebase.signOut(auth); showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info'); } catch (e) { console.error("Error signing out:", e); showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error'); } }
    else openAuthModal();
}

function openUploadModal() {
    if (!currentUserId) { openAuthModal(); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschlagen', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning'); return; }
    document.getElementById('uploadTitle').value = projectTitle; document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory; document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true; // Corrected to use value directly
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie ausw√§hlen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;
    document.getElementById('uploadProjectModal').showModal();
}

async function uploadProjectToHub() {
    if (!currentUserId) { showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error'); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschlagen', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning'); return; }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;
    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel f√ºr Ihr Projekt ein.', 'warning'); return; }
    if (!category) { showToast('Fehler', 'Bitte w√§hlen Sie eine Kategorie f√ºr Ihr Projekt aus.', 'warning'); return; }
    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {}; voxels.forEach((v, k) => { const [gx, gy, gz] = parseKey(k); voxelMap[`${gx},${gy},${gz}`] = v.color; });
        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            currentBlockSize: currentBlockSize, dynamicBlockDim: dynamicBlockDim, useDynamicBlockDim: useDynamicBlockDim,
            templateImageData: null
        };
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.firebase.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, activeDrawingLevel: activeDrawingLevel, activePresetIndex: activePresetIndex,
                cameraPosition: firestoreSafeSettings.cameraPosition, cameraQuaternion: firestoreSafeSettings.cameraQuaternion,
                currentAnchorPoint: { x: "start", y: "start", z: "start" }, currentBlockSize: currentBlockSize,
                currentColor: currentColor, currentDrawingAxis: currentDrawingAxis, dynamicBlockDim: dynamicBlockDim,
                gridSize: GRID, moveSpeed: moveSpeed, presetColors: presetColors, templateImageData: null, voxels: voxelMap
            }
        };
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, "models"), firestoreDocument);
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success');
    } catch (e) { console.error("Error uploading project:", e); showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error'); }
    finally { document.getElementById('uploadProjectModal').close(); }
}

function openAuthModal() { document.getElementById('authModal').showModal(); document.getElementById('emailLoginForm').classList.add('hidden'); }
function closeAuthModal() { document.getElementById('authModal').close(); cvs.focus(); }

window.signInWithGoogle = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing in with Google:", e); showToast('Anmeldefehler', `Google: ${e.message}`, 'error'); } }
window.signInWithGithub = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing in with GitHub:", e); showToast('Anmelmeldefehler', `GitHub: ${e.message}`, 'error'); } }
window.signInEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.signInWithEmailAndPassword(auth, email, password); showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing in with Email/Password:", e); showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error'); } }
window.signUpEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.createUserWithEmailAndPassword(auth, email, password); showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing up with Email/Password:", e); showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error'); } }

function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal'];
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

// Event handlers defined here to ensure they are in scope for window.onload
function onPointerLockChange() {
    if (document.pointerLockElement === cvs) { isPointerLocked = true; firstMoveAfterLock = true; mouseMovementX = mouseMovementY = 0; updatePreviewVoxel(0,0,0,false); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
    else { isPointerLocked = false; }
}

function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) {
        if (currentMode === Modes.LINE_ADD || currentMode === Modes.FREE_ADD) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else { cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5); }
    } else {
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {};
function onKeyDown(e) {
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal'].some(id => document.getElementById(id).open);
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true;
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault();
    if (e.key === 'Tab') { if (!(document.activeElement && document.activeElement.classList.contains('dynamic-block-input'))) { e.preventDefault(); cycleMode(); }}
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false;
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

function onPointerLeave(e) {
    if (e.pointerType === 'mouse') {
        if (!rightMouseButtonDown || (pointerIsDown && e.button === 0)) {
            if (pointerIsDown && initialDragVoxelCoords) {
                // Determine if it was a freehand drag or line/stack drag
                const isFreehandMode = (currentMode === Modes.FREE_ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW);
                const isLineOrStackDrag = (currentMode === Modes.LINE_ADD || isShiftDragging || isControlDragging);

                if (isFreehandMode && !isLineOrStackDrag) {
                    // End of freehand drag (mouse)
                    if (currentStrokeVoxels.size > 0) {
                        const oldState = []; const newState = [];
                        for (const [gKey, change] of currentStrokeVoxels.entries()) {
                            const [gx, gy, gz] = parseKey(gKey); oldState.push({ gx, gy, gz, color: change.initialColor });
                            newState.push({ gx, gy, gz, color: voxels.has(gKey) ? voxels.get(gKey).color : null });
                        } addCommand('batch', oldState, newState);
                    }
                } else if (isLineOrStackDrag) {
                    // End of line/stack drag (mouse)
                    applyStrokeChanges([], voxelsAtDragStart, currentMode, currentColor); // Rollback live changes
                    const oldState = [...voxelsAtDragStart.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
                    const { dimX, dimY, dimZ } = getCurrentBlockDimensions(false, isShiftDragging || isControlDragging); // Get final action dimensions
                    let finalTarget = null;
                    // For line/stack drag, if pointer leaves, use the last valid target or initial point
                    if (lastActionVoxelCoords) {
                        finalTarget = lastActionVoxelCoords;
                    } else {
                        finalTarget = initialDragVoxelCoords;
                    }
                    
                    if (finalTarget) { finalTarget.gx = Math.max(0, Math.min(GRID - dimX, finalTarget.gx)); finalTarget.gy = Math.max(0, Math.min(GRID - dimY, finalTarget.gy)); finalTarget.gz = Math.max(0, Math.min(GRID - dimZ, finalTarget.gz)); }
                    
                    const finalVoxels = finalTarget ? getVoxelsOnLine(initialDragVoxelCoords, finalTarget, currentMode, currentColor, dimX, dimY, dimZ) : [];
                    for (const v of finalVoxels) performVoxelModification(v.gx, v.gy, v.gz, currentMode, currentColor);
                    addCommand('batch', oldState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }));
                }
            }
            // Reset all states and previews after any pointer up
            pointerIsDown = false; lastActionVoxelCoords = null; initialDragVoxelCoords = null; voxelsAtDragStart = null; currentStrokeVoxels.clear();
            updatePreviewVoxel(0, 0, 0, false);
            if (currentMode !== Modes.MEASURE || (currentMode === Modes.MEASURE && measurementStartPoint === null && measurementEndPoint === null)) distanceDisplay.classList.add('hidden');
            initialDragVoxelWorldPos = null; dragAxisLock = null;
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        }
    }
}

function updateBlockSizeButtonsActiveState() {
    document.querySelectorAll('.block-size-btn').forEach(btn => btn.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
    document.getElementById('setDynamicBlockSizeBtn').classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50');
    if (useDynamicBlockDim) { document.getElementById('setDynamicBlockSizeBtn').classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
    else {
        const activeBtn = document.getElementById(`block-size-${currentBlockSize}x${currentBlockSize}`);
        if (activeBtn) { activeBtn.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        else { document.getElementById('block-size-1x1').classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); currentBlockSize = 1; localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize); }
    }
}

let pointerIsDown = false; let rightMouseButtonDown = false;
let lastX, lastY; let suppressNextTap = false;
let initialDragVoxelCoords = null;

function applyStrokeChanges(voxelsToApply, initialVoxelsState, mode, color) {
    // Revert previous live changes
    for (const [gKey, change] of currentStrokeVoxels.entries()) {
        const [gx, gy, gz] = parseKey(gKey);
        if (initialVoxelsState.has(gKey)) {
            _addSingleVoxel(gx, gy, gz, initialVoxelsState.get(gKey).color);
        } else {
            _removeSingleVoxel(gx, gy, gz);
        }
    }
    currentStrokeVoxels.clear();

    // Apply new changes
    for (const voxel of voxelsToApply) {
        const gKey = key(voxel.gx, voxel.gy, voxel.gz);
        const hasVoxelBeforeDrag = initialVoxelsState.has(gKey);
        const initialColor = hasVoxelBeforeDrag ? initialVoxelsState.get(gKey).color : null;
        
        performVoxelModification(voxel.gx, voxel.gy, voxel.gz, mode, color);
        
        // Record the change for potential future rollback
        currentStrokeVoxels.set(gKey, { newColor: color, initialColor: initialColor });
    }
}

function onPointerUp(e) {
    const isShiftOrControl = isShiftDragging || isControlDragging;
    const isFreehandMode = (currentMode === Modes.FREE_ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW);
    const isLineOrStackDrag = (currentMode === Modes.LINE_ADD || isShiftOrControl);

    if (e.pointerType === 'touch') {
        if (suppressNextTap) { suppressNextTap = false; }
        else if (activePointers.size === 1 && !doubleTapDragActive && currentMode !== Modes.MEASURE) {
            // Single tap for non-drag action
            const movedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
            if (movedDist <= TAP_DIST_TH) {
                 const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                 if (clickedVoxel) {
                     // For single tap in freehand modes, action is always 1x1x1
                     const { dimX: actionDimX, dimY: actionDimY, dimZ: actionDimZ } = getCurrentBlockDimensions(false, isShiftOrControl);
                     clickedVoxel.gx = Math.max(0, Math.min(GRID - actionDimX, clickedVoxel.gx));
                     clickedVoxel.gy = Math.max(0, Math.min(GRID - actionDimY, clickedVoxel.gy));
                     clickedVoxel.gz = Math.max(0, Math.min(GRID - actionDimZ, clickedVoxel.gz));

                     const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
                     const voxelsToModify = getVoxelsOnLine(clickedVoxel, clickedVoxel, currentMode, currentColor, actionDimX, actionDimY, actionDimZ);
                     for(const v of voxelsToModify) performVoxelModification(v.gx, v.gy, v.gz, currentMode, currentColor);
                     addCommand('batch', oldState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }));
                 }
            }
        }
        if (doubleTapDragActive && currentMode !== Modes.MEASURE && initialDragVoxelCoords) {
            // End of continuous drag (touch)
            if (isFreehandMode && !isLineOrStackDrag) {
                // Freehand mode
                if (currentStrokeVoxels.size > 0) {
                    const oldState = []; const newState = [];
                    for (const [gKey, change] of currentStrokeVoxels.entries()) {
                        const [gx, gy, gz] = parseKey(gKey); oldState.push({ gx, gy, gz, color: change.initialColor });
                        newState.push({ gx, gy, gz, color: voxels.has(gKey) ? voxels.get(gKey).color : null });
                    } addCommand('batch', oldState, newState);
                }
            } else if (isLineOrStackDrag) {
                // Line/Stack mode
                applyStrokeChanges([], voxelsAtDragStart, currentMode, currentColor); // Rollback live changes
                const oldState = [...voxelsAtDragStart.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
                let finalTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                const { dimX: actionDimX, dimY: actionDimY, dimZ: actionDimZ } = getCurrentBlockDimensions(false, isShiftOrControl); // Get final action dimensions

                if (finalTarget) {
                    if (dragAxisLock) {
                        const snappedFinalTarget = { ...finalTarget };
                        if (dragAxisLock === 'x') { snappedFinalTarget.gy = initialDragVoxelCoords.gy; snappedFinalTarget.gz = initialDragVoxelCoords.gz; }
                        else if (dragAxisLock === 'y') { snappedFinalTarget.gx = initialDragVoxelCoords.gx; snappedFinalTarget.gz = initialDragVoxelCoords.gz; }
                        else if (dragAxisLock === 'z') { snappedFinalTarget.gx = initialDragVoxelCoords.gx; snappedFinalTarget.gy = initialDragVoxelCoords.gy; }
                        finalTarget = snappedFinalTarget;
                    } else { finalTarget = initialDragVoxelCoords; } // If no drag lock, just use the initial point
                    if (finalTarget) {
                        finalTarget.gx = Math.max(0, Math.min(GRID - actionDimX, finalTarget.gx));
                        finalTarget.gy = Math.max(0, Math.min(GRID - actionDimY, finalTarget.gy));
                        finalTarget.gz = Math.max(0, Math.min(GRID - actionDimZ, finalTarget.gz));
                    }
                } else { finalTarget = initialDragVoxelCoords; } // Fallback if final target is null

                const finalVoxels = finalTarget ? getVoxelsOnLine(initialDragVoxelCoords, finalTarget, currentMode, currentColor, actionDimX, actionDimY, actionDimZ) : [];
                for (const v of finalVoxels) performVoxelModification(v.gx, v.gy, v.gz, currentMode, currentColor);
                addCommand('batch', oldState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }));
            }
        }
        releasePointer(e.pointerId, e);
        // Reset all previews and states after touch up
        updatePreviewVoxel(0, 0, 0, false);
        distanceDisplay.classList.add('hidden');
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        initialDragVoxelWorldPos = null; dragAxisLock = null; currentStrokeVoxels.clear();
        return;
    }

    if (e.pointerType === 'mouse') {
        if (e.button === 2) { rightMouseButtonDown = false; document.exitPointerLock(); return; }
        const movedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleClick = movedDist <= MOVE_PX;

        if (currentMode === Modes.MEASURE) {
            // Measurement mode doesn't commit on mouse up, just updates display
            updatePreviewVoxel(0, 0, 0, false); previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            pointerIsDown = false; return;
        }

        if (pointerIsDown && !isPointerLocked && initialDragVoxelCoords) {
            const isFreehandMode = (currentMode === Modes.FREE_ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW);
            const isLineOrStackDrag = (currentMode === Modes.LINE_ADD || isShiftOrControl);

            if (isFreehandMode && !isLineOrStackDrag) {
                // End of freehand drag (mouse)
                if (currentStrokeVoxels.size > 0) {
                    const oldState = []; const newState = [];
                    for (const [gKey, change] of currentStrokeVoxels.entries()) {
                        const [gx, gy, gz] = parseKey(gKey); oldState.push({ gx, gy, gz, color: change.initialColor });
                        newState.push({ gx, gy, gz, color: voxels.has(gKey) ? voxels.get(gKey).color : null });
                    } addCommand('batch', oldState, newState);
                }
            } else if (isLineOrStackDrag) {
                // Line/Stack mode
                applyStrokeChanges([], voxelsAtDragStart, currentMode, currentColor); // Rollback live changes
                const oldState = [...voxelsAtDragStart.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
                let finalTarget = null;
                let rawFinalTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
                const { dimX: actionDimX, dimY: actionDimY, dimZ: actionDimZ } = getCurrentBlockDimensions(false, isShiftOrControl); // Get final action dimensions

                if (rawFinalTarget) {
                    if (dragAxisLock) {
                        const snappedFinalTarget = { ...rawFinalTarget };
                        if (dragAxisLock === 'x') { snappedFinalTarget.gy = initialDragVoxelCoords.gy; snappedFinalTarget.gz = initialDragVoxelCoords.gz; }
                        else if (dragAxisLock === 'y') { snappedFinalTarget.gx = initialDragVoxelCoords.gx; snappedFinalTarget.gz = initialDragVoxelCoords.gz; }
                        else if (dragAxisLock === 'z') { snappedFinalTarget.gx = initialDragVoxelCoords.gx; snappedFinalTarget.gy = initialDragVoxelCoords.gy; }
                        finalTarget = snappedFinalTarget;
                    } else if (wasSingleClick) {
                        finalTarget = rawFinalTarget; // For single click, use the hovered target
                    } else {
                        finalTarget = initialDragVoxelCoords; // If dragged but no axis lock, revert to initial point
                    }
                    if (finalTarget) {
                        finalTarget.gx = Math.max(0, Math.min(GRID - actionDimX, finalTarget.gx));
                        finalTarget.gy = Math.max(0, Math.min(GRID - actionDimY, finalTarget.gy));
                        finalTarget.gz = Math.max(0, Math.min(GRID - actionDimZ, finalTarget.gz));
                    }
                } else {
                    finalTarget = initialDragVoxelCoords; // Fallback if no raw target
                }

                const finalVoxels = finalTarget ? getVoxelsOnLine(initialDragVoxelCoords, finalTarget, currentMode, currentColor, actionDimX, actionDimY, actionDimZ) : [];
                for (const v of finalVoxels) performVoxelModification(v.gx, v.gy, v.gz, currentMode, currentColor);
                addCommand('batch', oldState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }));
            }
        }
    }
    // Reset all states and previews after any pointer up
    pointerIsDown = false; isControlDragging = false; isShiftDragging = false; lastActionVoxelCoords = null;
    initialClickPos = null; initialDragVoxelCoords = null; voxelsAtDragStart = null; currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
    distanceDisplay.classList.add('hidden');
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    initialDragVoxelWorldPos = null; dragAxisLock = null;
}


function getPointOnFixedPlane(clientX, clientY, axis, level) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1, -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster(); raycaster.setFromCamera(mouse, cam);
    let planeNormal = new THREE.Vector3();
    if (axis === 'y') planeNormal.set(0, 1, 0); else if (axis === 'x') planeNormal.set(1, 0, 0); else if (axis === 'z') planeNormal.set(0, 0, 1);
    const drawingPlane = new THREE.Plane(planeNormal, -(level * VS));
    const intersectionPoint = new THREE.Vector3();
    if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
        let gx = Math.floor(intersectionPoint.x / VS); let gy = Math.floor(intersectionPoint.y / VS); let gz = Math.floor(intersectionPoint.z / VS);
        if (axis === 'y') gy = level; else if (axis === 'x') gx = level; else if (axis === 'z') gz = level;
        const { dimX, dimY, dimZ } = getCurrentBlockDimensions(); // This will return 1x1x1 for freehand modes
        gx = Math.max(0, Math.min(GRID - 1, gx)); gy = Math.max(0, Math.min(GRID - 1, gy)); gz = Math.max(0, Math.min(GRID - 1, gz));
        return { gx, gy, gz };
    } return null;
}

function setFixedBlockSize(size) {
    currentBlockSize = size; useDynamicBlockDim = false;
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize); localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);
    updateBlockSizeButtonsActiveState();
    const rect = cvs.getBoundingClientRect(); const mouseX = lastX - rect.left; const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        onPointerMove(new MouseEvent('mousemove', { clientX: lastX, clientY: lastY, buttons: pointerIsDown ? 1 : 0 }));
    } else { updatePreviewVoxel(0,0,0,false); previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = []; }
}

function setDynamicBlockDimensions() {
    dynamicBlockDim.x = Math.max(1, Math.min(GRID, parseInt(document.getElementById('dynamic-block-x').value)));
    dynamicBlockDim.y = Math.max(1, Math.min(GRID, parseInt(document.getElementById('dynamic-block-y').value)));
    dynamicBlockDim.z = Math.max(1, Math.min(GRID, parseInt(document.getElementById('dynamic-block-z').value)));
    document.getElementById('dynamic-block-x').value = dynamicBlockDim.x; document.getElementById('dynamic-block-y').value = dynamicBlockDim.y; document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;
    useDynamicBlockDim = true;
    localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x); localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y); localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z); localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);
    updateBlockSizeButtonsActiveState();
    const rect = cvs.getBoundingClientRect(); const mouseX = lastX - rect.left; const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        onPointerMove(new MouseEvent('mousemove', { clientX: lastX, clientY: lastY, buttons: pointerIsDown ? 1 : 0 }));
    } else { updatePreviewVoxel(0,0,0,false); previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = []; }
}

function getVoxelsOnLine(start, end, mode, color, dimX, dimY, dimZ) {
    if (!Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) { console.error("getVoxelsOnLine: Invalid (non-finite) start or end coordinates.", start, end); return []; }
    const voxelsOnLineSet = new Set();
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;
    let dm = Math.max(dx, dy, dz);
    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm, p2 = 2 * dz - dm;

    for (let i = 0; i <= dm; i++) {
        for (let xOff = 0; xOff < dimX; xOff++) { for (let yOff = 0; yOff < dimY; yOff++) { for (let zOff = 0; zOff < dimZ; zOff++) {
            const clampedX = Math.max(0, Math.min(GRID - 1, x + xOff));
            const clampedY = Math.max(0, Math.min(GRID - 1, y + yOff));
            const clampedZ = Math.max(0, Math.min(GRID - 1, z + zOff));
            voxelsOnLineSet.add(key(clampedX, clampedY, clampedZ));
        }}}
        if (dm === dx) { y += sy * (p1 > 0); p1 += 2 * dy; z += sz * (p2 > 0); p2 += 2 * dz; }
        else if (dm === dy) { x += sx * (p1 > 0); p1 += 2 * dx; z += sz * (p2 > 0); p2 += 2 * dz; }
        else { x += sx * (p1 > 0); p1 += 2 * dy; y += sy * (p2 > 0); p2 += 2 * dx; }
        if (dm === dx) x += sx; else if (dm === dy) y += sy; else z += sz;
    }
    return Array.from(voxelsOnLineSet).map(k => { const p = parseKey(k); return { gx: p[0], gy: p[1], gz: p[2], color: color }; });
}

function updatePreviewLineMesh() {
    previewLineInstancedMesh.count = 0;
    for (let i = 0; i < previewLineVoxels.length && i < maxPreviewInstances; i++) {
        const v = previewLineVoxels[i];
        dummy.position.set(v.gx * VS + HALF, v.gy * VS + HALF, v.gz * VS + HALF); dummy.updateMatrix();
        previewLineInstancedMesh.setMatrixAt(i, dummy.matrix);
        previewLineInstancedMesh.instanceColor.setXYZ(i, currentMode === Modes.DELETE ? 1 : 0, currentMode === Modes.DELETE ? 0 : 1, 0);
        previewLineInstancedMesh.count++;
    }
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineInstancedMesh.instanceColor.needsUpdate = true;
}

function onPointerDown(e) {
    if (e.button === 2) { e.preventDefault(); rightMouseButtonDown = true; cvs.requestPointerLock(); cvs.focus(); return; }
    if (isPointerLocked) return;
    dragAxisLock = null;
    const isShiftOrControl = isShiftDragging || isControlDragging;
    const isFreehandMode = (currentMode === Modes.FREE_ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW);
    const isLineOrStackDrag = (currentMode === Modes.LINE_ADD || isShiftOrControl);

    if (e.pointerType === 'touch') {
        if (suppressNextTap) { suppressNextTap = false; return; }
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.display = 'block'; touchIndicator.style.left = `${e.clientX}px`; touchIndicator.style.top = `${e.clientY}px`;
        const now = performance.now();

        if (tapCandidate && (now - tapCandidate.time < DT_MS) && (Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH)) {
            // Double tap for continuous drag
            doubleTapDragActive = true; tapCandidate = null;
            if (currentMode !== Modes.MEASURE) {
                let rawTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                if (rawTarget) {
                    const { dimX: actionDimX, dimY: actionDimY, dimZ: actionDimZ } = getCurrentBlockDimensions(true, isShiftOrControl); // Get actual action dimensions
                    rawTarget.gx = Math.max(0, Math.min(GRID - actionDimX, rawTarget.gx));
                    rawTarget.gy = Math.max(0, Math.min(GRID - actionDimY, rawTarget.gy));
                    rawTarget.gz = Math.max(0, Math.min(GRID - actionDimZ, rawTarget.gz));

                    initialDragVoxelCoords = rawTarget;
                    voxelsAtDragStart = new Map(voxels);
                    currentStrokeVoxels.clear();
                    
                    if (isFreehandMode && !isLineOrStackDrag) {
                        performVoxelModification(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz, currentMode, currentColor);
                        currentStrokeVoxels.set(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz), { newColor: voxels.has(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)) ? voxels.get(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)).color : null, initialColor: voxelsAtDragStart.has(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)) ? voxelsAtDragStart.get(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)).color : null });
                        updatePreviewVoxel(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz, true, 1, 1, 1); // Show 1x1x1 preview
                        previewLineInstancedMesh.count = 0; // Hide line preview
                    } else if (isLineOrStackDrag) {
                        const initialVoxels = getVoxelsOnLine(initialDragVoxelCoords, initialDragVoxelCoords, currentMode, currentColor, actionDimX, actionDimY, actionDimZ);
                        for (const v of initialVoxels) {
                            performVoxelModification(v.gx, v.gy, v.gz, currentMode, currentColor);
                            currentStrokeVoxels.set(key(v.gx, v.gy, v.gz), { newColor: currentColor, initialColor: voxelsAtDragStart.has(key(v.gx, v.gy, v.gz)) ? voxelsAtDragStart.get(key(v.gx, v.gy, v.gz)).color : null });
                        }
                        previewLineVoxels = initialVoxels;
                        updatePreviewLineMesh();
                        updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
                    }
                    lastActionVoxelCoords = { ...initialDragVoxelCoords };
                    initialDragVoxelWorldPos = new THREE.Vector3(initialDragVoxelCoords.gx * VS + HALF, initialDragVoxelCoords.gy * VS + HALF, initialDragVoxelCoords.gz * VS + HALF);
                }
            }
        } else {
            // Single tap or start of multi-touch gesture
            tapCandidate = { x: e.clientX, y: e.clientY, time: now };
            initialDragVoxelCoords = null; voxelsAtDragStart = null; initialDragVoxelWorldPos = null; currentStrokeVoxels.clear();
            distanceDisplay.classList.add('hidden');
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false); // Hide preview voxel on new tap/gesture start

            if (currentMode === Modes.MEASURE) {
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                if (clickedVoxel) {
                    // For measure mode, dimX, dimY, dimZ are always 1 for the click target
                    clickedVoxel.gx = Math.max(0, Math.min(GRID - 1, clickedVoxel.gx)); clickedVoxel.gy = Math.max(0, Math.min(GRID - 1, clickedVoxel.gy)); clickedVoxel.gz = Math.max(0, Math.min(GRID - 1, clickedVoxel.gz));
                    if (measurementStartPoint === null) {
                        measurementStartPoint = { ...clickedVoxel }; measurementEndPoint = null; distanceDisplay.classList.add('hidden');
                        previewLineVoxels = [{ gx: measurementStartPoint.gx, gy: measurementStartPoint.gy, gz: measurementStartPoint.gz }]; updatePreviewLineMesh();
                    } else {
                        measurementEndPoint = { ...clickedVoxel };
                        const dist = new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(new THREE.Vector3(measurementEndPoint.gx * VS, measurementEndPoint.gy * VS, measurementEndPoint.gz * VS));
                        distanceDisplay.textContent = `Distanz: ${dist.toFixed(2)} mm`; distanceDisplay.classList.remove('hidden');
                        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
                        measurementStartPoint = null; measurementEndPoint = null;
                    }
                } return;
            }
        }
        gestureState.initialPointerCount = activePointers.size;
        if (activePointers.size === 1) { gestureState.type = 'rotate'; gestureState.lastMid = { x: e.clientX, y: e.clientY }; }
        else if (activePointers.size >= 2) {
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
        }
        initialClickPos = { x: e.clientX, y: e.clientY }; return;
    }

    // Mouse pointer handling
    if (e.pointerType === 'mouse' && e.button === 0) {
        pointerIsDown = true; lastX = e.clientX; lastY = e.clientY; initialClickPos = { x: e.clientX, y: e.clientY };
        updatePreviewVoxel(0, 0, 0, false); // Hide preview on mouse down until movement or specific mode
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        distanceDisplay.classList.add('hidden');

        if (currentMode === Modes.MEASURE) {
            const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (clickedVoxel) {
                // For measure mode, dimX, dimY, dimZ are always 1 for the click target
                clickedVoxel.gx = Math.max(0, Math.min(GRID - 1, clickedVoxel.gx)); clickedVoxel.gy = Math.max(0, Math.min(GRID - 1, clickedVoxel.gy)); clickedVoxel.gz = Math.max(0, Math.min(GRID - 1, clickedVoxel.gz));
                if (measurementStartPoint === null) {
                    measurementStartPoint = { ...clickedVoxel }; measurementEndPoint = null; distanceDisplay.classList.add('hidden');
                    previewLineVoxels = [{ gx: measurementStartPoint.gx, gy: measurementStartPoint.gy, gz: measurementStartPoint.gz }]; updatePreviewLineMesh();
                } else {
                    measurementEndPoint = { ...clickedVoxel };
                    const dist = new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(new THREE.Vector3(measurementEndPoint.gx * VS, measurementEndPoint.gy * VS, measurementEndPoint.gz * VS));
                    distanceDisplay.textContent = `Distanz: ${dist.toFixed(2)} mm`; distanceDisplay.classList.remove('hidden');
                    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
                    measurementStartPoint = null; measurementEndPoint = null;
                }
            } pointerIsDown = false; return;
        }

        let rawTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
        if (!rawTarget) { // If no target voxel, don't start an action
            pointerIsDown = false; initialClickPos = null; return;
        }

        if (isFreehandMode && !isLineOrStackDrag) {
            // Start of freehand drag (mouse)
            initialDragVoxelCoords = rawTarget;
            dragAxisLock = null;
            voxelsAtDragStart = new Map(voxels);
            currentStrokeVoxels.clear();

            const { dimX: actionDimX, dimY: actionDimY, dimZ: actionDimZ } = getCurrentBlockDimensions(true, isShiftOrControl); // Always 1x1x1 for freehand
            initialDragVoxelCoords.gx = Math.max(0, Math.min(GRID - actionDimX, initialDragVoxelCoords.gx));
            initialDragVoxelCoords.gy = Math.max(0, Math.min(GRID - actionDimY, initialDragVoxelCoords.gy));
            initialDragVoxelCoords.gz = Math.max(0, Math.min(GRID - actionDimZ, initialDragVoxelCoords.gz));

            performVoxelModification(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz, currentMode, currentColor);
            currentStrokeVoxels.set(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz), { newColor: voxels.has(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)) ? voxels.get(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)).color : null, initialColor: voxelsAtDragStart.has(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)) ? voxelsAtDragStart.get(key(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz)).color : null });
            lastActionVoxelCoords = { ...initialDragVoxelCoords };
            updatePreviewVoxel(initialDragVoxelCoords.gx, initialDragVoxelCoords.gy, initialDragVoxelCoords.gz, true, actionDimX, actionDimY, actionDimZ); // Show preview for first voxel
            previewLineInstancedMesh.count = 0; // Hide line preview
            return;
        } else if (isLineOrStackDrag) {
            // Start of line/stack drag (mouse)
            if (isControlDragging && currentMode === Modes.LINE_ADD) { initialDragVoxelCoords = { gx: rawTarget.gx, gy: rawTarget.gy, gz: rawTarget.gz }; dragAxisLock = 'y'; }
            else if (isShiftDragging) { initialDragVoxelCoords = getPointOnFixedPlane(e.clientX, e.clientY, currentDrawingAxis, activeDrawingLevel[currentDrawingAxis]) || rawTarget; dragAxisLock = null; }
            else { initialDragVoxelCoords = rawTarget; dragAxisLock = null; }

            const { dimX: actionDimX, dimY: actionDimY, dimZ: actionDimZ } = getCurrentBlockDimensions(true, isShiftOrControl); // Get actual action dimensions
            initialDragVoxelCoords.gx = Math.max(0, Math.min(GRID - actionDimX, initialDragVoxelCoords.gx));
            initialDragVoxelCoords.gy = Math.max(0, Math.min(GRID - actionDimY, initialDragVoxelCoords.gy));
            initialDragVoxelCoords.gz = Math.max(0, Math.min(GRID - actionDimZ, initialDragVoxelCoords.gz));

            voxelsAtDragStart = new Map(voxels);
            currentStrokeVoxels.clear(); // This will be used for live preview rollback
            const initialVoxels = getVoxelsOnLine(initialDragVoxelCoords, initialDragVoxelCoords, currentMode, currentColor, actionDimX, actionDimY, actionDimZ);
            for (const v of initialVoxels) {
                performVoxelModification(v.gx, v.gy, v.gz, currentMode, currentColor);
                currentStrokeVoxels.set(key(v.gx, v.gy, v.gz), { newColor: currentColor, initialColor: voxelsAtDragStart.has(key(v.gx, v.gy, v.gz)) ? voxelsAtDragStart.get(key(v.gx, v.gy, v.gz)).color : null });
            }
            lastActionVoxelCoords = { ...initialDragVoxelCoords };
            initialDragVoxelWorldPos = new THREE.Vector3(initialDragVoxelCoords.gx * VS + HALF, initialDragVoxelCoords.gy * VS + HALF, initialDragVoxelCoords.gz * VS + HALF);
            distanceDisplay.classList.remove('hidden');
            previewLineVoxels = initialVoxels;
            updatePreviewLineMesh();
            updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            return;
        }
    }
}

function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) return;

    lastX = e.clientX;
    lastY = e.clientY;

    const isShiftOrControl = isShiftDragging || isControlDragging;
    const isFreehandMode = (currentMode === Modes.FREE_ADD || currentMode === Modes.DELETE || currentMode === Modes.DRAW);
    const isLineOrStackDrag = (currentMode === Modes.LINE_ADD || isShiftOrControl);

    // Get dimensions for the current *action*, which might be different from hover dimensions
    const { dimX, dimY, dimZ } = getCurrentBlockDimensions(true, isShiftOrControl);

    if (e.pointerType === 'touch') {
        if (!activePointers.has(e.pointerId)) return;
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.left = `${e.clientX}px`;
        touchIndicator.style.top = `${e.clientY}px`;

        if (doubleTapDragActive && currentMode !== Modes.MEASURE) {
            // This is a continuous drag for voxel modification (add/delete/draw)
            let rawCurrentTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');

            if (rawCurrentTarget) {
                if (isFreehandMode && !isLineOrStackDrag) {
                    // Freehand mode (no Shift/Ctrl)
                    rawCurrentTarget.gx = Math.max(0, Math.min(GRID - 1, rawCurrentTarget.gx));
                    rawCurrentTarget.gy = Math.max(0, Math.min(GRID - 1, rawCurrentTarget.gy));
                    rawCurrentTarget.gz = Math.max(0, Math.min(GRID - 1, rawCurrentTarget.gz));

                    if (!lastActionVoxelCoords || key(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz) !== key(lastActionVoxelCoords.gx, lastActionVoxelCoords.gy, lastActionVoxelCoords.gz)) {
                        performVoxelModification(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz, currentMode, currentColor);
                        const currentGKey = key(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz);
                        if (!currentStrokeVoxels.has(currentGKey)) {
                            currentStrokeVoxels.set(currentGKey, { newColor: voxels.has(currentGKey) ? voxels.get(currentGKey).color : null, initialColor: voxelsAtDragStart.has(currentGKey) ? voxelsAtDragStart.get(currentGKey).color : null });
                        } else if (currentMode === Modes.DRAW && voxels.has(currentGKey) && voxels.get(currentGKey).color !== currentColor) {
                            currentStrokeVoxels.get(currentGKey).newColor = currentColor;
                        }
                        lastActionVoxelCoords = { ...rawCurrentTarget };
                    }
                    updatePreviewVoxel(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz, true, 1, 1, 1); // Always 1x1x1 for freehand preview
                    previewLineInstancedMesh.count = 0; // Hide line preview
                    distanceDisplay.classList.add('hidden'); // Hide distance display
                    return;
                } else if (isLineOrStackDrag && initialDragVoxelCoords) {
                    // Line/Stack mode (LINE_ADD or with Shift/Ctrl)
                    let finalTarget = null;
                    if (dragAxisLock === null) {
                        const dx = Math.abs(rawCurrentTarget.gx - initialDragVoxelCoords.gx);
                        const dy = Math.abs(rawCurrentTarget.gy - initialDragVoxelCoords.gy);
                        const dz = Math.abs(rawCurrentTarget.gz - initialDragVoxelCoords.gz);
                        if (dx > VOXEL_DRAG_THRESHOLD || dy > VOXEL_DRAG_THRESHOLD || dz > VOXEL_DRAG_THRESHOLD) {
                            if (isControlDragging && currentMode === Modes.LINE_ADD) dragAxisLock = 'y';
                            else if (isShiftDragging) {
                                if (currentDrawingAxis === 'y') dragAxisLock = (dx >= dz) ? 'x' : 'z';
                                else if (currentDrawingAxis === 'x') dragAxisLock = (dy >= dz) ? 'y' : 'z';
                                else dragAxisLock = (dx >= dy) ? 'x' : 'y';
                            } else {
                                if (dx >= dy && dx >= dz) dragAxisLock = 'x';
                                else if (dy >= dx && dy >= dz) dragAxisLock = 'y';
                                else dragAxisLock = 'z';
                            }
                        }
                    }
                    if (dragAxisLock) {
                        finalTarget = { ...rawCurrentTarget };
                        if (dragAxisLock === 'x') { finalTarget.gy = initialDragVoxelCoords.gy; finalTarget.gz = initialDragVoxelCoords.gz; }
                        else if (dragAxisLock === 'y') { finalTarget.gx = initialDragVoxelCoords.gx; finalTarget.gz = initialDragVoxelCoords.gz; }
                        else if (dragAxisLock === 'z') { finalTarget.gx = initialDragVoxelCoords.gx; finalTarget.gy = initialDragVoxelCoords.gy; }
                    } else {
                        finalTarget = initialDragVoxelCoords;
                    }
                    if (finalTarget) {
                        finalTarget.gx = Math.max(0, Math.min(GRID - dimX, finalTarget.gx));
                        finalTarget.gy = Math.max(0, Math.min(GRID - dimY, finalTarget.gy));
                        finalTarget.gz = Math.max(0, Math.min(GRID - dimZ, finalTarget.gz));
                    }

                    if (dragAxisLock && finalTarget) {
                        const voxelsToDraw = getVoxelsOnLine(initialDragVoxelCoords, finalTarget, currentMode, currentColor, dimX, dimY, dimZ);
                        applyStrokeChanges(voxelsToDraw, voxelsAtDragStart, currentMode, currentColor);
                        lastActionVoxelCoords = { ...finalTarget };
                        distanceDisplay.textContent = `Distanz: ${initialDragVoxelWorldPos.distanceTo(new THREE.Vector3(finalTarget.gx * VS + HALF, finalTarget.gy * VS + HALF, finalTarget.gz * VS + HALF)).toFixed(2)} mm`;
                        distanceDisplay.classList.remove('hidden');
                        previewLineVoxels = voxelsToDraw;
                        updatePreviewLineMesh();
                        updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
                    } else {
                        distanceDisplay.classList.add('hidden');
                        previewLineInstancedMesh.count = 0;
                        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                        previewLineVoxels = [];
                        updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
                    }
                    return;
                }
            }
        } else if (currentMode === Modes.MEASURE && measurementStartPoint) {
            const currentTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
            if (currentTarget) {
                currentTarget.gx = Math.max(0, Math.min(GRID - 1, currentTarget.gx));
                currentTarget.gy = Math.max(0, Math.min(GRID - 1, currentTarget.gy));
                currentTarget.gz = Math.max(0, Math.min(GRID - 1, currentTarget.gz));
                distanceDisplay.textContent = `Distanz: ${new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(new THREE.Vector3(currentTarget.gx * VS, currentTarget.gy * VS, currentTarget.gz * VS)).toFixed(2)} mm`;
                distanceDisplay.classList.remove('hidden');
                previewLineVoxels = getVoxelsOnLine(measurementStartPoint, currentTarget, currentMode, currentColor, 1, 1, 1);
                updatePreviewLineMesh();
                updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            } else {
                distanceDisplay.classList.add('hidden');
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
                updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            }
            return;
        }
        // If not in a drag or measure gesture, handle camera rotation/pan
        handleGesture();
        updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
        distanceDisplay.classList.add('hidden');
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
        return;
    }

    // Mouse pointer handling
    const movedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    const isDraggingVoxelAction = pointerIsDown && (movedDist > MOVE_PX || isShiftOrControl); // Use isShiftOrControl here

    if (currentMode === Modes.MEASURE) {
        if (measurementStartPoint) {
            const tempTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (tempTarget) {
                tempTarget.gx = Math.max(0, Math.min(GRID - 1, tempTarget.gx));
                tempTarget.gy = Math.max(0, Math.min(GRID - 1, tempTarget.gy));
                tempTarget.gz = Math.max(0, Math.min(GRID - 1, tempTarget.gz));
                distanceDisplay.textContent = `Distanz: ${new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(new THREE.Vector3(tempTarget.gx * VS, tempTarget.gy * VS, tempTarget.gz * VS)).toFixed(2)} mm`;
                distanceDisplay.classList.remove('hidden');
                previewLineVoxels = getVoxelsOnLine(measurementStartPoint, tempTarget, currentMode, currentColor, 1, 1, 1);
                updatePreviewLineMesh();
                updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            } else {
                distanceDisplay.classList.add('hidden');
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
                updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            }
        } else {
            const tempTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            updatePreviewVoxel(tempTarget ? tempTarget.gx : 0, tempTarget ? tempTarget.gy : 0, tempTarget ? tempTarget.gz : 0, !!tempTarget, 1, 1, 1); // Always 1x1x1 preview for measure start
            previewLineInstancedMesh.count = 0; // Hide line preview
            distanceDisplay.classList.add('hidden'); // Hide distance display
        }
        return;
    } else {
        let rawCurrentTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');

        if (pointerIsDown && isFreehandMode && !isLineOrStackDrag) {
            // Freehand drag (mouse)
            if (rawCurrentTarget && lastActionVoxelCoords) {
                rawCurrentTarget.gx = Math.max(0, Math.min(GRID - 1, rawCurrentTarget.gx));
                rawCurrentTarget.gy = Math.max(0, Math.min(GRID - 1, rawCurrentTarget.gy));
                rawCurrentTarget.gz = Math.max(0, Math.min(GRID - 1, rawCurrentTarget.gz));

                if (key(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz) !== key(lastActionVoxelCoords.gx, lastActionVoxelCoords.gy, lastActionVoxelCoords.gz)) {
                    performVoxelModification(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz, currentMode, currentColor);
                    const currentGKey = key(rawCurrentTarget.gx, rawCurrentTarget.gy, rawCurrentTarget.gz);
                    if (!currentStrokeVoxels.has(currentGKey)) {
                        currentStrokeVoxels.set(currentGKey, { newColor: voxels.has(currentGKey) ? voxels.get(currentGKey).color : null, initialColor: voxelsAtDragStart.has(currentGKey) ? voxelsAtDragStart.get(currentGKey).color : null });
                    } else if (currentMode === Modes.DRAW && voxels.has(currentGKey) && voxels.get(currentGKey).color !== currentColor) {
                        currentStrokeVoxels.get(currentGKey).newColor = currentColor;
                    }
                    lastActionVoxelCoords = { ...rawCurrentTarget };
                }
            }
            updatePreviewVoxel(rawCurrentTarget ? rawCurrentTarget.gx : 0, rawCurrentTarget ? rawCurrentTarget.gy : 0, rawCurrentTarget ? rawCurrentTarget.gz : 0, !!rawCurrentTarget, 1, 1, 1); // Always 1x1x1 for freehand preview
            previewLineInstancedMesh.count = 0; // Hide line preview
            distanceDisplay.classList.add('hidden'); // Hide distance display
            return;
        } else if (isDraggingVoxelAction && rawCurrentTarget && initialDragVoxelCoords) {
            // Line/Stack drag (mouse)
            let finalTarget = null;
            if (dragAxisLock === null) {
                const dx = Math.abs(rawCurrentTarget.gx - initialDragVoxelCoords.gx);
                const dy = Math.abs(rawCurrentTarget.gy - initialDragVoxelCoords.gy);
                const dz = Math.abs(rawCurrentTarget.gz - initialDragVoxelCoords.gz);
                if (dx > VOXEL_DRAG_THRESHOLD || dy > VOXEL_DRAG_THRESHOLD || dz > VOXEL_DRAG_THRESHOLD) {
                    if (isControlDragging && currentMode === Modes.LINE_ADD) dragAxisLock = 'y';
                    else if (isShiftDragging) {
                        if (currentDrawingAxis === 'y') dragAxisLock = (dx >= dz) ? 'x' : 'z';
                        else if (currentDrawingAxis === 'x') dragAxisLock = (dy >= dz) ? 'y' : 'z';
                        else dragAxisLock = (dx >= dy) ? 'x' : 'y';
                    } else {
                        if (dx >= dy && dx >= dz) dragAxisLock = 'x';
                        else if (dy >= dx && dy >= dz) dragAxisLock = 'y';
                        else dragAxisLock = 'z';
                    }
                }
            }
            if (dragAxisLock) {
                finalTarget = { ...rawCurrentTarget };
                if (dragAxisLock === 'x') { finalTarget.gy = initialDragVoxelCoords.gy; finalTarget.gz = initialDragVoxelCoords.gz; }
                else if (dragAxisLock === 'y') { finalTarget.gx = initialDragVoxelCoords.gx; finalTarget.gz = initialDragVoxelCoords.gz; }
                else if (dragAxisLock === 'z') { finalTarget.gx = initialDragVoxelCoords.gx; finalTarget.gy = initialDragVoxelCoords.gy; }
            } else {
                finalTarget = initialDragVoxelCoords;
            }
            if (finalTarget) {
                finalTarget.gx = Math.max(0, Math.min(GRID - dimX, finalTarget.gx));
                finalTarget.gy = Math.max(0, Math.min(GRID - dimY, finalTarget.gy));
                finalTarget.gz = Math.max(0, Math.min(GRID - dimZ, finalTarget.gz));
            }

            if (dragAxisLock && finalTarget) {
                const voxelsToDraw = getVoxelsOnLine(initialDragVoxelCoords, finalTarget, currentMode, currentColor, dimX, dimY, dimZ);
                applyStrokeChanges(voxelsToDraw, voxelsAtDragStart, currentMode, currentColor);
                lastActionVoxelCoords = { ...finalTarget };
                distanceDisplay.textContent = `Distanz: ${initialDragVoxelWorldPos.distanceTo(new THREE.Vector3(finalTarget.gx * VS + HALF, finalTarget.gy * VS + HALF, finalTarget.gz * VS + HALF)).toFixed(2)} mm`;
                distanceDisplay.classList.remove('hidden');
                previewLineVoxels = voxelsToDraw;
                updatePreviewLineMesh();
                updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            } else {
                distanceDisplay.classList.add('hidden');
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
                updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
            }
            return;
        } else {
            // Hovering (mouse)
            distanceDisplay.classList.add('hidden');
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];

            let hoverTarget = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (hoverTarget) {
                const { dimX: hoverDimX, dimY: hoverDimY, dimZ: hoverDimZ } = getCurrentBlockDimensions(false, isShiftOrControl); // Get dimensions for hover preview
                updatePreviewVoxel(hoverTarget.gx, hoverTarget.gy, hoverTarget.gz, true, hoverDimX, hoverDimY, hoverDimZ);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
        }
    }
}

window.onload = async function() {
    closeAllModals();
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        touchIndicator = document.getElementById('touch-indicator'); distanceDisplay = document.getElementById('distanceDisplay');
        infoBox = document.getElementById('infoBox'); helpToggleBtn = document.getElementById('helpToggleBtn');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34);
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ');
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches;
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap;
      
        scene.add(new THREE.AmbientLight(0x606060));
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
        
        scene.add(previewVoxelMesh); updatePreviewVoxel(0,0,0,false);
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }), maxPreviewInstances);
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage); scene.add(previewLineInstancedMesh);
        rebuildHelpers();

        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        containerDiv.addEventListener('touchmove', (e) => { if (activePointers.size > 0) e.preventDefault(); }, { passive: false });
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        document.addEventListener('mousemove', (e) => { if (isPointerLocked) { mouseMovementX = e.movementX; mouseMovementY = e.movementY; } });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID; const newGrid = parseInt(e.target.value);
            const oldVoxelState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.filter(v => v.gx < newGrid && v.gy < newGrid && v.gz < newGrid).forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
            GRID = newGrid; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
            addCommand('resizeGrid', oldVoxelState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }), { oldGrid: oldGrid, newGrid: GRID });
            rebuildHelpers(); resetCameraPosition();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor);
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
        });
        document.getElementById('color-picker').addEventListener('blur', (e) => {
            currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor);
        });

        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => {
            const box = presetBoxes[i]; box.value = color;
            box.addEventListener('click', (e) => setActivePreset(i));
            box.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex); else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        document.getElementById('exportStlBtn').addEventListener('click', exportSTL);
        document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);

        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value); document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('block-size-1x1').addEventListener('click', () => setFixedBlockSize(1));
        document.getElementById('block-size-4x4').addEventListener('click', () => setFixedBlockSize(4));
        document.getElementById('block-size-8x8').addEventListener('click', () => setFixedBlockSize(8));
        document.getElementById('block-size-10x10').addEventListener('click', () => setFixedBlockSize(10));

        const dynamicXInput = document.getElementById('dynamic-block-x');
        const dynamicYInput = document.getElementById('dynamic-block-y');
        const dynamicZInput = document.getElementById('dynamic-block-z');
        const setDynamicBlockSizeBtn = document.getElementById('setDynamicBlockSizeBtn');

        dynamicXInput.addEventListener('input', (e) => { dynamicBlockDim.x = parseInt(e.target.value) || 1; localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x); });
        dynamicYInput.addEventListener('input', (e) => { dynamicBlockDim.y = parseInt(e.target.value) || 1; localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y); });
        dynamicZInput.addEventListener('input', (e) => { dynamicBlockDim.z = parseInt(e.target.value) || 1; localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z); });
        setDynamicBlockSizeBtn.addEventListener('click', setDynamicBlockDimensions);

        [dynamicXInput, dynamicYInput, dynamicZInput].forEach(input => {
            input.addEventListener('keydown', (e) => { if (e.key === 'Tab') e.stopPropagation(); });
            input.addEventListener('focus', () => { isPointerLocked = false; document.exitPointerLock(); });
            input.addEventListener('blur', () => cvs.focus());
        });

        document.getElementById('measureDistanceBtn').addEventListener('click', () => {
            currentMode = Modes.MEASURE; document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
            measurementStartPoint = null; measurementEndPoint = null; distanceDisplay.classList.add('hidden');
            updatePreviewVoxel(0, 0, 0, false);
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        });

        let showInfoBox = localStorage.getItem('showInfoBox') === 'true';
        function updateInfoBoxVisibility() {
            if (infoBox) infoBox.classList.toggle('hidden', !showInfoBox);
            if (helpToggleBtn) helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
            localStorage.setItem('showInfoBox', showInfoBox);
        }
        helpToggleBtn.addEventListener('click', () => { showInfoBox = !showInfoBox; updateInfoBoxVisibility(); });
        updateInfoBoxVisibility();

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        document.getElementById('menuToggle').addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
        });

        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            if (e.matches) { controlsPanel.classList.add('hidden'); mobileControls.classList.remove('hidden'); }
            else { controlsPanel.classList.remove('hidden'); controlsPanel.classList.add('flex'); mobileControls.classList.add('hidden'); }
            onResize();
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        document.getElementById('mobile-undo').addEventListener('click', undo);
        document.getElementById('mobile-redo').addEventListener('click', redo);
        document.getElementById('mobile-save').addEventListener('click', saveJSON);
        document.getElementById('mobile-camera').addEventListener('click', resetCameraPosition);
        document.getElementById('mobile-assist').addEventListener('click', () => {
            touchAssistEnabled = !touchAssistEnabled;
            const assistBtn = document.getElementById('mobile-assist');
            assistBtn.classList.toggle('border-primary', touchAssistEnabled); assistBtn.classList.toggle('border-base-content', !touchAssistEnabled);
            showToast('Touch Assist', `Magnetisches Zielen ist jetzt ${touchAssistEnabled ? 'aktiviert' : 'deaktiviert'}.`, 'info');
        });
        document.getElementById('mobile-login-logout').addEventListener('click', loginLogout);

        document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        document.getElementById('color-picker').value = currentColor;
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        document.getElementById('dynamic-block-x').value = dynamicBlockDim.x; document.getElementById('dynamic-block-y').value = dynamicBlockDim.y; document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;
        updateBlockSizeButtonsActiveState();

        const app = window.firebase.initializeApp(window.firebaseConfig);
        auth = window.firebase.getAuth(app); db = window.firebase.getFirestore(app);
        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const uploadToHubBtn = document.getElementById('uploadToHubBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const goToHubBtn = document.getElementById('goToHubBtn');
        let projectLoadedFromUrl = false;

        predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; document.getElementById('uploadCategory').appendChild(opt); });

        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await window.firebase.signInWithCustomToken(auth, __initial_auth_token); }
                    catch (e) { console.error("Firebase Auth Token Error:", e); try { await window.firebase.signInAnonymously(auth); } catch (ae) { console.error("Firebase Anonymous Auth Error:", ae); showToast('Anmeldefehler', `Anonymer Anmeldefehler: ${ae.message}.`, 'error', 5000); } }
                } else {
                    try { await window.firebase.signInAnonymously(auth); }
                    catch (e) { console.error("Firebase Anonymous Auth Error:", e); showToast('Anmeldefehler', `Anonymer Anmeldefehler: ${ae.message}.`, 'error', 5000); }
                }

                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null; currentUser = user;
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    userIdDisplay.innerHTML = user ? `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle"> ${user.uid}` : '';
                    uploadToHubBtn.classList.toggle('hidden', !user);
                    document.getElementById('mobile-login-logout').textContent = user ? 'üö™' : 'üîë';
                    if (user) document.getElementById('authModal').close();

                    if (!projectLoadedFromUrl) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId'); const encodedJson = urlParams.get('projectJson');
                        if (modelId) { await loadProjectFromModelId(modelId); projectLoadedFromUrl = true; }
                        else if (encodedJson) {
                            try {
                                const decodedJson = decodeURIComponent(encodedJson);
                                loadProjectData(JSON.parse(decodedJson));
                                showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success');
                                projectLoadedFromUrl = true;
                            } catch (e) { console.error("Error loading project from URL param:", e); showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ung√ºltige oder besch√§digte Projektdaten. Fehler: ' + e.message, 'error'); resetToDefaultProject(); }
                        } else { projectRemixOf = ''; projectSourceJsonUrl = ''; }
                    }
                });
                animate();
            })
            .catch((e) => { console.error("Firebase setPersistence Error:", e); showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000); animate(); });

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        loginLogoutBtn.addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); });
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInWithGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } });
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });
    } catch (e) { console.error("VoxelShaper Initialization Error:", e); showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000); }
};

const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);
    if (isPointerLocked) {
        if (firstMoveAfterLock) { firstMoveAfterLock = false; mouseMovementX = mouseMovementY = 0; return; }
        euler.y -= (mouseMovementX || 0) * rotSpeed; euler.x -= (mouseMovementY || 0) * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); cam.quaternion.setFromEuler(euler);
        mouseMovementX = mouseMovementY = 0;
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }
    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    ren.render(scene, cam);
}
</script>
</body>
</html>
