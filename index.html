<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>
<style>
/* CSS für den Body mit Safe-Area-Anpassungen */
body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;

    /* --- WICHTIG: ANPASSUNGEN FÜR SICHERE BEREICHE --- */
    /* Verschiebt den Inhalt nach unten, um Platz für die Statusleiste/Notch zu schaffen */
    padding-top: env(safe-area-inset-top);
    /* Fügt Polsterung für den unteren Bereich hinzu (z.B. für Home-Indikatoren auf iPhones) */
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Entscheidend: Stellt sicher, dass das Padding in der 100vh Höhe enthalten ist */
    box-sizing: border-box;
    /* --- ENDE ANPASSUNGEN FÜR SICHERE BEREICHE --- */
}

/* verhindert, dass das OS den Canvas als Text selektiert */
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;    /* iOS Kontextmenü */
}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode{
    font-weight:700;
    color:#81c784;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box; /* Ensure border (if added back) doesn't push content out */
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    display: none;
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Style for the new terrain controls panel */
#terrainControlsPanel {
    background: #3a3f47;
    padding: 14px;
    margin-top: 10px;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    align-items: center;
    border: 1px solid #4a4f57;
    transition: all 0.3s ease-in-out;
}
/* ---------------------------------------------------
    HAMBURGER-BUTTON
    --------------------------------------------------- */
#menuToggle{
    position: fixed;
    /* top: 10px; <-- DIESE ZEILE WIRD GEÄNDERT! */
    top: calc(10px + env(safe-area-inset-top)); /* <-- NEU: Verschiebt es um 10px + Safe-Area nach unten */
    right: 10px;
    z-index: 1500;             /* über allen Panels */
    width: 42px; height: 42px;
    font-size: 1.4em;
    line-height: 42px;
    text-align: center;
    background:#555c66;
    color:#e0e0e0;
    border:none;
    border-radius:8px;
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.4);
}
#menuToggle:hover{background:#6a727f}

/* ---------------------------------------------------
    Responsive-Regel: Auf Viewports ≤ 768 px wird
    das Bedienfeld anfangs versteckt.
    --------------------------------------------------- */
@media (max-width:768px){
    #controls{display:none;}
}
/* ---------------------------------------------------
    Gelände-Button optisch hervorheben
    --------------------------------------------------- */
#generateTerrainBtn{
    padding: 12px 26px;
    font-size: 1.05em;
    font-weight: 600;
    letter-spacing: .3px;

    /* Farben im VoxelShaper-Grün */
    background: linear-gradient(180deg,#66bb6a 0%,#43a047 100%);
    color:#fff;

    border:none;
    border-radius:8px;
    cursor:pointer;

    /* leichter „erhabener“ Effekt */
    box-shadow:0 2px 6px rgba(0,0,0,.4);
    transition: transform .06s ease, box-shadow .06s ease;
}

/* Hover / Focus */
#generateTerrainBtn:hover,
#generateTerrainBtn:focus-visible{
    transform: translateY(-1px);
    box-shadow:0 4px 10px rgba(0,0,0,.45);
}

/* Aktiv (Button gedrückt) */
#generateTerrainBtn:active{
    transform: translateY(0);
    box-shadow:0 2px 4px rgba(0,0,0,.35);
}
/* Canvas & Container: KEINE default-Gesten */
#container,
#voxelCanvas{
    touch-action: none;           /* iOS ≥13.4, Android, Desktop */
    -ms-touch-action: none;       /* altes Edge/IE */

    /* ← neu: sorge dafür, dass die CSS-Border innen sitzt */
           box-sizing: border-box;
}
</style>
</head>
<body>
<button id="menuToggle" aria-label="Menü umschalten">☰</button>

<div id="controls">
    <label for="grid-size-slider">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="90" value="10">
    <span id="grid-size-display">10×10×10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff">
    <div id="color-preset-1" class="color-preset-box"></div>
    <div id="color-preset-2" class="color-preset-box"></div>
    <div id="color-preset-3" class="color-preset-box"></div>

    <button id="modeToggle">Modus wechseln</button><span id="current-mode">Modus: Hinzufügen</span>
    <button id="clearBtn">Alles löschen</button>
    <button id="fillLevelBtn">Ebene füllen</button>
    <button id="saveBtn">Projekt speichern</button>
    <button id="loadBtn">Projekt laden</button>
    <button id="exportStlBtn">STL Export</button>
    <button id="importStlBtn">STL Import</button> <!-- NEW: STL Import Button -->
    <button id="exportObjBtn">OBJ Export</button> <!-- NEW: OBJ Export Button -->
    <button id="importObjBtn">OBJ Import</button> <!-- NEW: OBJ Import Button -->
    <button id="exportVoxBtn">VOX Export</button> <!-- NEW: VOX Export Button -->
    <button id="importVoxBtn">VOX Import</button> <!-- NEW: VOX Import Button -->

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1">
    <span id="fly-speed-display">0.10</span>

    <label for="block-size-selector">Blockgröße:</label>
    <button id="block-size-1x1" class="block-size-btn active">1x1</button>
    <button id="block-size-4x4" class="block-size-btn">4x4</button>
    <button id="block-size-8x8" class="block-size-btn">8x8</button>
    <button id="block-size-10x10" class="block-size-btn">10x10</button> <!-- NEW: 10x10 Block Size Button -->

    <button id="toggleTerrainControlsBtn">Gelände-Optionen</button>
    <button id="helpToggleBtn">Hilfe</button>
    <button id="resetCameraBtn">Zur Szene zurückkehren</button>

    <!-- NEW: Image Template Controls -->
    <button id="loadImageTemplateBtn">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" style="display:none;">Bildvorlage entfernen</button>
    <label for="lockImageTemplateCheckbox">Vorlage sperren:</label>
    <input type="checkbox" id="lockImageTemplateCheckbox">
    <input type="file" id="imageFileInput" accept="image/*" style="display:none;">
</div>

<div id="terrainControlsPanel" style="display:none;">
    <button id="generateTerrainBtn">Gelände generieren</button>
    <label for="terrain-height-scale">Höhe:</label>
    <input type="number" id="terrain-height-scale" value="10" min="1" step="1">
    <label for="terrain-frequency">Frequenz:</label>
    <input type="number" id="terrain-frequency" value="0.05" min="0.001" max="0.5" step="0.001">
    <label for="terrain-octaves">Oktaven:</label>
    <input type="number" id="terrain-octaves" value="4" min="1" max="10" step="1">
    <label for="terrain-lacunarity">Lacunarity:</label>
    <input type="number" id="terrain-lacunarity" value="2.0" min="1.0" max="4.0" step="0.1">
    <label for="terrain-gain">Gain:</label>
    <input type="number" id="terrain-gain" value="0.5" min="0.1" max="1.0" step="0.01">
    <label for="terrain-seed">Seed:</label>
    <input type="text" id="terrain-seed" placeholder="Zahl oder Text">
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus → Kamera drehen (Fly Mode)<br>
    WASD / E / Q → bewegen<br>
    Linke MT → Voxel hinzuf./löschen/zeichnen<br>
    **Alt + Mausrad → Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad → Zeichenebene Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad → Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedrückt + Maus ziehen → Voxel Aktion auf aktiver Ebene (Hinzufügen / Löschen / Zeichnen)**<br>
    **Control + Linke MT gedrückt + Maus ziehen → Voxel ziehen zum Hinzufügen (Stapeln, nur im Hinzufügen-Modus)**<br>
    Mausrad → Kamera Geschwindigkeit anpassen<br>
    **Tab → Modus wechseln (Hinzufügen / Löschen / Zeichnen)**<br>
    **1, 2, 3 → Voreingestellte Farbe wählen (Shift/Strg/Cmd + 1,2,3 zum Speichern)**<br>
    **Strg + Z → Rückgängig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z → Wiederholen (Redo)**
    </div>
    <input type="file" id="fileInput" accept=".json">
    <input type="file" id="stlFileInput" accept=".stl" style="display:none;"> <!-- NEW: STL File Input -->
    <input type="file" id="objFileInput" accept=".obj" style="display:none;"> <!-- NEW: OBJ File Input -->
    <input type="file" id="voxFileInput" accept=".vox" style="display:none;"> <!-- NEW: VOX File Input -->
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt löschen</h3>
        <p>Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h3 id="messageModalTitle">Nachricht</h3>
        <p id="messageModalText"></p>
        <div class="modal-buttons">
            <button id="messageModalCloseBtn" class="cancel">Schließen</button>
        </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/noisejs/2.1.0/perlin.js"></script>
<script src="lib/voxelshaper_io.js"></script> <!-- NEW: VoxelShaperIO library -->


<script>
// Define VoxelShaperCore class to encapsulate all logic and state
class VoxelShaperCore {
    constructor(canvasElement, containerElement) {
        // Constants
        this.VS = 1;
        this.HALF = this.VS * 0.5;

        // Core Three.js components
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x282c34);
        this.cam = null; // Initialized in initThreeJs
        this.ren = null; // Initialized in initThreeJs
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ'); // For camera rotation

        // Voxel data and rendering
        this.voxels = new Map(); // Stores { color: hex_color, instanceId: number }
        this.instancedMesh = null; // Initialized in initThreeJs
        this.dummy = new THREE.Object3D(); // For setting instance matrices
        this.tempColor = new THREE.Color(); // For setting instance colors

        // Helpers
        this.gridHelper = null;
        this.boxHelper = null;
        this.previewVoxelMesh = null; // Initialized in initThreeJs

        // UI-related state (managed by API methods, but core holds values)
        this.GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;
        this.currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
        this.moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
        this.activeDrawingLevel = { x: 0, y: 0, z: 0 };
        this.currentDrawingAxis = 'y';
        this.currentMode = VoxelShaperCore.Modes.ADD; // Default mode
        this.currentBlockSize = 1; // Default block size

        // Terrain generation parameters
        this.terrainHeightScale = 10;
        this.terrainFrequency = 0.05;
        this.terrainOctaves = 4;
        this.terrainLacunarity = 2.0;
        this.terrainGain = 0.5;
        this.terrainSeed = '';
        this.noise2D = new ValueNoise2D(this.terrainSeed); // Initialize noise generator

        // Image template
        this.templateImageMesh = null;
        this.templateImageData = null;

        // Input state
        this.keyboard = {};
        this.isPointerLocked = false;
        this.firstMoveAfterLock = true;
        this.isShiftDragging = false;
        this.isControlDragging = false;
        this.pointerIsDown = false;
        this.lastX = 0;
        this.lastY = 0;
        this.initialClickPos = null;
        this.lastActionVoxelCoords = null;
        this.fixedDragPlaneParams = { level: null, axis: null };
        this.isHoldDrawingActive = false;
        this.longPressTimer = null;
        this.dblTapActive = false;
        this.dblTapDrag = false;
        this.isDblTapDragActive = false;
        this.activeGestureMode = 'none';
        this.tapCandidate = null;
        this.lastTap = 0;
        this.prevTouch = null;
        this.activePointers = new Map();
        this.gestureMid = null;
        this.gestureDist = null;
        this.gestureMode = null;

        // History
        this.history = [];
        this.historyPointer = -1;
        this.MAX_HISTORY_SIZE = 100;

        // DOM elements (passed in or looked up)
        this.canvas = canvasElement;
        this.container = containerElement;

        // Initialize Three.js scene, camera, renderer, and helpers
        this.initThreeJs();
        this.animate(); // Start animation loop
    }

    // Static properties for Modes
    static Modes = {
        ADD: 'Hinzufügen',
        DELETE: 'Löschen',
        DRAW: 'Zeichnen',
    };

    // Constants for input handling
    static TAP_DIST_TH = 10;
    static DT_MS = 250;
    static MOVE_PX = 10;
    static LONG_PRESS_DELAY_MS = 500;
    static PINCH_ZOOM_MULT = 30;
    static DRAG_BASE = 0.1;
    static PAN_PIX_TH = 10;
    static PINCH_REL_TH = 0.08;
    static ROT_SPEED = 0.004;

    /**
     * Initializes the Three.js scene, camera, renderer, and core meshes.
     * This method sets up the visual environment for the voxel editor.
     * @private
     */
    initThreeJs() {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        this.cam = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        this.resetCameraPosition();

        this.ren = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        this.ren.setSize(this.container.clientWidth, this.container.clientHeight);
        this.ren.setPixelRatio(window.devicePixelRatio);
        this.ren.shadowMap.enabled = true;
        this.ren.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        this.scene.add(ambientLight);

        this.mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        this.mainDirectionalLight.position.set(10, 20, 15);
        this.mainDirectionalLight.castShadow = true;
        this.mainDirectionalLight.shadow.mapSize.width = 2048;
        this.mainDirectionalLight.shadow.mapSize.height = 2048;
        this.mainDirectionalLight.shadow.camera.near = 0.5;
        this.mainDirectionalLight.shadow.camera.far = 50;
        this.mainDirectionalLight.shadow.camera.left = -30;
        this.mainDirectionalLight.shadow.camera.right = 30;
        this.mainDirectionalLight.shadow.camera.top = 30;
        this.mainDirectionalLight.shadow.camera.bottom = -30;
        this.scene.add(this.mainDirectionalLight);

        // InstancedMesh for voxels
        const voxelBaseGeometry = new THREE.BoxGeometry(this.VS, this.VS, this.VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        meshMaterial.onBeforeCompile = (shader) => {
            shader.vertexShader = `
                varying vec3 vInstanceColor;
                ${shader.vertexShader}
            `.replace('void main() {', `void main() {`);
            shader.vertexShader = shader.vertexShader.replace(
                '#include <color_vertex>',
                `
                #include <color_vertex>
                #ifdef USE_INSTANCING_COLOR
                    vInstanceColor = instanceColor;
                #else
                    vInstanceColor = vec3(1.0);
                #endif
                `
            );
            shader.fragmentShader = `
                varying vec3 vInstanceColor;
                ${shader.fragmentShader}
            `.replace(
                'vec4 diffuseColor = vec4( diffuse, opacity );',
                'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
            );
        };

        const initialMaxVoxels = 90 * 90 * 90;
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, initialMaxVoxels);
        this.instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(initialMaxVoxels * 16), 16);
        this.instancedMesh.geometry.setAttribute('instanceMatrix', this.instancedMesh.instanceMatrix);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(initialMaxVoxels * 3), 3);
        this.instancedMesh.geometry.setAttribute('instanceColor', this.instancedMesh.instanceColor);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true;
        this.instancedMesh.receiveShadow = true;
        this.scene.add(this.instancedMesh);
        this.instancedMesh.count = 0;

        // Preview Voxel
        const previewVoxelGeometry = new THREE.BoxGeometry(this.VS, this.VS, this.VS);
        const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false });
        this.previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial);
        this.scene.add(this.previewVoxelMesh);
        this.updatePreviewVoxel(0, 0, 0, false); // Initially hide
        
        this.rebuildHelpers();
    }

    /**
     * Main animation loop for rendering the scene.
     * @private
     */
    animate = () => {
        requestAnimationFrame(this.animate);

        // Continuous keyboard movement when pointer is locked (fly mode)
        if (this.isPointerLocked) {
            const forward = this.cam.getWorldDirection(new THREE.Vector3());
            const right = new THREE.Vector3().crossVectors(forward, this.cam.up).normalize();
            const up = new THREE.Vector3(0, 1, 0); // World up direction

            const currentMoveSpeed = this.moveSpeed * 5;

            if (this.keyboard['w']) this.cam.position.addScaledVector(forward, currentMoveSpeed);
            if (this.keyboard['s']) this.cam.position.addScaledVector(forward, -currentMoveSpeed);
            if (this.keyboard['a']) this.cam.position.addScaledVector(right, -currentMoveSpeed);
            if (this.keyboard['d']) this.cam.position.addScaledVector(right, currentMoveSpeed);
            if (this.keyboard['q']) this.cam.position.addScaledVector(up, -currentMoveSpeed);
            if (this.keyboard['e']) this.cam.position.addScaledVector(up, currentMoveSpeed);
        }

        this.ren.render(this.scene, this.cam);
    }

    /**
     * Handles window resize events to update camera aspect ratio and renderer size.
     * @public
     */
    onResize() {
        this.cam.aspect = this.container.clientWidth / this.container.clientHeight;
        this.cam.updateProjectionMatrix();
        this.ren.setSize(this.container.clientWidth, this.container.clientHeight);
    }

    /**
     * Rebuilds the grid and bounding box helpers based on the current grid size and drawing level.
     * @private
     */
    rebuildHelpers() {
        if (this.gridHelper) this.scene.remove(this.gridHelper);
        if (this.boxHelper) this.scene.remove(this.boxHelper);

        const size = this.GRID * this.VS;

        if (this.currentDrawingAxis === 'y') {
            this.gridHelper = new THREE.GridHelper(size, this.GRID, 0x444444, 0x444444);
            this.gridHelper.position.set(size / 2, this.activeDrawingLevel.y * this.VS, size / 2);
        } else if (this.currentDrawingAxis === 'x') {
            this.gridHelper = new THREE.GridHelper(size, this.GRID, 0x444444, 0x444444);
            this.gridHelper.rotation.z = Math.PI / 2;
            this.gridHelper.position.set(this.activeDrawingLevel.x * this.VS, size / 2, size / 2);
        } else if (this.currentDrawingAxis === 'z') {
            this.gridHelper = new THREE.GridHelper(size, this.GRID, 0x444444, 0x444444);
            this.gridHelper.rotation.x = Math.PI / 2;
            this.gridHelper.position.set(size / 2, size / 2, this.activeDrawingLevel.z * this.VS);
        }
        this.scene.add(this.gridHelper);

        const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
        this.boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
        this.boxHelper.position.set(size / 2, size / 2, size / 2);
        this.scene.add(this.boxHelper);
    }

    /**
     * Updates the position of the grid helper.
     * @public
     */
    updateGridHelperPosition() {
        this.rebuildHelpers();
    }

    /**
     * Sets the active drawing level and axis.
     * @param {number} level - The coordinate of the drawing plane on the given axis.
     * @param {'x'|'y'|'z'} axis - The axis for the drawing plane.
     * @public
     */
    setDrawingLevel(level, axis) {
        if (this.activeDrawingLevel[axis] !== level || this.currentDrawingAxis !== axis) {
            this.activeDrawingLevel[axis] = Math.max(0, Math.min(this.GRID - 1, level));
            this.currentDrawingAxis = axis;
            this.rebuildHelpers();
        }
    }

    /**
     * Sets the current drawing color.
     * @param {string} colorHex - The hexadecimal color string (e.g., '#RRGGBB').
     * @public
     */
    setCurrentColor(colorHex) {
        this.currentColor = colorHex;
    }

    /**
     * Sets the current block size for drawing operations.
     * @param {number} size - The size of the block (e.g., 1, 4, 8, 10).
     * @public
     */
    setBlockSize(size) {
        this.currentBlockSize = size;
        // Trigger a preview update if the mouse is currently over the canvas
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = this.lastX - rect.left;
        const mouseY = this.lastY - rect.top;
        if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
            this.updatePreviewVoxel(0, 0, 0, true); // Force update preview
        } else {
            this.updatePreviewVoxel(0, 0, 0, false); // Hide if mouse is outside
        }
    }

    /**
     * Cycles through the drawing modes (Add, Delete, Draw).
     * @public
     */
    cycleMode() {
        switch (this.currentMode) {
            case VoxelShaperCore.Modes.ADD:
                this.currentMode = VoxelShaperCore.Modes.DELETE;
                break;
            case VoxelShaperCore.Modes.DELETE:
                this.currentMode = VoxelShaperCore.Modes.DRAW;
                break;
            case VoxelShaperCore.Modes.DRAW:
                this.currentMode = VoxelShaperCore.Modes.ADD;
                break;
        }
        // This part would typically be handled by the UI, but for API completeness,
        // we can return the new mode or trigger an event.
        return this.currentMode;
    }

    /**
     * Maps grid coordinates (gx, gy, gz) to a unique string key.
     * @param {number} gx - X-coordinate.
     * @param {number} gy - Y-coordinate.
     * @param {number} gz - Z-coordinate.
     * @returns {string} The unique key.
     * @private
     */
    key(gx, gy, gz) {
        return `${gx},${gy},${gz}`;
    }

    /**
     * Parses a string key back into grid coordinates.
     * @param {string} k - The key string.
     * @returns {number[]} An array [gx, gy, gz].
     * @private
     */
    parseKey(k) {
        return k.split(',').map(Number);
    }

    /**
     * Adds a voxel at the specified grid coordinates with the given color.
     * @param {number} gx - X-coordinate.
     * @param {number} gy - Y-coordinate.
     * @param {number} gz - Z-coordinate.
     * @param {string} colorHex - The hexadecimal color string.
     * @param {boolean} [fromHistory=false] - True if called from history (prevents adding to history again).
     * @public
     */
    addVoxel(gx, gy, gz, colorHex, fromHistory = false) {
        gx = Math.max(0, Math.min(this.GRID - 1, gx));
        gy = Math.max(0, Math.min(this.GRID - 1, gy));
        gz = Math.max(0, Math.min(this.GRID - 1, gz));

        const k = this.key(gx, gy, gz);
        let instanceId;

        if (this.voxels.has(k)) {
            const existingData = this.voxels.get(k);
            if (existingData.color !== colorHex) {
                if (!fromHistory) {
                    this.addCommand('recolor', gx, gy, gz, existingData.color, colorHex);
                }
                instanceId = existingData.instanceId;
                this.tempColor.set(colorHex);
                this.instancedMesh.setColorAt(instanceId, this.tempColor);
                this.instancedMesh.instanceColor.needsUpdate = true;
                this.voxels.set(k, { color: colorHex, instanceId: instanceId });
            }
            return;
        } else {
            if (!fromHistory) {
                this.addCommand('add', gx, gy, gz, null, colorHex);
            }

            instanceId = this.instancedMesh.count;
            if (instanceId >= this.instancedMesh.maxInstancedCount) {
                console.warn("Max instanced count reached! Cannot add more voxels.");
                return;
            }

            this.dummy.position.set(gx * this.VS + this.HALF, gy * this.VS + this.HALF, gz * this.VS + this.HALF);
            this.dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(instanceId, this.dummy.matrix);

            this.tempColor.set(colorHex);
            this.instancedMesh.setColorAt(instanceId, this.tempColor);

            this.voxels.set(k, { color: colorHex, instanceId: instanceId });

            this.instancedMesh.count++;
            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }

    /**
     * Removes a voxel at the specified grid coordinates.
     * @param {number} gx - X-coordinate.
     * @param {number} gy - Y-coordinate.
     * @param {number} gz - Z-coordinate.
     * @param {boolean} [fromHistory=false] - True if called from history.
     * @public
     */
    removeVoxel(gx, gy, gz, fromHistory = false) {
        const k = this.key(gx, gy, gz);
        if (!this.voxels.has(k)) {
            return;
        }

        const removedVoxelData = this.voxels.get(k);
        const removedInstanceId = removedVoxelData.instanceId;

        if (!fromHistory) {
            this.addCommand('delete', gx, gy, gz, removedVoxelData.color, null);
        }

        if (removedInstanceId !== this.instancedMesh.count - 1) {
            let lastVoxelKey = null;
            for (const [vk, vd] of this.voxels.entries()) {
                if (vd.instanceId === this.instancedMesh.count - 1) {
                    lastVoxelKey = vk;
                    break;
                }
            }
            const lastVoxelData = this.voxels.get(lastVoxelKey);

            this.instancedMesh.getMatrixAt(this.instancedMesh.count - 1, this.dummy.matrix);
            this.instancedMesh.setMatrixAt(removedInstanceId, this.dummy.matrix);

            this.instancedMesh.getColorAt(this.instancedMesh.count - 1, this.tempColor);
            this.instancedMesh.setColorAt(removedInstanceId, this.tempColor);

            this.voxels.set(lastVoxelKey, { color: lastVoxelData.color, instanceId: removedInstanceId });
        }

        this.instancedMesh.count--;
        this.voxels.delete(k);

        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
    }

    /**
     * Recolor a voxel at the specified grid coordinates.
     * @param {number} gx - X-coordinate.
     * @param {number} gy - Y-coordinate.
     * @param {number} gz - Z-coordinate.
     * @param {string} newColorHex - The new hexadecimal color string.
     * @param {boolean} [fromHistory=false] - True if called from history.
     * @public
     */
    recolorVoxel(gx, gy, gz, newColorHex, fromHistory = false) {
        const k = this.key(gx, gy, gz);
        if (!this.voxels.has(k)) {
            return;
        }

        const existingData = this.voxels.get(k);
        if (existingData.color === newColorHex) {
            return;
        }

        if (!fromHistory) {
            this.addCommand('recolor', gx, gy, gz, existingData.color, newColorHex);
        }

        const instanceId = existingData.instanceId;
        this.tempColor.set(newColorHex);
        this.instancedMesh.setColorAt(instanceId, this.tempColor);
        this.instancedMesh.instanceColor.needsUpdate = true;
        this.voxels.set(k, { color: newColorHex, instanceId: instanceId });
    }

    /**
     * Performs voxel modification (add, delete, or draw) for a block of voxels.
     * @param {number} baseX - Base X-coordinate.
     * @param {number} baseY - Base Y-coordinate.
     * @param {number} baseZ - Base Z-coordinate.
     * @param {string} mode - The current mode (VoxelShaperCore.Modes.ADD, DELETE, DRAW).
     * @param {string} color - The color to apply.
     * @param {number} [blockSize=1] - The size of the block.
     * @private
     */
    performVoxelModification(baseX, baseY, baseZ, mode, color, blockSize = 1) {
        let axis1, axis2;
        if (this.currentDrawingAxis === 'y') {
            axis1 = 'x';
            axis2 = 'z';
        } else if (this.currentDrawingAxis === 'x') {
            axis1 = 'y';
            axis2 = 'z';
        } else { // currentDrawingAxis === 'z'
            axis1 = 'x';
            axis2 = 'y';
        }

        for (let i = 0; i < blockSize; i++) {
            for (let j = 0; j < blockSize; j++) {
                let x = baseX, y = baseY, z = baseZ;

                if (axis1 === 'x') x = baseX + i;
                else if (axis1 === 'y') y = baseY + i;
                else if (axis1 === 'z') z = baseZ + i;

                if (axis2 === 'x') x = baseX + j;
                else if (axis2 === 'y') y = baseY + j;
                else if (axis2 === 'z') z = baseZ + j;

                if (this.currentDrawingAxis === 'x') x = baseX;
                else if (this.currentDrawingAxis === 'y') y = baseY;
                else if (this.currentDrawingAxis === 'z') z = baseZ;

                const clampedX = Math.max(0, Math.min(this.GRID - 1, x));
                const clampedY = Math.max(0, Math.min(this.GRID - 1, y));
                const clampedZ = Math.max(0, Math.min(this.GRID - 1, z));

                const voxelKey = this.key(clampedX, clampedY, clampedZ);
                const actualHasVoxel = this.voxels.has(voxelKey);

                switch (mode) {
                    case VoxelShaperCore.Modes.ADD:
                        if (!actualHasVoxel) {
                            this.addVoxel(clampedX, clampedY, clampedZ, color);
                        }
                        break;
                    case VoxelShaperCore.Modes.DELETE:
                        if (actualHasVoxel) {
                            this.removeVoxel(clampedX, clampedY, clampedZ);
                        }
                        break;
                    case VoxelShaperCore.Modes.DRAW:
                        if (actualHasVoxel && this.voxels.get(voxelKey).color !== color) {
                            this.recolorVoxel(clampedX, clampedY, clampedZ, color);
                        }
                        break;
                }
            }
        }
    }

    /**
     * Draws a line of voxels between two points using DDA algorithm.
     * @param {object} start - Start coordinates {gx, gy, gz}.
     * @param {object} end - End coordinates {gx, gy, gz}.
     * @param {string} mode - The current mode.
     * @param {string} color - The color to apply.
     * @param {number} [blockSize=1] - The size of the block.
     * @private
     */
    drawLineOfVoxels(start, end, mode, color, blockSize = 1) {
        let x = start.gx;
        let y = start.gy;
        let z = start.gz;
        const x2 = end.gx;
        const y2 = end.gy;
        const z2 = end.gz;

        const dx = x2 - x;
        const dy = y2 - y;
        const dz = z2 - z;

        const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

        if (steps === 0) {
            this.performVoxelModification(x, y, z, mode, color, blockSize);
            return;
        }

        const x_inc = dx / steps;
        const y_inc = dy / steps;
        const z_inc = dz / steps;

        for (let i = 0; i <= steps; i++) {
            this.performVoxelModification(Math.round(x), Math.round(y), Math.round(z), mode, color, blockSize);
            x += x_inc;
            y += y_inc;
            z += z_inc;
        }
    }

    /**
     * Updates the preview voxel's position, visibility, and color.
     * @param {number} x - X-coordinate for preview.
     * @param {number} y - Y-coordinate for preview.
     * @param {number} z - Z-coordinate for preview.
     * @param {boolean} visible - Whether the preview voxel should be visible.
     * @private
     */
    updatePreviewVoxel(x, y, z, visible) {
        if (this.previewVoxelMesh) {
            if (visible) {
                if (this.previewVoxelMesh.geometry) {
                    this.previewVoxelMesh.geometry.dispose();
                }

                const blockDimX = (this.currentDrawingAxis === 'y' || this.currentDrawingAxis === 'z') ? this.currentBlockSize * this.VS : this.VS;
                const blockDimY = (this.currentDrawingAxis === 'x' || this.currentDrawingAxis === 'z') ? this.currentBlockSize * this.VS : this.VS;
                const blockDimZ = (this.currentDrawingAxis === 'x' || this.currentDrawingAxis === 'y') ? this.currentBlockSize * this.VS : this.VS;

                const tempGeometry = new THREE.BoxGeometry(blockDimX, blockDimY, blockDimZ);
                this.previewVoxelMesh.geometry = tempGeometry;

                const centerX = x * this.VS + blockDimX / 2;
                const centerY = y * this.VS + blockDimY / 2;
                const centerZ = z * this.VS + blockDimZ / 2;

                this.previewVoxelMesh.position.set(centerX, centerY, centerZ);

                this.previewVoxelMesh.visible = true;
                this.previewVoxelMesh.material.color.set(this.currentColor);
                if (this.currentMode === VoxelShaperCore.Modes.DELETE) {
                    this.previewVoxelMesh.material.opacity = 0.2;
                } else {
                    this.previewVoxelMesh.material.opacity = 0.5;
                }
            } else {
                this.previewVoxelMesh.visible = false;
            }
        }
    }

    /**
     * Sets the fixed drag plane parameters for drawing operations.
     * @param {number} clientX - Client X-coordinate of the pointer.
     * @param {number} clientY - Client Y-coordinate of the pointer.
     * @param {string} mode - The current mode.
     * @private
     */
    setFixedDragPlane(clientX, clientY, mode) {
        const rect = this.canvas.getBoundingClientRect();
        const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                        -((clientY - rect.top) / rect.height) * 2 + 1);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.cam);
        const intersects = raycaster.intersectObject(this.instancedMesh);

        if (intersects.length > 0) {
            const hit = intersects[0];
            const hitNormal = hit.face.normal;
            const instanceMatrix = new THREE.Matrix4();
            this.instancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
            const instancePosition = new THREE.Vector3();
            instancePosition.setFromMatrixPosition(instanceMatrix);

            const hitVoxelX = Math.round(instancePosition.x - this.HALF);
            const hitVoxelY = Math.round(instancePosition.y - this.HALF);
            const hitVoxelZ = Math.round(instancePosition.z - this.HALF);

            let level, axis;

            const absNx = Math.abs(hitNormal.x);
            const absNy = Math.abs(hitNormal.y);
            const absNz = Math.abs(hitNormal.z);

            if (mode === VoxelShaperCore.Modes.ADD) {
                if (absNy > absNx && absNy > absNz) {
                    axis = 'y';
                    level = hitVoxelY + Math.round(hitNormal.y);
                } else if (absNx > absNy && absNx > absNz) {
                    axis = 'x';
                    level = hitVoxelX + Math.round(hitNormal.x);
                } else {
                    axis = 'z';
                    level = hitVoxelZ + Math.round(hitNormal.z);
                }
            } else {
                if (absNy > absNx && absNy > absNz) {
                    axis = 'y';
                    level = hitVoxelY;
                } else if (absNx > absNy && absNx > absNz) {
                    axis = 'x';
                    level = hitVoxelX;
                } else {
                    axis = 'z';
                    level = hitVoxelZ;
                }
            }
            this.fixedDragPlaneParams.level = level;
            this.fixedDragPlaneParams.axis = axis;
        } else {
            this.fixedDragPlaneParams.axis = this.currentDrawingAxis;
            this.fixedDragPlaneParams.level = this.activeDrawingLevel[this.currentDrawingAxis];
        }
    }

    /**
     * Calculates the target voxel coordinates based on pointer position and interaction mode.
     * @param {number} clientX - Client X-coordinate of the pointer.
     * @param {number} clientY - Client Y-coordinate of the pointer.
     * @param {string} mode - The current mode.
     * @param {boolean} isDragging - True if a drag operation is active.
     * @param {boolean} isStackingAdd - True if stacking add mode is active (Ctrl-drag).
     * @returns {object|null} The target voxel coordinates {gx, gy, gz} or null if no valid target.
     * @private
     */
    calculateTargetVoxelCoords(clientX, clientY, mode, isDragging, isStackingAdd) {
        if (this.isPointerLocked) return null;

        const rect = this.canvas.getBoundingClientRect();
        const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                        -((clientY - rect.top) / rect.height) * 2 + 1);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.cam);

        const objectsToIntersect = [this.instancedMesh];

        let targetVoxelCoords = null;

        if (isStackingAdd) {
            const intersects = raycaster.intersectObjects(objectsToIntersect);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const instanceMatrix = new THREE.Matrix4();
                this.instancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
                const instancePosition = new THREE.Vector3();
                instancePosition.setFromMatrixPosition(instanceMatrix);

                const gx = Math.round(instancePosition.x - this.HALF);
                const gz = Math.round(instancePosition.z - this.HALF);
                let highestY = -1;
                for (let y = 0; y < this.GRID; y++) {
                    if (this.voxels.has(this.key(gx, y, gz))) {
                        highestY = y;
                    }
                }
                targetVoxelCoords = { gx: gx, gy: highestY + 1, gz: gz };
            } else {
                const intersectionPoint = new THREE.Vector3();
                const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -(this.activeDrawingLevel.y * this.VS));
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                if(intersectionPoint){
                    targetVoxelCoords = {
                        gx: Math.floor(intersectionPoint.x / this.VS),
                        gy: this.activeDrawingLevel.y,
                        gz: Math.floor(intersectionPoint.z / this.VS)
                    };
                } else {
                    return null;
                }
            }
        }
        else if (isDragging && this.fixedDragPlaneParams.level !== null && this.fixedDragPlaneParams.axis !== null) {
            let planeNormal = new THREE.Vector3();
            if (this.fixedDragPlaneParams.axis === 'y') planeNormal.set(0, 1, 0);
            else if (this.fixedDragPlaneParams.axis === 'x') planeNormal.set(1, 0, 0);
            else if (this.fixedDragPlaneParams.axis === 'z') planeNormal.set(0, 0, 1);
            const drawingPlane = new THREE.Plane(planeNormal, -(this.fixedDragPlaneParams.level * this.VS));

            const intersectionPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

            if (intersectionPoint) {
                let gx = Math.floor(intersectionPoint.x / this.VS);
                let gy = Math.floor(intersectionPoint.y / this.VS);
                let gz = Math.floor(intersectionPoint.z / this.VS);

                if (this.fixedDragPlaneParams.axis === 'y') gy = this.fixedDragPlaneParams.level;
                else if (this.fixedDragPlaneParams.axis === 'x') gx = this.fixedDragPlaneParams.level;
                else if (this.fixedDragPlaneParams.axis === 'z') gz = this.fixedDragPlaneParams.level;

                targetVoxelCoords = { gx, gy, gz };
            }
        }
        else {
            const intersects = raycaster.intersectObjects(objectsToIntersect);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitNormal = hit.face.normal;
                const instanceMatrix = new THREE.Matrix4();
                this.instancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
                const instancePosition = new THREE.Vector3();
                instancePosition.setFromMatrixPosition(instanceMatrix);

                const hitVoxelX = Math.round(instancePosition.x - this.HALF);
                const hitVoxelY = Math.round(instancePosition.y - this.HALF);
                const hitVoxelZ = Math.round(instancePosition.z - this.HALF);

                if (mode === VoxelShaperCore.Modes.ADD) {
                    targetVoxelCoords = {
                        gx: hitVoxelX + hitNormal.x,
                        gy: hitVoxelY + hitNormal.y,
                        gz: hitVoxelZ + hitNormal.z
                    };
                } else { // DELETE or DRAW
                    targetVoxelCoords = {
                        gx: hitVoxelX,
                        gy: hitVoxelY,
                        gz: hitVoxelZ
                    };
                }
            } else if (mode === VoxelShaperCore.Modes.ADD) {
                const intersectionPoint = new THREE.Vector3();
                let planeNormal = new THREE.Vector3();
                if (this.currentDrawingAxis === 'y') planeNormal.set(0, 1, 0);
                else if (this.currentDrawingAxis === 'x') planeNormal.set(1, 0, 0);
                else if (this.currentDrawingAxis === 'z') planeNormal.set(0, 0, 1);
                const drawingPlane = new THREE.Plane(planeNormal, -(this.activeDrawingLevel[this.currentDrawingAxis] * this.VS));

                raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);
                if (intersectionPoint) {
                    let gx = Math.floor(intersectionPoint.x / this.VS);
                    let gy = Math.floor(intersectionPoint.y / this.VS);
                    let gz = Math.floor(intersectionPoint.z / this.VS);

                    if (this.currentDrawingAxis === 'y') gy = this.activeDrawingLevel.y;
                    else if (this.currentDrawingAxis === 'x') gx = this.activeDrawingLevel.x;
                    else if (this.currentDrawingAxis === 'z') gz = this.activeDrawingLevel.z;

                    targetVoxelCoords = { gx, gy, gz };
                }
            }
        }

        if (targetVoxelCoords) {
            targetVoxelCoords.gx = Math.max(0, Math.min(this.GRID - 1, targetVoxelCoords.gx));
            targetVoxelCoords.gy = Math.max(0, Math.min(this.GRID - 1, targetVoxelCoords.gy));
            targetVoxelCoords.gz = Math.max(0, Math.min(this.GRID - 1, targetVoxelCoords.gz));
            return targetVoxelCoords;
        }
        return null;
    }

    /**
     * Clears all voxels from the scene.
     * @param {boolean} [fromHistory=false] - True if called from history.
     * @private
     */
    clearAllInternal(fromHistory = false) {
        if (!fromHistory) {
            const oldState = [...this.voxels.entries()].map(([id, data]) => {
                const parts = this.parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            this.addCommand('clearAll', null, null, null, null, null, oldState, []);
        }
        this.voxels.clear();
        this.instancedMesh.count = 0;
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
        this.rebuildHelpers();
    }

    /**
     * Public method to clear all voxels. Adds to history.
     * @public
     */
    clearAllVoxels() {
        this.clearAllInternal(false);
    }

    /**
     * Fills the active drawing level with voxels of the current color.
     * @public
     */
    fillLevel() {
        const oldState = [...this.voxels.entries()].map(([id, data]) => {
            const parts = this.parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        this.clearAllInternal(true); // Clear without adding to history

        const newState = [];
        for (let x = 0; x < this.GRID; x++) {
            for (let z = 0; z < this.GRID; z++) {
                let gx, gy, gz;
                if (this.currentDrawingAxis === 'y') {
                    gx = x;
                    gy = this.activeDrawingLevel.y;
                    gz = z;
                } else if (this.currentDrawingAxis === 'x') {
                    gx = this.activeDrawingLevel.x;
                    gy = x;
                    gz = z;
                }
                else if (this.currentDrawingAxis === 'z') {
                    gx = x;
                    gy = z;
                    gz = this.activeDrawingLevel.z;
                }
                this.addVoxel(gx, gy, gz, this.currentColor, true);
                newState.push({ gx, gy, gz, color: this.currentColor });
            }
        }
        
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;

        this.addCommand('fillLevel', null, null, null, null, null, oldState, newState);
    }

    /**
     * Gets the current voxel data as a plain object.
     * @returns {object} A serializable object containing voxel data and settings.
     * @public
     */
    getVoxelsData() {
        const data = {};
        this.voxels.forEach((value, key) => {
            data[key] = value.color;
        });

        const settings = {
            gridSize: this.GRID,
            cameraPosition: this.cam.position.toArray(),
            cameraQuaternion: this.cam.quaternion.toArray(),
            activeDrawingLevel: this.activeDrawingLevel,
            currentDrawingAxis: this.currentDrawingAxis,
            currentColor: this.currentColor,
            terrainHeightScale: this.terrainHeightScale,
            terrainFrequency: this.terrainFrequency,
            terrainOctaves: this.terrainOctaves,
            terrainLacunarity: this.terrainLacunarity,
            terrainGain: this.terrainGain,
            terrainSeed: this.terrainSeed,
            moveSpeed: this.moveSpeed,
            currentBlockSize: this.currentBlockSize,
            templateImageData: this.templateImageData
        };

        return { voxels: data, settings: settings };
    }

    /**
     * Loads voxel data and settings into the editor.
     * @param {object} projectData - The project data object (from getVoxelsData or JSON).
     * @public
     */
    loadVoxelsData(projectData) {
        const loadedVoxels = projectData.voxels;
        const loadedSettings = projectData.settings;

        this.clearAllInternal(true);
        this.removeImageTemplate(true);

        if (loadedSettings) {
            this.setGridSize(loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10, true);
        }

        if (this.instancedMesh) {
            this.scene.remove(this.instancedMesh);
            this.instancedMesh.geometry.dispose();
            this.instancedMesh.material.dispose();
        }

        const voxelBaseGeometry = new THREE.BoxGeometry(this.VS, this.VS, this.VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        meshMaterial.onBeforeCompile = (shader) => {
            shader.vertexShader = `varying vec3 vInstanceColor; ${shader.vertexShader}`.replace('void main() {', `void main() {`);
            shader.vertexShader = shader.vertexShader.replace('#include <color_vertex>', `#include <color_vertex> #ifdef USE_INSTANCING_COLOR vInstanceColor = instanceColor; #else vInstanceColor = vec3(1.0); #endif`);
            shader.fragmentShader = `varying vec3 vInstanceColor; ${shader.fragmentShader}`.replace('vec4 diffuseColor = vec4( diffuse, opacity );', 'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );');
        };

        const maxVoxelsForLoadedGrid = this.GRID * this.GRID * this.GRID;
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxVoxelsForLoadedGrid);
        this.instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 16), 16);
        this.instancedMesh.geometry.setAttribute('instanceMatrix', this.instancedMesh.instanceMatrix);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 3), 3);
        this.instancedMesh.geometry.setAttribute('instanceColor', this.instancedMesh.instanceColor);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true;
        this.instancedMesh.receiveShadow = true;
        this.scene.add(this.instancedMesh);
        this.instancedMesh.count = 0;

        let instanceCounter = 0;
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k];
            const parts = this.parseKey(k);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0];
                const gy = parts[1];
                const gz = parts[2];

                if (gx < this.GRID && gy < this.GRID && gz < this.GRID) {
                    if (instanceCounter >= this.instancedMesh.maxInstancedCount) {
                        console.warn("Max instanced count reached during load. Some voxels may not be loaded.");
                        break;
                    }

                    this.dummy.position.set(gx * this.VS + this.HALF, gy * this.VS + this.HALF, gz * this.VS + this.HALF);
                    this.dummy.updateMatrix();
                    this.instancedMesh.setMatrixAt(instanceCounter, this.dummy.matrix);

                    this.tempColor.set(colorValue);
                    this.instancedMesh.setColorAt(instanceCounter, this.tempColor);

                    this.voxels.set(this.key(gx, gy, gz), { color: colorValue, instanceId: instanceCounter });
                    instanceCounter++;
                }
            }
        }
        this.instancedMesh.count = instanceCounter;
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;

        if (loadedSettings) {
            if (loadedSettings.cameraPosition) {
                this.cam.position.fromArray(loadedSettings.cameraPosition);
            }
            if (loadedSettings.cameraQuaternion) {
                this.cam.quaternion.fromArray(loadedSettings.cameraQuaternion);
                this.euler.setFromQuaternion(this.cam.quaternion, 'YXZ');
            }
            if (loadedSettings.activeDrawingLevel) {
                this.activeDrawingLevel = { ...loadedSettings.activeDrawingLevel };
            }
            if (loadedSettings.currentDrawingAxis) {
                this.currentDrawingAxis = loadedSettings.currentDrawingAxis;
            }
            this.updateGridHelperPosition();

            this.currentColor = loadedSettings.currentColor || '#ffffff';
            this.terrainHeightScale = loadedSettings.terrainHeightScale !== undefined ? loadedSettings.terrainHeightScale : 10;
            this.terrainFrequency = loadedSettings.terrainFrequency !== undefined ? loadedSettings.terrainFrequency : 0.05;
            this.terrainOctaves = loadedSettings.terrainOctaves !== undefined  ? loadedSettings.octaves : 4;
            this.terrainLacunarity = loadedSettings.lacunarity !== undefined ? loadedSettings.lacunarity : 2.0;
            this.terrainGain = loadedSettings.gain !== undefined ? loadedSettings.gain : 0.5;
            this.terrainSeed = loadedSettings.terrainSeed !== undefined ? loadedSettings.terrainSeed : '';
            this.moveSpeed = loadedSettings.moveSpeed !== undefined ? loadedSettings.moveSpeed : 0.1;
            this.currentBlockSize = loadedSettings.currentBlockSize !== undefined ? loadedSettings.currentBlockSize : 1;
            
            if (loadedSettings.templateImageData) {
                this.templateImageData = loadedSettings.templateImageData;
                const loader = new THREE.TextureLoader();
                loader.load(this.templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(this.templateImageData.scaledWidth, this.templateImageData.scaledHeight);
                    if (this.templateImageMesh) {
                        this.scene.remove(this.templateImageMesh);
                        this.templateImageMesh.geometry.dispose();
                        this.templateImageMesh.material.dispose();
                    }
                    this.templateImageMesh = new THREE.Mesh(geometry, material);
                    this.templateImageMesh.position.fromArray(this.templateImageData.position);
                    this.templateImageMesh.rotation.fromArray(this.templateImageData.rotation);
                    this.templateImageMesh.scale.fromArray(this.templateImageData.scale);
                    this.templateImageMesh.renderOrder = -1;
                    this.scene.add(this.templateImageMesh);
                    this.lockImageTemplate(this.templateImageData.locked);
                }, undefined, (err) => {
                    console.error('Error loading template image texture:', err);
                    this.templateImageMesh = null;
                    this.templateImageData = null;
                });
            }
            this.noise2D = new ValueNoise2D(this.terrainSeed);
        }

        this.history.length = 0;
        this.historyPointer = -1;
        this.resetCameraPosition();
    }

    /**
     * Sets the grid size of the voxel editor.
     * @param {number} newSize - The new grid size.
     * @param {boolean} [fromLoad=false] - True if called during a project load.
     * @public
     */
    setGridSize(newSize, fromLoad = false) {
        const oldGrid = this.GRID;
        this.GRID = newSize;
        localStorage.setItem('voxelEditorGridSize', this.GRID);

        if (!fromLoad) {
            const oldVoxelState = [...this.voxels.entries()].map(([id, data]) => {
                const parts = this.parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            const voxelsToKeep = new Map();
            this.voxels.forEach((data, k) => {
                const [gx, gy, gz] = this.parseKey(k);
                if (gx < this.GRID && gy < this.GRID && gz < this.GRID) {
                    voxelsToKeep.set(k, data);
                }
            });

            this.voxels.clear();
            this.instancedMesh.count = 0;

            let newInstanceId = 0;
            voxelsToKeep.forEach((data, k) => {
                const [gx, gy, gz] = this.parseKey(k);
                
                this.dummy.position.set(gx * this.VS + this.HALF, gy * this.VS + this.HALF, gz * this.VS + this.HALF);
                this.dummy.updateMatrix();
                this.instancedMesh.setMatrixAt(newInstanceId, this.dummy.matrix);

                this.tempColor.set(data.color);
                this.instancedMesh.setColorAt(newInstanceId, this.tempColor);

                this.voxels.set(k, { color: data.color, instanceId: newInstanceId });
                newInstanceId++;
            });
            this.instancedMesh.count = newInstanceId;
            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;

            const newVoxelState = [...this.voxels.entries()].map(([id, data]) => {
                const parts = this.parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            this.addCommand('resizeGrid', null, null, null, null, null, oldVoxelState, newVoxelState, { oldGrid: oldGrid, newGrid: this.GRID });
        }
        this.rebuildHelpers();
        this.resetCameraPosition();
    }

    /**
     * Exports the current voxel model as an STL file.
     * @public
     */
    exportSTL() {
        if (this.instancedMesh.count === 0) {
            return { success: false, message: 'No voxels to export.' };
        }

        const geometriesToMerge = [];
        const tempBoxGeometry = new THREE.BoxGeometry(this.VS, this.VS, this.VS);
        const tempMatrix = new THREE.Matrix4();
        const tempColorExport = new THREE.Color();

        for (let i = 0; i < this.instancedMesh.count; i++) {
            this.instancedMesh.getMatrixAt(i, tempMatrix);
            this.instancedMesh.getColorAt(i, tempColorExport);

            const instanceGeometry = tempBoxGeometry.clone();
            instanceGeometry.applyMatrix4(tempMatrix);

            const colorArray = [];
            for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
                colorArray.push(tempColorExport.r, tempColorExport.g, tempColorExport.b);
            }
            instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
            geometriesToMerge.push(instanceGeometry);
        }

        let mergedGeometry;
        if (geometriesToMerge.length > 0) {
            mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true);
        } else {
            mergedGeometry = new THREE.BufferGeometry();
        }

        const tempMesh = new THREE.Mesh(mergedGeometry, this.instancedMesh.material);

        const exporter = new THREE.STLExporter();
        const result = exporter.parse(tempMesh);

        tempBoxGeometry.dispose();
        if (mergedGeometry) mergedGeometry.dispose();

        return { success: true, data: result, filename: 'voxel_model.stl', mimeType: 'application/octet-stream' };
    }

    /**
     * Imports an STL file and converts it into voxels.
     * @param {ArrayBuffer} arrayBuffer - The STL file content as an ArrayBuffer.
     * @public
     */
    importSTL(arrayBuffer) {
        const loader = new THREE.STLLoader();
        try {
            const geometry = loader.parse(arrayBuffer);
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const size = new THREE.Vector3();
            bbox.getSize(size);

            const oldState = [...this.voxels.entries()].map(([id, data]) => {
                const parts = this.parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            this.clearAllInternal(true);

            const scaleFactor = Math.min(this.GRID / size.x, this.GRID / this.GRID / size.y, this.GRID / size.z);
            const offset = new THREE.Vector3(
                -bbox.min.x * scaleFactor,
                -bbox.min.y * scaleFactor,
                -bbox.min.z * scaleFactor
            );

            const tempMesh = new THREE.Mesh(geometry);
            tempMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            tempMesh.position.copy(offset);
            tempMesh.updateMatrixWorld(true);

            const newVoxels = [];
            const color = new THREE.Color(this.currentColor);

            for (let x = 0; x < this.GRID; x++) {
                for (let y = 0; y < this.GRID; y++) {
                    for (let z = 0; z < this.GRID; z++) {
                        const worldX = x * this.VS + this.HALF;
                        const worldY = y * this.VS + this.HALF;
                        const worldZ = z * this.VS + this.HALF;

                        const point = new THREE.Vector3(worldX, worldY, worldZ);
                        const localPoint = point.clone().applyMatrix4(tempMesh.matrixWorld.clone().invert());

                        if (geometry.boundingBox.containsPoint(localPoint)) {
                            this.addVoxel(x, y, z, color.getHex(), true);
                            newVoxels.push({ gx: x, gy: y, gz: z, color: color.getHex() });
                        }
                    }
                }
            }
            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
            this.rebuildHelpers();
            this.resetCameraPosition();

            this.addCommand('importSTL', null, null, null, null, null, oldState, newVoxels);
            return { success: true, message: 'STL model imported and voxelized successfully.' };
        } catch (error) {
            console.error('Error loading STL file:', error);
            return { success: false, message: 'Error loading STL file. Ensure it is a valid STL file.' };
        }
    }

    /**
     * Exports the current voxel model as an OBJ file.
     * @public
     */
    exportOBJ() {
        if (this.instancedMesh.count === 0) {
            return { success: false, message: 'No voxels to export.' };
        }

        const voxelsToExport = [];
        let maxX = 0, maxY = 0, maxZ = 0;

        this.voxels.forEach((data, k) => {
            const [x, y, z] = this.parseKey(k);
            voxelsToExport.push({ x, y, z, c: 1 });
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
            maxZ = Math.max(maxZ, z);
        });

        const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
        const objText = VoxelShaperIO.voxToOBJ(voxModel, this.VS);

        return { success: true, data: objText, filename: 'voxel_model.obj', mimeType: 'text/plain' };
    }

    /**
     * Imports an OBJ file and converts it into voxels.
     * @param {string} objText - The OBJ file content as a string.
     * @public
     */
    importOBJ(objText) {
        try {
            const voxModel = VoxelShaperIO.objToVox(objText, this.VS);

            const oldState = [...this.voxels.entries()].map(([id, data]) => {
                const parts = this.parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            this.clearAllInternal(true);

            this.setGridSize(Math.max(voxModel.sizeX, voxModel.sizeY, voxModel.sizeZ), true);

            const newVoxels = [];
            const importColor = this.currentColor;

            voxModel.voxels.forEach(v => {
                if (v.x < this.GRID && v.y < this.GRID && v.z < this.GRID) {
                    this.addVoxel(v.x, v.y, v.z, importColor, true);
                    newVoxels.push({ gx: v.x, gy: v.y, gz: v.z, color: importColor });
                }
            });

            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
            this.rebuildHelpers();
            this.resetCameraPosition();

            this.addCommand('importOBJ', null, null, null, null, null, oldState, newVoxels);
            return { success: true, message: 'OBJ model imported and voxelized successfully.' };
        } catch (error) {
            console.error('Error loading OBJ file:', error);
            return { success: false, message: 'Error loading OBJ file. Ensure it is a valid OBJ file.' };
        }
    }

    /**
     * Exports the current voxel model as a VOX file.
     * @public
     */
    exportVOX() {
        if (this.instancedMesh.count === 0) {
            return { success: false, message: 'No voxels to export.' };
        }

        const voxelsToExport = [];
        const uniqueColors = new Map();
        const palette = new Uint32Array(256);
        palette[0] = 0x00000000;

        let maxX = 0, maxY = 0, maxZ = 0;

        let currentPaletteIndex = 1;
        this.voxels.forEach((data) => {
            if (!uniqueColors.has(data.color)) {
                if (currentPaletteIndex < 256) {
                    uniqueColors.set(data.color, currentPaletteIndex);
                    palette[currentPaletteIndex] = (parseInt(data.color.substring(1), 16) << 8) | 0xFF;
                    currentPaletteIndex++;
                } else {
                    console.warn("More than 255 unique colors detected. Some colors may be lost during VOX export.");
                }
            }
        });

        this.voxels.forEach((data, k) => {
            const [x, y, z] = this.parseKey(k);
            const paletteIndex = uniqueColors.has(data.color) ? uniqueColors.get(data.color) : 1;
            voxelsToExport.push({ x, y, z, c: paletteIndex });
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
            maxZ = Math.max(maxZ, z);
        });

        const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport, palette);
        const arrayBuffer = VoxelShaperIO.buildVox(voxModel);

        return { success: true, data: arrayBuffer, filename: 'voxel_model.vox', mimeType: 'application/octet-stream' };
    }

    /**
     * Imports a VOX file and converts it into voxels.
     * @param {ArrayBuffer} arrayBuffer - The VOX file content as an ArrayBuffer.
     * @public
     */
    importVOX(arrayBuffer) {
        try {
            const voxModel = VoxelShaperIO.parseVox(arrayBuffer);

            if (!voxModel || !Array.isArray(voxModel.voxels)) {
                return { success: false, message: 'Invalid VOX model structure received from parser.' };
            }

            if (voxModel.voxels.length === 0) {
                this.clearAllInternal(true);
                this.setGridSize(10, true); // Reset to default grid size
                return { success: true, message: 'VOX file imported, but contained no voxels. Scene reset to default empty grid.' };
            }

            let offsetX = 0, offsetY = 0, offsetZ = 0;
            const minX = Math.min(...voxModel.voxels.map(v => v.x));
            const minY = Math.min(...voxModel.voxels.map(v => v.y));
            const minZ = Math.min(...voxModel.voxels.map(v => v.z));

            if (minX < 0) offsetX = -minX;
            if (minY < 0) offsetY = -minY;
            if (minZ < 0) offsetZ = -minZ;

            const oldState = [...this.voxels.entries()].map(([id, data]) => {
                const parts = this.parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            this.clearAllInternal(true);

            const newMaxX = (voxModel.sizeX || 0) + offsetX;
            const newMaxY = (voxModel.sizeY || 0) + offsetY;
            const newMaxZ = (voxModel.sizeZ || 0) + offsetZ;
            this.setGridSize(Math.max(newMaxX, newMaxY, newMaxZ, 10), true);

            const newVoxels = [];
            voxModel.voxels.forEach(v => {
                let colorHex = '#ffffff';
                if (v.c > 0 && v.c <= 256 && voxModel.palette) {
                    const rgba = voxModel.palette[v.c];
                    const r = (rgba >> 24) & 0xFF;
                    const g = (rgba >> 16) & 0xFF;
                    const b = (rgba >> 8) & 0xFF;
                    colorHex = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
                }

                const gx = v.x + offsetX;
                const gy = v.y + offsetY;
                const gz = v.z + offsetZ;

                if (gx >= 0 && gx < this.GRID && gy >= 0 && gy < this.GRID && gz >= 0 && gz < this.GRID) {
                    this.addVoxel(gx, gy, gz, colorHex, true);
                    newVoxels.push({ gx, gy, gz, color: colorHex });
                } else {
                    console.warn(`Voxel at (${v.x}, ${v.y}, ${v.z}) (offsetted to ${gx},${gy},${gz}) is out of new grid bounds [0, ${this.GRID-1}]. Skipping.`);
                }
            });

            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
            this.rebuildHelpers();
            this.resetCameraPosition();

            this.addCommand('importVOX', null, null, null, null, null, oldState, newVoxels);
            return { success: true, message: 'VOX model imported successfully.' };

        } catch (error) {
            console.error('Error loading VOX file:', error);
            return { success: false, message: 'Error loading VOX file. Ensure it is a valid MagicaVoxel (.vox) file.' };
        }
    }

    /**
     * Generates terrain based on Perlin noise and current terrain parameters.
     * @public
     */
    generateTerrain() {
        const oldState = [...this.voxels.entries()].map(([id, data]) => {
            const parts = this.parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        this.clearAllInternal(true);

        this.noise2D = new ValueNoise2D(this.terrainSeed);

        for (let x = 0; x < this.GRID; x++) {
            for (let z = 0; z < this.GRID; z++) {
                const noiseVal = (this.noise2D.fbm(x, z, this.terrainOctaves, this.terrainLacunarity, this.terrainGain) + 1) * 0.5;
                let terrainHeight = Math.floor(noiseVal * this.terrainHeightScale);

                terrainHeight = Math.max(1, Math.min(this.GRID, terrainHeight));

                for (let y = 0; y < terrainHeight; y++) {
                    let voxelColor;
                    if (y < this.terrainHeightScale * 0.2) {
                        voxelColor = 0x6495ED;
                    } else if (y < this.terrainHeightScale * 0.6) {
                        voxelColor = 0x8B4513;
                    } else {
                        voxelColor = 0x708237;
                    }
                    this.addVoxel(x, y, z, voxelColor, true);
                }
            }
        }
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
        this.rebuildHelpers();
        this.resetCameraPosition();

        const newState = [...this.voxels.entries()].map(([id, data]) => {
            const parts = this.parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        this.addCommand('terrainGenerate', null, null, null, null, null, oldState, newState);
    }

    /**
     * Resets the camera position to a default view of the grid.
     * @public
     */
    resetCameraPosition() {
        this.cam.position.set(this.GRID * 1.0, this.GRID * 1.2, this.GRID * 1.5);
        this.cam.lookAt(this.GRID / 2, this.GRID / 2, this.GRID / 2);
        this.euler.setFromQuaternion(this.cam.quaternion, 'YXZ');
    }

    /**
     * Loads an image as a template in the scene.
     * @param {string} base64Image - The base64 encoded image data.
     * @public
     */
    loadImageTemplate(base64Image) {
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = this.GRID * this.VS;
            const planeHeight = planeWidth / aspectRatio;

            if (this.templateImageMesh) {
                this.scene.remove(this.templateImageMesh);
                this.templateImageMesh.geometry.dispose();
                this.templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            this.templateImageMesh = new THREE.Mesh(geometry, material);

            this.templateImageMesh.position.set(
                (this.GRID * this.VS) / 2,
                (this.GRID * this.VS) / 2,
                -0.5 * this.VS
            );
            this.templateImageMesh.rotation.y = Math.PI;

            this.templateImageMesh.renderOrder = -1;
            this.scene.add(this.templateImageMesh);

            this.templateImageData = {
                src: base64Image,
                position: this.templateImageMesh.position.toArray(),
                rotation: this.templateImageMesh.rotation.toArray(),
                scale: this.templateImageMesh.scale.toArray(),
                locked: false,
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
        };
        img.src = base64Image;
    }

    /**
     * Removes the current image template from the scene.
     * @param {boolean} [fromLoad=false] - True if called during a project load.
     * @public
     */
    removeImageTemplate(fromLoad = false) {
        if (this.templateImageMesh) {
            this.scene.remove(this.templateImageMesh);
            this.templateImageMesh.geometry.dispose();
            this.templateImageMesh.material.dispose();
            this.templateImageMesh = null;
            this.templateImageData = null;
        }
    }

    /**
     * Locks or unlocks the image template, making it non-interactive when locked.
     * @param {boolean} locked - True to lock, false to unlock.
     * @public
     */
    lockImageTemplate(locked) {
        if (this.templateImageData) {
            this.templateImageData.locked = locked;
        }
        if (this.templateImageMesh) {
            if (locked) {
                this.templateImageMesh.raycast = function() {};
            } else {
                delete this.templateImageMesh.raycast;
            }
        }
    }

    /**
     * Adds a command to the history stack.
     * @param {string} type - Type of command (e.g., 'add', 'delete', 'recolor').
     * @param {number} [gx] - X-coordinate.
     * @param {number} [gy] - Y-coordinate.
     * @param {number} [gz] - Z-coordinate.
     * @param {string} [oldColor] - Old color for recolor/delete.
     * @param {string} [newColor] - New color for add/recolor.
     * @param {Array} [oldState] - Full voxel state before command (for clear/fill/terrain).
     * @param {Array} [newState] - Full voxel state after command (for clear/fill/terrain).
     * @param {object} [commandData] - Additional data for the command (e.g., grid resize).
     * @private
     */
    addCommand(type, gx, gy, gz, oldColor = null, newColor = null, oldState = null, newState = null, commandData = null) {
        if (this.historyPointer < this.history.length - 1) {
            this.history.splice(this.historyPointer + 1);
        }
        this.history.push({ type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData });
        this.historyPointer++;
        if (this.history.length > this.MAX_HISTORY_SIZE) {
            this.history.shift();
            this.historyPointer--;
        }
    }

    /**
     * Executes a history command.
     * @param {object} command - The command object.
     * @param {boolean} reverse - True to execute in reverse (undo).
     * @private
     */
    executeCommand(command, reverse = false) {
        const { type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData } = command;
        switch (type) {
            case 'add':
                if (reverse) { this.removeVoxel(gx, gy, gz, true); }
                else { this.addVoxel(gx, gy, gz, newColor, true); }
                break;
            case 'delete':
                if (reverse) { this.addVoxel(gx, gy, gz, oldColor, true); }
                else { this.removeVoxel(gx, gy, gz, true); }
                break;
            case 'recolor':
                if (reverse) { this.recolorVoxel(gx, gy, gz, oldColor, true); }
                else { this.recolorVoxel(gx, gy, gz, newColor, true); }
                break;
            case 'clearAll':
                if (reverse) {
                    this.clearAllInternal(true);
                    oldState.forEach(v => this.addVoxel(v.gx, v.gy, v.gz, v.color, true));
                } else {
                    this.clearAllInternal(true);
                }
                break;
            case 'fillLevel':
                if (reverse) {
                    this.clearAllInternal(true);
                    oldState.forEach(v => this.addVoxel(v.gx, v.gy, v.gz, v.color, true));
                } else {
                    this.clearAllInternal(true);
                    newState.forEach(v => this.addVoxel(v.gx, v.gy, v.gz, v.color, true));
                }
                break;
            case 'terrainGenerate':
                if (reverse) {
                    this.clearAllInternal(true);
                    oldState.forEach(v => this.addVoxel(v.gx, v.gy, v.gz, v.color, true));
                } else {
                    this.clearAllInternal(true);
                    newState.forEach(v => this.addVoxel(v.gx, v.gy, v.gz, v.color, true));
                }
                break;
            case 'resizeGrid':
                const targetGridSize = reverse ? commandData.oldGrid : commandData.newGrid;
                this.GRID = targetGridSize; // Directly set GRID
                // Update UI element if it exists (this is a side effect for the UI)
                const gridSizeSlider = document.getElementById('grid-size-slider');
                const gridSizeDisplay = document.getElementById('grid-size-display');
                if (gridSizeSlider) gridSizeSlider.value = this.GRID;
                if (gridSizeDisplay) gridSizeDisplay.textContent = `${this.GRID}×${this.GRID}×${this.GRID}`;
                localStorage.setItem('voxelEditorGridSize', this.GRID);

                this.clearAllInternal(true);
                const targetState = reverse ? oldState : newState;
                targetState.forEach(v => this.addVoxel(v.gx, v.gy, v.gz, v.color, true));
                break;
        }
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
        this.rebuildHelpers();
    }

    /**
     * Undoes the last action.
     * @public
     */
    undo() {
        if (this.historyPointer >= 0) {
            this.executeCommand(this.history[this.historyPointer], true);
            this.historyPointer--;
        }
    }

    /**
     * Redoes the last undone action.
     * @public
     */
    redo() {
        if (this.historyPointer < this.history.length - 1) {
            this.historyPointer++;
            this.executeCommand(this.history[this.historyPointer], false);
        }
    }

    // --- Input Handlers (remain as instance methods, called by UI event listeners) ---
    onPointerDown = (e) => {
        if (e.pointerType === 'mouse' && e.button === 2) {
            this.canvas.requestPointerLock();
            e.preventDefault();
            return;
        }

        if (!this.isPointerLocked) {
            this.pointerIsDown = true;
            this.lastX = e.clientX;
            this.lastY = e.clientY;
            this.lastActionVoxelCoords = null;
            this.initialClickPos = { x: e.clientX, y: e.clientY };

            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
            this.isHoldDrawingActive = false;
            this.longPressTimer = setTimeout(() => {
                this.isHoldDrawingActive = true;
            }, VoxelShaperCore.LONG_PRESS_DELAY_MS);

            this.fixedDragPlaneParams.level = null;
            this.fixedDragPlaneParams.axis = null;

            const now = performance.now();
            if (now - this.lastTap < VoxelShaperCore.DT_MS && this.tapCandidate && Math.hypot(e.clientX - this.tapCandidate.x, e.clientY - this.tapCandidate.y) < VoxelShaperCore.TAP_DIST_TH) {
                this.dblTapActive = true;
                this.isDblTapDragActive = true;
                this.activeGestureMode = 'dblTapDragDraw';
                this.setFixedDragPlane(e.clientX, e.clientY, this.currentMode);
            } else {
                this.dblTapActive = false;
                this.isDblTapDragActive = false;
                this.activeGestureMode = 'none';
                this.tapCandidate = { x: e.clientX, y: e.clientY, time: now };
            }

            const isShiftOrNormalDrag = (this.isShiftDragging || this.isDblTapDragActive) || (e.buttons === 1 && !this.isControlDragging);
            if (isShiftOrNormalDrag) {
                this.setFixedDragPlane(e.clientX, e.clientY, this.currentMode);
            }

            if (e.pointerType === 'touch') {
                this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
                this.handleGesture();
            }
        }
    }

    onPointerMove = (e) => {
        if (e.pointerType === 'touch') {
            this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
            this.handleGesture();
            if (this.activePointers.size > 1 && (this.gestureMode === 'pan' || this.gestureMode === 'pinch')) {
                this.updatePreviewVoxel(0, 0, 0, false);
                return;
            }
            if (this.activePointers.size === 1 && !this.isDblTapDragActive) {
                this.updatePreviewVoxel(0, 0, 0, false);
                return;
            }
        } else if (this.isPointerLocked) {
            if (this.firstMoveAfterLock) {
                this.firstMoveAfterLock = false;
                return;
            }
            const dx = e.movementX || 0;
            const dy = e.movementY || 0;
            this.euler.y -= dx * VoxelShaperCore.ROT_SPEED;
            this.euler.x -= dy * VoxelShaperCore.ROT_SPEED;
            this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
            this.cam.quaternion.setFromEuler(this.euler);
            return;
        }

        const currentTargetVoxel = this.calculateTargetVoxelCoords(e.clientX, e.clientY, this.currentMode, this.pointerIsDown, this.isControlDragging);

        if (currentTargetVoxel && !this.isPointerLocked) {
            this.updatePreviewVoxel(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, true);
        } else {
            this.updatePreviewVoxel(0, 0, 0, false);
        }

        if (this.pointerIsDown) {
            const movedDistance = this.initialClickPos ? Math.hypot(e.clientX - this.initialClickPos.x, e.clientY - this.initialClickPos.y) : 0;
            const isActualDrag = movedDistance > VoxelShaperCore.MOVE_PX;

            if (isActualDrag || this.isHoldDrawingActive || this.isDblTapDragActive) {
                if (currentTargetVoxel) {
                    if (this.isShiftDragging || this.isControlDragging || this.isDblTapDragActive || (this.fixedDragPlaneParams.level !== null && this.fixedDragPlaneParams.axis !== null)) {
                        if (!this.lastActionVoxelCoords ||
                            this.lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                            this.lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                            this.lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                            if (this.lastActionVoxelCoords) {
                                this.drawLineOfVoxels(this.lastActionVoxelCoords, currentTargetVoxel, this.currentMode, this.currentColor, this.currentBlockSize);
                            } else {
                                this.performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, this.currentMode, this.currentColor, this.currentBlockSize);
                            }
                            this.lastActionVoxelCoords = { ...currentTargetVoxel };
                        }
                    } else {
                        if (!this.lastActionVoxelCoords ||
                            this.lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                            this.lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                            this.lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                            this.performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, this.currentMode, this.currentColor, this.currentBlockSize);
                            this.lastActionVoxelCoords = { ...currentTargetVoxel };
                        }
                    }
                }
            }
        }
    }

    onPointerUp = (e) => {
        if (this.longPressTimer) {
            clearTimeout(this.longPressTimer);
            this.longPressTimer = null;
        }
        this.isHoldDrawingActive = false;

        if (e.pointerType === 'mouse') {
            if (e.button === 2) {
                document.exitPointerLock();
                return;
            }

            const movedDistance = this.initialClickPos ? Math.hypot(e.clientX - this.initialClickPos.x, e.clientY - this.initialClickPos.y) : 0;
            const wasSingleClick = movedDistance <= VoxelShaperCore.MOVE_PX;

            if (this.pointerIsDown && !this.isPointerLocked) {
                if (wasSingleClick) {
                    const clickedVoxel = this.calculateTargetVoxelCoords(e.clientX, e.clientY, this.currentMode, false, false);
                    if (clickedVoxel) {
                        this.performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, this.currentMode, this.currentColor, this.currentBlockSize);
                    }
                }
            }
            this.pointerIsDown = false;
            this.lastTap = performance.now();
        } else if (e.pointerType === 'touch') {
            this.releasePointer(e.pointerId);

            const movedDistance = this.initialClickPos ? Math.hypot(e.clientX - this.initialClickPos.x, e.clientY - this.initialClickPos.y) : 0;
            const wasSingleTap = movedDistance <= VoxelShaperCore.TAP_DIST_TH;

            if (!this.isPointerLocked && this.activePointers.size === 0) {
                if (wasSingleTap && !this.dblTapActive && !this.dblTapDrag) {
                    const clickedVoxel = this.calculateTargetVoxelCoords(e.clientX, e.clientY, this.currentMode, false, false);
                    if (clickedVoxel) {
                        this.performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, this.currentMode, this.currentColor, this.currentBlockSize);
                    }
                }
            }
        }

        this.updatePreviewVoxel(0, 0, 0, false);
        this.isControlDragging = false;
        this.isShiftDragging = false;
        this.dblTapDrag = false;
        this.isDblTapDragActive = false;
        this.activeGestureMode = 'none';
        this.lastActionVoxelCoords = null;
        this.initialClickPos = null;
        this.fixedDragPlaneParams.level = null;
        this.fixedDragPlaneParams.axis = null;
    }

    onPointerLeave = (e) => {
        if (e.pointerType === 'mouse') {
            this.pointerIsDown = false;
            this.lastActionVoxelCoords = null;
            this.updatePreviewVoxel(0, 0, 0, false);
        }
    }

    onPointerLockChange = () => {
        if (document.pointerLockElement === this.canvas) {
            this.isPointerLocked = true;
            this.firstMoveAfterLock = true;
            this.updatePreviewVoxel(0,0,0,false);
            this.euler.setFromQuaternion(this.cam.quaternion, 'YXZ');
        } else {
            this.isPointerLocked = false;
        }
    }

    onMouseWheel = (e) => {
        e.preventDefault();

        const sensitivity = 0.005;
        let zoomAmount = e.deltaY * sensitivity;

        if (e.altKey) {
            if (e.shiftKey) {
                this.setDrawingLevel(this.activeDrawingLevel.z - Math.sign(e.deltaY), 'z');
            } else if (e.ctrlKey) {
                this.setDrawingLevel(this.activeDrawingLevel.x - Math.sign(e.deltaY), 'x');
            } else {
                this.setDrawingLevel(this.activeDrawingLevel.y - Math.sign(e.deltaY), 'y');
            }
        } else {
            const speedChange = -Math.sign(e.deltaY) * 0.01;
            this.moveSpeed = Math.max(0.01, Math.min(1.0, this.moveSpeed + speedChange));
            // Update UI element (side effect for UI)
            const flySpeedSlider = document.getElementById('fly-speed-slider');
            const flySpeedDisplay = document.getElementById('fly-speed-display');
            if (flySpeedSlider) flySpeedSlider.value = this.moveSpeed;
            if (flySpeedDisplay) flySpeedDisplay.textContent = this.moveSpeed.toFixed(2);
            localStorage.setItem('voxelEditorFlySpeed', this.moveSpeed);

            this.cam.position.addScaledVector(
                this.cam.getWorldDirection(new THREE.Vector3()),
                zoomAmount * this.moveSpeed * 5
            );
        }
    }

    onKeyDown = (e) => {
        this.keyboard[e.key] = true;

        if (e.key === 'Shift') { this.isShiftDragging = true; }
        if (e.key === 'Control' || e.key === 'Meta') { this.isControlDragging = true; }

        if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); this.undo(); }
        if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); this.redo(); }

        switch (e.key) {
            case 'Tab': e.preventDefault(); this.cycleMode(); break;
            // Preset color selection is handled by UI, not core API
        }
    }

    onKeyUp = (e) => {
        this.keyboard[e.key] = false;
        if (e.key === 'Shift') { this.isShiftDragging = false; }
        if (e.key === 'Control' || e.key === 'Meta') { this.isControlDragging = false; }
    }

    handleGesture = () => {
        const pts = [...this.activePointers.values()];
        if (pts.length === 0) return;

        if (pts.length === 1){
            const p = pts[0];

            if (this.dblTapActive){
                if (!this.dblTapDrag){
                    const moved = Math.hypot(p.x - this.tapCandidate.x, p.y - this.tapCandidate.y);
                    if (moved > VoxelShaperCore.MOVE_PX){
                        this.dblTapDrag = true;
                        this.isShiftDragging = true;
                        this.setFixedDragPlane(p.x, p.y, this.currentMode);
                    }
                }
                if (this.dblTapDrag){
                    const currentTargetVoxel = this.calculateTargetVoxelCoords(p.x, p.y, this.currentMode, true, false);
                    if (currentTargetVoxel) {
                        if (!this.lastActionVoxelCoords ||
                            this.lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                            this.lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                            this.lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                            if (this.lastActionVoxelCoords) {
                                this.drawLineOfVoxels(this.lastActionVoxelCoords, currentTargetVoxel, this.currentMode, this.currentColor, this.currentBlockSize);
                            } else {
                                this.performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, this.currentMode, this.currentColor, this.currentBlockSize);
                            }
                            this.lastActionVoxelCoords = { ...currentTargetVoxel };
                        }
                    }
                }
                this.prevTouch = {x:p.x, y:p.y};
                return;
            }

            if (this.prevTouch === null){
                this.prevTouch = {x:p.x, y:p.y};
                return;
            }

            const dx = p.x - this.prevTouch.x;
            const dy = p.y - this.prevTouch.y;

            this.euler.y += dx * VoxelShaperCore.ROT_SPEED;
            this.euler.x += dy * VoxelShaperCore.ROT_SPEED;
            this.euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.euler.x));
            this.cam.quaternion.setFromEuler(this.euler);

            this.prevTouch = {x:p.x, y:p.y};
            return;
        }

        if (pts.length !== 2) return;

        const [p0, p1] = pts;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (this.gestureMid === null){
            this.gestureMid = {x:midX, y:midY};
            this.gestureDist = dist;
            this.gestureMode = null;
        }

        const dMid = Math.hypot(midX - this.gestureMid.x, midY - this.gestureMid.y);
        const relΔ = Math.abs(dist - this.gestureDist) / this.gestureDist;

        if (this.gestureMode === null){
            if (relΔ > VoxelShaperCore.PINCH_REL_TH) this.gestureMode = 'pinch';
            else if (dMid > VoxelShaperCore.PAN_PIX_TH) this.gestureMode = 'pan';
            else return;
        }

        if (this.gestureMode === 'pinch'){
            const scale = dist / this.gestureDist;
            const zoomDelta = (scale - 1) * VoxelShaperCore.PINCH_ZOOM_MULT * this.moveSpeed;
            this.cam.position.addScaledVector(
                this.cam.getWorldDirection(new THREE.Vector3()),
                zoomDelta
            );
            this.gestureDist = dist;
        } else {
            const panFactor = VoxelShaperCore.DRAG_BASE * (this.moveSpeed * 5);
            const dx = (midX - this.gestureMid.x) * panFactor;
            const dy = (midY - this.gestureMid.y) * panFactor;

            const dir = this.cam.getWorldDirection(new THREE.Vector3());
            const right = new THREE.Vector3().crossVectors(dir, this.cam.up).normalize();
            const upVec = this.cam.up.clone().normalize();

            this.cam.position.addScaledVector(right, -dx);
            this.cam.position.addScaledVector(upVec, dy);

            this.gestureMid = {x:midX, y:midY};
        }
        this.prevTouch = null;
    }

    releasePointer = (id) => {
        this.activePointers.delete(id);

        if (this.activePointers.size === 1){
            const last = [...this.activePointers.values()][0];
            this.prevTouch = { x:last.x, y:last.y };
            this.gestureMid = this.gestureDist = null;
            this.gestureMode = null;
            return;
        }

        if (this.activePointers.size === 0){
            this.tapCandidate = null;
            this.dblTapActive = false;
            this.dblTapDrag = false;
            this.isShiftDragging = false;
            this.isDblTapDragActive = false;
            this.gestureMid = this.gestureDist = null;
            this.gestureMode = null;
            this.prevTouch = null;
            this.lastActionVoxelCoords = null;
        }
    }
}

// Custom ValueNoise2D as a function constructor to avoid lexical declaration issues
function ValueNoise2D(seed = '') {
    this.seed = seed;
    this.rng = new Math.seedrandom(seed);
    if (typeof noise === 'undefined') {
        console.warn("Perlin.js library (noise object) not found. ValueNoise2D will use basic Math.random.");
        this.noiseGenerator = null;
    } else {
        this.noiseGenerator = new noise.Perlin();
    }
}

ValueNoise2D.prototype._smoothstep = function(t) {
    return t * t * (3 - 2 * t);
};

ValueNoise2D.prototype._lerp = function(a, b, t) {
    return a + t * (b - a);
};

ValueNoise2D.prototype.fbm = function(x, z, octaves, lacunarity, gain) {
    let total = 0;
    let amplitude = 1;
    let maxAmplitude = 0;
    let frequency = VoxelShaperCore.prototype.terrainFrequency; // Access from prototype or pass as param

    for (let i = 0; i < octaves; i++) {
        const x0 = Math.floor(x * frequency);
        const z0 = Math.floor(z * frequency);
        const x1 = x0 + 1;
        const z1 = z0 + 1;

        const fx = (x * frequency) - x0;
        const fz = (z * frequency) - z0;

        const val00 = new Math.seedrandom(`${this.seed}-${x0}-${z0}`)();
        const val10 = new Math.seedrandom(`${this.seed}-${x1}-${z0}`)();
        const val01 = new Math.seedrandom(`${this.seed}-${x0}-${z1}`)();
        const val11 = new Math.seedrandom(`${this.seed}-${x1}-${z1}`)();

        const ix0 = this._lerp(val00, val10, this._smoothstep(fx));
        const ix1 = this._lerp(val01, val11, this._smoothstep(fz));

        total += this._lerp(ix0, ix1, this._smoothstep(fz)) * amplitude;

        maxAmplitude += amplitude;

        frequency *= lacunarity;
        amplitude *= gain;
    }

    if (maxAmplitude === 0) return 0;
    return (total / maxAmplitude) * 2 - 1;
};


// --- UI Initialization and Event Handling ---
let voxelShaper; // Global instance of the core logic
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513',
    localStorage.getItem('voxelPresetColor2') || '#708237',
    localStorage.getItem('voxelPresetColor3') || '#6495ED'
];
let activePresetIndex = -1;
let presetBoxes = [];

// Generic message modal function
function showMessageModal(title, message) {
    const modal = document.getElementById('messageModal');
    document.getElementById('messageModalTitle').textContent = title;
    document.getElementById('messageModalText').textContent = message;
    modal.style.display = 'flex';
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        voxelShaper.setCurrentColor(presetColors[index]);
        document.getElementById('color-picker').value = voxelShaper.currentColor;
        localStorage.setItem('voxelEditorColor', voxelShaper.currentColor);

        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index;
    }
}

function saveCurrentColorToPreset(index) {
    if (index >= 0 && index < presetColors.length) {
        voxelShaper.currentColor = document.getElementById('color-picker').value;
        presetColors[index] = voxelShaper.currentColor;
        localStorage.setItem(`voxelPresetColor${index + 1}`, voxelShaper.currentColor);
        presetBoxes[index].style.backgroundColor = voxelShaper.currentColor;
        setActivePreset(index);
    }
}

window.onload = function() {
    const canvas = document.getElementById('voxelCanvas');
    const container = document.getElementById('container');
    voxelShaper = new VoxelShaperCore(canvas, container);

    // Initial UI updates based on core state
    document.getElementById('grid-size-slider').value = voxelShaper.GRID;
    document.getElementById('grid-size-display').textContent = `${voxelShaper.GRID}×${voxelShaper.GRID}×${voxelShaper.GRID}`;
    document.getElementById('color-picker').value = voxelShaper.currentColor;
    document.getElementById('current-mode').textContent = `Modus: ${voxelShaper.currentMode}`;
    document.getElementById('fly-speed-slider').value = voxelShaper.moveSpeed;
    document.getElementById('fly-speed-display').textContent = voxelShaper.moveSpeed.toFixed(2);
    document.getElementById('terrain-height-scale').value = voxelShaper.terrainHeightScale;
    document.getElementById('terrain-frequency').value = voxelShaper.terrainFrequency;
    document.getElementById('terrain-octaves').value = voxelShaper.terrainOctaves;
    document.getElementById('terrain-lacunarity').value = voxelShaper.terrainLacunarity;
    document.getElementById('terrain-gain').value = voxelShaper.terrainGain;
    document.getElementById('terrain-seed').value = voxelShaper.terrainSeed;
    document.getElementById(`block-size-${voxelShaper.currentBlockSize}x${voxelShaper.currentBlockSize}`).classList.add('active');


    // Event Listeners for UI
    window.addEventListener('resize', voxelShaper.onResize);
    container.addEventListener('pointerdown', voxelShaper.onPointerDown);
    container.addEventListener('pointermove', voxelShaper.onPointerMove);
    container.addEventListener('pointerup', voxelShaper.onPointerUp);
    container.addEventListener('pointercancel', voxelShaper.onPointerUp);
    container.addEventListener('pointerleave', voxelShaper.onPointerLeave);
    container.addEventListener('wheel', voxelShaper.onMouseWheel, { passive: false });
    document.addEventListener('keydown', voxelShaper.onKeyDown);
    document.addEventListener('keyup', voxelShaper.onKeyUp);
    document.addEventListener('pointerlockchange', voxelShaper.onPointerLockChange, false);
    container.addEventListener('contextmenu', (e) => e.preventDefault());

    document.getElementById('grid-size-slider').addEventListener('input', (e) => {
        voxelShaper.setGridSize(parseInt(e.target.value));
        document.getElementById('grid-size-display').textContent = `${voxelShaper.GRID}×${voxelShaper.GRID}×${voxelShaper.GRID}`;
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        voxelShaper.setCurrentColor(e.target.value);
        localStorage.setItem('voxelEditorColor', voxelShaper.currentColor);
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    });

    presetBoxes = [
        document.getElementById('color-preset-1'),
        document.getElementById('color-preset-2'),
        document.getElementById('color-preset-3')
    ];
    presetColors.forEach((color, index) => {
        const box = presetBoxes[index];
        box.style.backgroundColor = color;
        box.addEventListener('click', (e) => {
            if (e.shiftKey || e.ctrlKey || e.metaKey) { saveCurrentColorToPreset(index); }
            else { setActivePreset(index); }
        });
    });
    if (activePresetIndex !== -1) { setActivePreset(activePresetIndex); }
    else { document.getElementById('color-picker').value = voxelShaper.currentColor; }

    document.getElementById('modeToggle').addEventListener('click', () => {
        const newMode = voxelShaper.cycleMode();
        document.getElementById('current-mode').textContent = `Modus: ${newMode}`;
    });

    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').addEventListener('click', () => { clearConfirmationModal.style.display = 'flex'; });
    document.getElementById('saveAndClearBtn').addEventListener('click', () => {
        const { success, data, filename, mimeType } = voxelShaper.exportJSON();
        if (success) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showMessageModal('Export erfolgreich', 'Projekt erfolgreich gespeichert!');
        } else {
            showMessageModal('Export fehlgeschlagen', data);
        }
        voxelShaper.clearAllVoxels();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => {
        voxelShaper.clearAllVoxels();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('cancelClearBtn').addEventListener('click', () => { clearConfirmationModal.style.display = 'none'; });
    document.getElementById('messageModalCloseBtn').addEventListener('click', () => { document.getElementById('messageModal').style.display = 'none'; });

    document.getElementById('fillLevelBtn').addEventListener('click', () => voxelShaper.fillLevel());
    document.getElementById('saveBtn').addEventListener('click', () => {
        const { success, data, filename, mimeType } = voxelShaper.exportJSON();
        if (success) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showMessageModal('Export erfolgreich', 'Projekt erfolgreich gespeichert!');
        } else {
            showMessageModal('Export fehlgeschlagen', data);
        }
    });

    document.getElementById('loadBtn').addEventListener('click', () => { document.getElementById('fileInput').click(); });
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const projectData = JSON.parse(event.target.result);
                voxelShaper.loadVoxelsData(projectData);
                showMessageModal('Import erfolgreich', 'Projekt erfolgreich geladen.');
                // Update UI elements after loading
                document.getElementById('grid-size-slider').value = voxelShaper.GRID;
                document.getElementById('grid-size-display').textContent = `${voxelShaper.GRID}×${voxelShaper.GRID}×${voxelShaper.GRID}`;
                document.getElementById('color-picker').value = voxelShaper.currentColor;
                document.getElementById('fly-speed-slider').value = voxelShaper.moveSpeed;
                document.getElementById('fly-speed-display').textContent = voxelShaper.moveSpeed.toFixed(2);
                document.getElementById('terrain-height-scale').value = voxelShaper.terrainHeightScale;
                document.getElementById('terrain-frequency').value = voxelShaper.terrainFrequency;
                document.getElementById('terrain-octaves').value = voxelShaper.terrainOctaves;
                document.getElementById('terrain-lacunarity').value = voxelShaper.terrainLacunarity;
                document.getElementById('terrain-gain').value = voxelShaper.terrainGain;
                document.getElementById('terrain-seed').value = voxelShaper.terrainSeed;
                document.getElementById('lockImageTemplateCheckbox').checked = voxelShaper.templateImageData ? voxelShaper.templateImageData.locked : false;
                document.getElementById('removeImageTemplateBtn').style.display = voxelShaper.templateImageMesh ? 'inline-block' : 'none';

                document.querySelectorAll('.block-size-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`block-size-${voxelShaper.currentBlockSize}x${voxelShaper.currentBlockSize}`).classList.add('active');

                // Reload preset colors from local storage after loading project
                for(let i = 0; i < presetColors.length; i++) {
                    presetColors[i] = localStorage.getItem(`voxelPresetColor${i + 1}`) || presetColors[i];
                    presetBoxes[i].style.backgroundColor = presetColors[i];
                }
                setActivePreset(voxelShaper.activePresetIndex); // Re-apply active preset status
            } catch (error) {
                console.error('Error loading JSON file:', error);
                showMessageModal('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine gültige Voxel-Projekt-JSON-Datei handelt.');
            }
        };
        reader.readAsText(file);
    });

    document.getElementById('exportStlBtn').addEventListener('click', () => {
        const { success, data, filename, mimeType, message } = voxelShaper.exportSTL();
        if (success) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showMessageModal('Export erfolgreich', message);
        } else {
            showMessageModal('Export fehlgeschlagen', message);
        }
    });
    document.getElementById('importStlBtn').addEventListener('click', () => { document.getElementById('stlFileInput').click(); });
    document.getElementById('stlFileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const { success, message } = voxelShaper.importSTL(event.target.result);
            showMessageModal(success ? 'Import erfolgreich' : 'Import fehlgeschlagen', message);
        };
        reader.readAsArrayBuffer(file);
    });

    document.getElementById('exportObjBtn').addEventListener('click', () => {
        const { success, data, filename, mimeType, message } = voxelShaper.exportOBJ();
        if (success) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showMessageModal('Export erfolgreich', message);
        } else {
            showMessageModal('Export fehlgeschlagen', message);
        }
    });
    document.getElementById('importObjBtn').addEventListener('click', () => { document.getElementById('objFileInput').click(); });
    document.getElementById('objFileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const { success, message } = voxelShaper.importOBJ(event.target.result);
            showMessageModal(success ? 'Import erfolgreich' : 'Import fehlgeschlagen', message);
        };
        reader.readAsText(file);
    });

    document.getElementById('exportVoxBtn').addEventListener('click', () => {
        const { success, data, filename, mimeType, message } = voxelShaper.exportVOX();
        if (success) {
            const blob = new Blob([data], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showMessageModal('Export erfolgreich', message);
        } else {
            showMessageModal('Export fehlgeschlagen', message);
        }
    });
    document.getElementById('importVoxBtn').addEventListener('click', () => { document.getElementById('voxFileInput').click(); });
    document.getElementById('voxFileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const { success, message } = voxelShaper.importVOX(event.target.result);
            showMessageModal(success ? 'Import erfolgreich' : 'Import fehlgeschlagen', message);
        };
        reader.readAsArrayBuffer(file);
    });

    document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
        voxelShaper.moveSpeed = parseFloat(e.target.value);
        document.getElementById('fly-speed-display').textContent = voxelShaper.moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', voxelShaper.moveSpeed);
    });

    document.getElementById('block-size-1x1').addEventListener('click', () => voxelShaper.setBlockSize(1));
    document.getElementById('block-size-4x4').addEventListener('click', () => voxelShaper.setBlockSize(4));
    document.getElementById('block-size-8x8').addEventListener('click', () => voxelShaper.setBlockSize(8));
    document.getElementById('block-size-10x10').addEventListener('click', () => voxelShaper.setBlockSize(10));

    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');
    let showInfoBox = localStorage.getItem('showInfoBox') === 'true';
    function updateInfoBoxVisibility() {
        infoBox.style.display = showInfoBox ? 'block' : 'none';
        helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
        localStorage.setItem('showInfoBox', showInfoBox);
    }
    helpToggleBtn.addEventListener('click', () => { showInfoBox = !showInfoBox; updateInfoBoxVisibility(); });
    updateInfoBoxVisibility();

    const terrainControlsPanel = document.getElementById('terrainControlsPanel');
    const toggleTerrainControlsBtn = document.getElementById('toggleTerrainControlsBtn');
    let showTerrainControls = localStorage.getItem('showTerrainControls') === 'true';
    function updateTerrainControlsVisibility() {
        terrainControlsPanel.style.display = showTerrainControls ? 'flex' : 'none';
        toggleTerrainControlsBtn.textContent = showTerrainControls ? 'Gelände-Optionen ausblenden' : 'Gelände-Optionen anzeigen';
        localStorage.setItem('showTerrainControls', showTerrainControls);
    }
    toggleTerrainControlsBtn.addEventListener('click', () => { showTerrainControls = !showTerrainControls; updateTerrainControlsVisibility(); });
    updateTerrainControlsVisibility();

    document.getElementById('terrain-height-scale').addEventListener('input', (e) => voxelShaper.terrainHeightScale = parseInt(e.target.value));
    document.getElementById('terrain-frequency').addEventListener('input', (e) => voxelShaper.terrainFrequency = parseFloat(e.target.value));
    document.getElementById('terrain-octaves').addEventListener('input', (e) => voxelShaper.terrainOctaves = parseInt(e.target.value));
    document.getElementById('terrain-lacunarity').addEventListener('input', (e) => voxelShaper.terrainLacunarity = parseFloat(e.target.value));
    document.getElementById('terrain-gain').addEventListener('input', (e) => voxelShaper.terrainGain = parseFloat(e.target.value));
    document.getElementById('terrain-seed').addEventListener('input', (e) => {
        voxelShaper.terrainSeed = e.target.value;
        voxelShaper.hasUserTypedSeed = (voxelShaper.terrainSeed !== '');
    });
    document.getElementById('generateTerrainBtn').addEventListener('click', () => voxelShaper.generateTerrain());
    document.getElementById('resetCameraBtn').addEventListener('click', () => voxelShaper.resetCameraPosition());

    document.getElementById('loadImageTemplateBtn').addEventListener('click', () => { document.getElementById('imageFileInput').click(); });
    document.getElementById('imageFileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            voxelShaper.loadImageTemplate(event.target.result);
            document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
            document.getElementById('lockImageTemplateCheckbox').checked = false;
        };
        reader.readAsDataURL(file);
    });
    document.getElementById('removeImageTemplateBtn').addEventListener('click', () => {
        voxelShaper.removeImageTemplate();
        document.getElementById('removeImageTemplateBtn').style.display = 'none';
        document.getElementById('lockImageTemplateCheckbox').checked = false;
    });
    document.getElementById('lockImageTemplateCheckbox').addEventListener('change', (e) => {
        voxelShaper.lockImageTemplate(e.target.checked);
    });


    const menuToggle = document.getElementById('menuToggle');
    menuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        if (controlsPanel.style.display === 'none' || controlsPanel.style.display === '') {
            controlsPanel.style.display = 'flex';
        } else {
            controlsPanel.style.display = 'none';
        }
    });

    const mediaQuery = window.matchMedia('(max-width: 768px)');
    function handleMediaQueryChange(e) {
        const controlsPanel = document.getElementById('controls');
        if (e.matches) {
            controlsPanel.style.display = 'none';
            menuToggle.style.display = 'block';
        } else {
            controlsPanel.style.display = 'flex';
            menuToggle.style.display = 'none';
        }
    }
    mediaQuery.addListener(handleMediaQueryChange);
    handleMediaQueryChange(mediaQuery);
};
</script>
</body>
</html>
