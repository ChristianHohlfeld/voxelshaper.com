<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>
<style>
/* CSS für den Body mit Safe-Area-Anpassungen */
body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;

    /* --- WICHTIG: ANPASSUNGEN FÜR SICHERE BEREICHE --- */
    /* Verschiebt den Inhalt nach unten, um Platz für die Statusleiste/Notch zu schaffen */
    padding-top: env(safe-area-inset-top);
    /* Fügt Polsterung für den unteren Bereich hinzu (z.B. für Home-Indikatoren auf iPhones) */
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Entscheidend: Stellt sicher, dass das Padding in der 100vh Höhe enthalten ist */
    box-sizing: border-box;
    /* --- ENDE ANPASSUNGEN FÜR SICHERE BEREICHE --- */
}

/* verhindert, dass das OS den Canvas als Text selektiert */
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;    /* iOS Kontextmenü */
}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode{
    font-weight:700;
    color:#81c784;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box; /* Ensure border (if added back) doesn't push content out */
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    display: none;
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Style for the new terrain controls panel */
#terrainControlsPanel {
    background: #3a3f47;
    padding: 14px;
    margin-top: 10px;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    align-items: center;
    border: 1px solid #4a4f57;
    transition: all 0.3s ease-in-out;
}
/* ---------------------------------------------------
    HAMBURGER-BUTTON
    --------------------------------------------------- */
#menuToggle{
    position: fixed;
    /* top: 10px; <-- DIESE ZEILE WIRD GEÄNDERT! */
    top: calc(10px + env(safe-area-inset-top)); /* <-- NEU: Verschiebt es um 10px + Safe-Area nach unten */
    right: 10px;
    z-index: 1500;             /* über allen Panels */
    width: 42px; height: 42px;
    font-size: 1.4em;
    line-height: 42px;
    text-align: center;
    background:#555c66;
    color:#e0e0e0;
    border:none;
    border-radius:8px;
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.4);
}
#menuToggle:hover{background:#6a727f}

/* ---------------------------------------------------
    Responsive-Regel: Auf Viewports ≤ 768 px wird
    das Bedienfeld anfangs versteckt.
    --------------------------------------------------- */
@media (max-width:768px){
    #controls{display:none;}
}
/* ---------------------------------------------------
    Gelände-Button optisch hervorheben
    --------------------------------------------------- */
#generateTerrainBtn{
    padding: 12px 26px;
    font-size: 1.05em;
    font-weight: 600;
    letter-spacing: .3px;

    /* Farben im VoxelShaper-Grün */
    background: linear-gradient(180deg,#66bb6a 0%,#43a047 100%);
    color:#fff;

    border:none;
    border-radius:8px;
    cursor:pointer;

    /* leichter „erhabener“ Effekt */
    box-shadow:0 2px 6px rgba(0,0,0,.4);
    transition: transform .06s ease, box-shadow .06s ease;
}

/* Hover / Focus */
#generateTerrainBtn:hover,
#generateTerrainBtn:focus-visible{
    transform: translateY(-1px);
    box-shadow:0 4px 10px rgba(0,0,0,.45);
}

/* Aktiv (Button gedrückt) */
#generateTerrainBtn:active{
    transform: translateY(0);
    box-shadow:0 2px 4px rgba(0,0,0,.35);
}
/* Canvas & Container: KEINE default-Gesten */
#container,
#voxelCanvas{
    touch-action: none;           /* iOS ≥13.4, Android, Desktop */
    -ms-touch-action: none;       /* altes Edge/IE */

    /* ← neu: sorge dafür, dass die CSS-Border innen sitzt */
           box-sizing: border-box;
}
</style>
</head>
<body>
<button id="menuToggle" aria-label="Menü umschalten">☰</button>

<div id="controls">
    <label for="grid-size-slider">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="90" value="10">
    <span id="grid-size-display">10×10×10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff">
    <div id="color-preset-1" class="color-preset-box"></div>
    <div id="color-preset-2" class="color-preset-box"></div>
    <div id="color-preset-3" class="color-preset-box"></div>

    <button id="modeToggle">Modus wechseln</button><span id="current-mode">Modus: Hinzufügen</span>
    <button id="clearBtn">Alles löschen</button>
    <button id="fillLevelBtn">Ebene füllen</button>
    <button id="saveBtn">Projekt speichern</button>
    <button id="loadBtn">Projekt laden</button>
    <button id="exportStlBtn">STL Export</button>
    <button id="importStlBtn">STL Import</button> <!-- NEW: STL Import Button -->
    <button id="exportObjBtn">OBJ Export</button> <!-- NEW: OBJ Export Button -->
    <button id="importObjBtn">OBJ Import</button> <!-- NEW: OBJ Import Button -->
    <button id="exportVoxBtn">VOX Export</button> <!-- NEW: VOX Export Button -->
    <button id="importVoxBtn">VOX Import</button> <!-- NEW: VOX Import Button -->

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1">
    <span id="fly-speed-display">0.10</span>

    <label for="block-size-selector">Blockgröße:</label>
    <button id="block-size-1x1" class="block-size-btn active">1x1</button>
    <button id="block-size-4x4" class="block-size-btn">4x4</button>
    <button id="block-size-8x8" class="block-size-btn">8x8</button>
    <button id="block-size-10x10" class="block-size-btn">10x10</button> <!-- NEW: 10x10 Block Size Button -->

    <button id="toggleTerrainControlsBtn">Gelände-Optionen</button>
    <button id="helpToggleBtn">Hilfe</button>
    <button id="resetCameraBtn">Zur Szene zurückkehren</button>

    <!-- NEW: Image Template Controls -->
    <button id="loadImageTemplateBtn">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" style="display:none;">Bildvorlage entfernen</button>
    <label for="lockImageTemplateCheckbox">Vorlage sperren:</label>
    <input type="checkbox" id="lockImageTemplateCheckbox">
    <input type="file" id="imageFileInput" accept="image/*" style="display:none;">
</div>

<div id="terrainControlsPanel" style="display:none;">
    <button id="generateTerrainBtn">Gelände generieren</button>
    <label for="terrain-height-scale">Höhe:</label>
    <input type="number" id="terrain-height-scale" value="10" min="1" step="1">
    <label for="terrain-frequency">Frequenz:</label>
    <input type="number" id="terrain-frequency" value="0.05" min="0.001" max="0.5" step="0.001">
    <label for="terrain-octaves">Oktaven:</label>
    <input type="number" id="terrain-octaves" value="4" min="1" max="10" step="1">
    <label for="terrain-lacunarity">Lacunarity:</label>
    <input type="number" id="terrain-lacunarity" value="2.0" min="1.0" max="4.0" step="0.1">
    <label for="terrain-gain">Gain:</label>
    <input type="number" id="terrain-gain" value="0.5" min="0.1" max="1.0" step="0.01">
    <label for="terrain-seed">Seed:</label>
    <input type="text" id="terrain-seed" placeholder="Zahl oder Text">
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus → Kamera drehen (Fly Mode)<br>
    WASD / E / Q → bewegen<br>
    Linke MT → Voxel hinzuf./löschen/zeichnen<br>
    **Alt + Mausrad → Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad → Zeichenebene Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad → Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedrückt + Maus ziehen → Voxel Aktion auf aktiver Ebene (Hinzufügen / Löschen / Zeichnen)**<br>
    **Control + Linke MT gedrückt + Maus ziehen → Voxel ziehen zum Hinzufügen (Stapeln, nur im Hinzufügen-Modus)**<br>
    Mausrad → Kamera Geschwindigkeit anpassen<br>
    **Tab → Modus wechseln (Hinzufügen / Löschen / Zeichnen)**<br>
    **1, 2, 3 → Voreingestellte Farbe wählen (Shift/Strg/Cmd + 1,2,3 zum Speichern)**<br>
    **Strg + Z → Rückgängig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z → Wiederholen (Redo)**
    </div>
    <input type="file" id="fileInput" accept=".json">
    <input type="file" id="stlFileInput" accept=".stl" style="display:none;"> <!-- NEW: STL File Input -->
    <input type="file" id="objFileInput" accept=".obj" style="display:none;"> <!-- NEW: OBJ File Input -->
    <input type="file" id="voxFileInput" accept=".vox" style="display:none;"> <!-- NEW: VOX File Input -->
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt löschen</h3>
        <p>Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h3 id="messageModalTitle">Nachricht</h3>
        <p id="messageModalText"></p>
        <div class="modal-buttons">
            <button id="messageModalCloseBtn" class="cancel">Schließen</button>
        </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/noisejs/2.1.0/perlin.js"></script>
<script src="lib/voxelshaper_io.js"></script> <!-- NEW: VoxelShaperIO library -->


<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;

/* ---------- globale Variablen ---------- */
let isDblTapDragActive= false; // Controls if a double-tap-drag should activate drawing
let activeGestureMode = 'none'; // NEW: Verfolgt den aktuell aktiven Gestenmodus ('none', 'singleTouchCamera', 'multiTouchCamera', 'dblTapDragDraw')
let isHoldDrawingActive = false;   // NEW: Verfolgt, ob ein Long-Press-Zeichnen aktiv ist
const LONG_PRESS_DELAY_MS = 500;   // NEW: Wartezeit (in Millisekunden) für Long-Press-Erkennung

/* ----------------------------------------------
   GLOBAL – neue Hilfs-Variablen
---------------------------------------------- */
const PINCH_ZOOM_MULT = 40;     // Zoom-Geschwindigkeit ↑  (vorher 15, erhöht für schnellere mobile Erfahrung)
/* ---------- Double-Tap-State ---------- */
let tapCandidate   = null;   // {x,y,time}
const TAP_DIST_TH  = 10;     // max. Bewegung (px) für 'Tap'
let gestureMode  = null;   // null | 'pan' | 'pinch'
let gestureMid   = null;   // {x,y}  – letzte Mittel­punkt­position
let gestureDist  = null;   // vorheriger Zwei-Finger-Abstand
let longPressTimer = null; // Initialize longPressTimer to null

/* --- 2-Finger-Drag / Pinch ---------------------------------- */
const DRAG_BASE   = 0.1;   // Grund-faktor (wird mit moveSpeed multipliziert) (vorher 0.08)
const PAN_PIX_TH  = 10;      // ab 4 px Bewegung → Pan
const PINCH_REL_TH = 0.08;  // ≥6 % Distanzänderung → Pinch
let prevTouch = null;
let touchStartPos = null; // merkt Position für Tap-Erkennung
let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;   // Globale Drehgeschwindigkeit    (NEU)
/* --- Double-Tap Gesten ---------------------------------------- */
let lastTap       = 0;        // Zeitstempel des letzten pointerup
let dblTapActive  = false;    // true während des 2. Taps
let dblTapDrag    = false;    // wird true, sobald Finger > MOVE_PX zieht
const DT_MS       = 250;      // max. Abstand Taps (ms)
const MOVE_PX     = 10;        // ab hier gilt es als Drag (erhöht von 6)
/* ---------- Touch-Gesten (NEU) ---------- */
const activePointers = new Map();   // id → {x,y}
let isMultiTouchGestureActive = false; // NEW: Flag to track if a multi-touch gesture was active

let euler; // Declare euler globally
// voxels Map stores { color: hex_color, instanceId: number }
const voxels = new Map();
let cvs;
let containerDiv; // Reference to the container div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt für aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse für Alt+Mausrad

// NEW: Global object to store fixed plane parameters for drag operations
let fixedDragPlaneParams = { level: null, axis: null };

// Lade die Farbe aus dem Local Storage oder nutze Weiß als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
// Lade die Gittergröße aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;
console.log("Initial GRID size loaded:", GRID); // Debugging line for initial load

// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgrün (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen für Lichter, die Schatten werfen, um sie später anpassen zu können
let mainDirectionalLight;
let fillDirectionalLight; // NEW: Zweites gerichtetes Licht
let hemisphereLight;      // NEW: Hemisphärenlicht
let groundPlane;          // NEW: Bodenplatte

// Globale Variablen für Dragging-Status
let isShiftDragging = false;   // physische Shift-Taste

function shiftActive(){        // true, wenn Shift an
    return isShiftDragging;
}
let isControlDragging = false;
let rotate = false; // Moved to global as it's used across handlers
let isPointerLocked = false; // NEW: Track pointer lock status
let lastActionVoxelCoords = null; // NEW: Tracks the last voxel acted upon for drag drawing
let initialClickPos = null; // To differentiate click from drag
let firstMoveAfterLock = true; // NEW: Flag to ignore first movement after pointer lock

// Performance optimization: InstancedMesh
let instancedMesh; // Replaces voxelMesh and voxelGeometry
const dummy = new THREE.Object3D(); // For setting instance matrices
const tempColor = new THREE.Color(); // For setting instance colors

// NEU: Globale Variable für den Vorschau-Voxel
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // depthTest: false, damit er immer sichtbar ist
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Initialize here
// ENDE NEU

// Modus-Enum
const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen',
};
let currentMode = Modes.ADD; // Standardmodus

// Block Size
let currentBlockSize = 1; // Default to 1x1

// Undo/Redo History
const history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// Global terrain parameters (can be adjusted by UI)
let terrainHeightScale = 10;
let terrainFrequency = 0.05;
let terrainOctaves = 4;
let terrainLacunarity = 2.0;
let terrainGain = 0.5;
let terrainSeed = ''; // Empty string means random seed
let hasUserTypedSeed = false; // Flag to track if user has manually set the seed
// Global instance of the noise generator
let noise2D;

// NEW: Global variables for image template
let templateImageMesh = null;
// Updated templateImageData structure to store scaled dimensions
let templateImageData = null; // { src: base64, position: [], rotation: [], scale: [], locked: boolean, scaledWidth: number, scaledHeight: number }


// Custom ValueNoise2D as a function constructor to avoid lexical declaration issues
function ValueNoise2D(seed = '') {
    this.seed = seed;
    this.rng = new Math.seedrandom(seed);
    // Initialize Perlin noise. The 'noise' object should be available from perlin.js
    if (typeof noise === 'undefined') {
        console.warn("Perlin.js library (noise object) not found. ValueNoise2D will use basic Math.random.");
        this.noiseGenerator = null;
    } else {
        this.noiseGenerator = new noise.Perlin();
    }
}

ValueNoise2D.prototype._smoothstep = function(t) {
    return t * t * (3 - 2 * t);
};

ValueNoise2D.prototype._lerp = function(a, b, t) {
    return a + t * (b - a);
};

ValueNoise2D.prototype.fbm = function(x, z, octaves, lacunarity, gain) {
    let total = 0;
    let amplitude = 1;
    let maxAmplitude = 0;
    let frequency = terrainFrequency;

    for (let i = 0; i < octaves; i++) {
        const x0 = Math.floor(x * frequency);
        const z0 = Math.floor(z * frequency);
        const x1 = x0 + 1;
        const z1 = z0 + 1;

        const fx = (x * frequency) - x0;
        const fz = (z * frequency) - z0;

        // Use a temporary seeded RNG for each corner value to ensure determinism
        const val00 = new Math.seedrandom(`${this.seed}-${x0}-${z0}`)();
        const val10 = new Math.seedrandom(`${this.seed}-${x1}-${z0}`)();
        const val01 = new Math.seedrandom(`${this.seed}-${x0}-${z1}`)();
        const val11 = new Math.seedrandom(`${this.seed}-${x1}-${z1}`)();

        const ix0 = this._lerp(val00, val10, this._smoothstep(fx));
        const ix1 = this._lerp(val01, val11, this._smoothstep(fz));

        total += this._lerp(ix0, ix1, this._smoothstep(fz)) * amplitude;

        maxAmplitude += amplitude;

        frequency *= lacunarity;
        amplitude *= gain;
    }

    if (maxAmplitude === 0) return 0;
    return (total / maxAmplitude) * 2 - 1;
};


/* ---------- Hilfsfunktionen (alle vor window.onload verschoben) ---------- */

function onResize() {
    // Use containerDiv for sizing
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
}

function handleGesture () {
  const pts = [...activePointers.values()];
  if (pts.length === 0) return;

  if (pts.length === 1){
    const p = pts[0];

    // If double-tap-drag is active, handle drawing, not camera movement
    if (activeGestureMode === 'dblTapDragDraw'){
      if (!dblTapDrag){
        const moved = Math.hypot(p.x - touchStartPos.x,
                                 p.y - touchStartPos.y);
        if (moved > MOVE_PX){
          dblTapDrag      = true;
          isShiftDragging = true; // Enable line drawing
          // Fixed plane for dblTapDrag is already set in onPointerDown
        }
      }

      if (dblTapDrag){
        // In touch, dblTapDrag is like a shift-drag, so it should draw a line
        const currentTargetVoxel = calculateTargetVoxelCoords(p.x, p.y, currentMode, true, false); // Pass fixedDragPlaneParams implicitly
        if (currentTargetVoxel) {
            if (!lastActionVoxelCoords ||
                lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                
                if (lastActionVoxelCoords) {
                    drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor, currentBlockSize);
                } else {
                    performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
                }
                lastActionVoxelCoords = { ...currentTargetVoxel };
            }
        }
      }
      prevTouch = {x:p.x, y:p.y};
      return; // Exit, as we are in a drawing gesture
    }

    // Single-finger camera look
    if (prevTouch === null){
        prevTouch = {x:p.x, y:p.y}; // This should already be set in onPointerDown now
        return;
    }

    const dx = p.x - prevTouch.x;
    const dy = p.y - prevTouch.y;

    euler.y +=  dx * rotSpeed;
    euler.x +=  dy * rotSpeed;
    euler.x  =  Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
    cam.quaternion.setFromEuler(euler);

    prevTouch = {x:p.x, y:p.y};
    return;
  }

  // Multi-touch gestures (pan/pinch)
  if (pts.length !== 2) return;

  const [p0, p1] = pts;
  const midX  = (p0.x + p1.x) * 0.5;
  const midY  = (p0.y + p1.y) * 0.5;
  const dist  = Math.hypot(p1.x - p0.x, p1.y - p0.y);

  if (gestureMid === null){
    gestureMid  = {x:midX, y:midY};
    gestureDist = dist;
    gestureMode = null;
  }

  const dMid  = Math.hypot(midX - gestureMid.x, midY - gestureMid.y);
  const relΔ  = Math.abs(dist - gestureDist) / gestureDist;

  if (gestureMode === null){
    if (relΔ > PINCH_REL_TH)       gestureMode = 'pinch';
    else if (dMid > PAN_PIX_TH)    gestureMode = 'pan';
    else return;
  }

  if (gestureMode === 'pinch'){
    const scale     = dist / gestureDist;
    const zoomDelta = (scale - 1) * PINCH_ZOOM_MULT  * moveSpeed;
    cam.position.addScaledVector(
        cam.getWorldDirection(new THREE.Vector3()),
        zoomDelta
    );
    gestureDist = dist;
  } else { // Pan (strafe left/right, up/down)
    const panFactor = DRAG_BASE * (moveSpeed * 5);
    const dx = (midX - gestureMid.x) * panFactor;
    const dy = (midY - gestureMid.y) * panFactor;

    const dir   = cam.getWorldDirection(new THREE.Vector3());
    const right = new THREE.Vector3().crossVectors(dir, cam.up).normalize();
    const upVec = cam.up.clone().normalize(); // Use world up for vertical movement

    cam.position.addScaledVector(right, -dx); // Strafe left/right
    cam.position.addScaledVector(upVec, dy);   // Strafe up/down

    gestureMid = {x:midX, y:midY};
  }

  prevTouch = null;
}

function releasePointer(id){
    activePointers.delete(id);

    if (activePointers.size === 1){
        const last = [...activePointers.values()][0];
        prevTouch   = { x:last.x, y:last.y };
        gestureMid  = gestureDist = null;
        gestureMode = null;
        // If one pointer remains, and it was a double-tap-drag, keep that mode active
        // Otherwise, revert to single-touch camera mode
        if (!isDblTapDragActive) { // Only change mode if not already in dblTapDragDraw
             activeGestureMode = 'singleTouchCamera';
        }
        return;
    }

    if (activePointers.size === 0){
        tapCandidate   = null;
        dblTapActive   = false;
        dblTapDrag     = false;
        isShiftDragging = false;
        isDblTapDragActive= false;
        gestureMid  = gestureDist = null;
        gestureMode = null;
        prevTouch   = null;
        lastActionVoxelCoords = null; // Reset for next touch interaction
        activeGestureMode = 'none'; // Reset general gesture mode
    }
}

function rebuildHelpers() {
    if (typeof THREE === 'undefined') {
        console.error("THREE is not defined in rebuildHelpers. Cannot rebuild helpers.");
        return;
    }
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.z = Math.PI / 2;
        gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
}

// Maps grid coordinates (gx, gy, gz) to a unique string key
function key(gx, gy, gz) {
    return `${gx},${gy},${gz}`;
}

// Parses a string key back into grid coordinates
function parseKey(k) {
    return k.split(',').map(Number);
}

function cycleMode() {
    switch (currentMode) {
        case Modes.ADD:
            currentMode = Modes.DELETE;
            break;
        case Modes.DELETE:
            currentMode = Modes.DRAW;
            break;
        case Modes.DRAW:
            currentMode = Modes.ADD; // Cycle back to ADD
            break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor); // Save as current selected color

        // Update active class for visual feedback
        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index; // Store which preset is active
    }
}

// New function to save current color to a preset slot
function saveCurrentColorToPreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = document.getElementById('color-picker').value; // Ensure we get the latest color from picker
        presetColors[index] = currentColor; // Update the array with the current color picker value
        localStorage.setItem(`voxelPresetColor${index + 1}`, currentColor); // Persist to local storage
        presetBoxes[index].style.backgroundColor = currentColor; // Update visual of the preset box
        setActivePreset(index); // Make the newly saved preset the active one
        console.log(`Saving preset color ${index + 1}: ${currentColor}`);
        console.log(`localStorage 'voxelPresetColor${index + 1}' after save:`, localStorage.getItem(`voxelPresetColor${index + 1}`));
    }
}

function addCommand(type, gx, gy, gz, oldColor = null, newColor = null, oldState = null, newState = null, commandData = null) {
    // Clear redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    history.push({ type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData });
    historyPointer++;

    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

function executeCommand(command, reverse = false) {
    const { type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData } = command;
    switch (type) {
        case 'add':
            if (reverse) {
                removeVoxel(gx, gy, gz, true); // true for fromHistory
            } else {
                addVoxel(gx, gy, gz, newColor, true); // true for fromHistory
            }
            break;
        case 'delete':
            if (reverse) {
                addVoxel(gx, gy, gz, oldColor, true); // Re-add with original color
            } else {
                removeVoxel(gx, gy, gz, true);
            }
            break;
        case 'recolor':
            if (reverse) {
                recolorVoxel(gx, gy, gz, oldColor, true);
            } else {
                recolorVoxel(gx, gy, gz, newColor, true);
            }
            break;
        case 'clearAll':
            if (reverse) {
                clearAllInternal(true); // Clear current state first without history
                // Restore old state by adding voxels back
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear directly without history
            }
            break;
        case 'fillLevel':
            if (reverse) {
                clearAllInternal(true); // Clear current state
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear current state
                newState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            }
            break;
        case 'terrainGenerate':
            if (reverse) {
                clearAllInternal(true); // Clear current state
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear current state
                newState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            }
            break;
        case 'resizeGrid':
            const targetGridSize = reverse ? commandData.oldGrid : commandData.newGrid;
            GRID = targetGridSize;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            clearAllInternal(true); // Clear current state without history
            const targetState = reverse ? oldState : newState;
            targetState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            break;
    }
    // After executing a command, ensure the instancedMesh is updated
    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;
    rebuildHelpers(); // Ensure helpers reflect the new state
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // true for reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // false for forward
    }
}

// Function to add a voxel (updates InstancedMesh)
function addVoxel(gx, gy, gz, colorHex, fromHistory = false) {
    // Clamp coordinates to grid boundaries
    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    const k = key(gx, gy, gz);
    let instanceId;

    if (voxels.has(k)) {
        // Voxel already exists, check if color is different (recolor)
        const existingData = voxels.get(k);
        if (existingData.color !== colorHex) {
            if (!fromHistory) {
                addCommand('recolor', gx, gy, gz, existingData.color, colorHex);
            }
            instanceId = existingData.instanceId;
            tempColor.set(colorHex);
            instancedMesh.setColorAt(instanceId, tempColor);
            instancedMesh.instanceColor.needsUpdate = true;
            voxels.set(k, { color: colorHex, instanceId: instanceId });
        }
        // If color is the same, do nothing.
        return;
    } else {
        // New voxel, add to InstancedMesh
        if (!fromHistory) {
            addCommand('add', gx, gy, gz, null, colorHex);
        }

        instanceId = instancedMesh.count;
        if (instanceId >= instancedMesh.maxInstancedCount) {
            console.warn("Max instanced count reached! Cannot add more voxels.");
            return;
        }

        // Set matrix for the new instance
        dummy.position.set(gx * VS + HALF, gy * VS + HALF, gz * VS + HALF);
        dummy.updateMatrix();
        instancedMesh.setMatrixAt(instanceId, dummy.matrix);

        // Set color for the new instance
        tempColor.set(colorHex);
        instancedMesh.setColorAt(instanceId, tempColor);

        // Store voxel data and its instanceId in the map
        voxels.set(k, { color: colorHex, instanceId: instanceId });

        instancedMesh.count++; // Increment active instance count
        instancedMesh.instanceMatrix.needsUpdate = true;
        instancedMesh.instanceColor.needsUpdate = true;
    }
}


// Function to remove a voxel (updates InstancedMesh)
function removeVoxel(gx, gy, gz, fromHistory = false) {
    const k = key(gx, gy, gz);
    if (!voxels.has(k)) {
        return; // Voxel does not exist
    }

    const removedVoxelData = voxels.get(k);
    const removedInstanceId = removedVoxelData.instanceId;

    if (!fromHistory) {
        addCommand('delete', gx, gy, gz, removedVoxelData.color, null);
    }

    // If the voxel to be removed is not the last one, swap it with the last voxel
    if (removedInstanceId !== instancedMesh.count - 1) {
        // Find the key of the last voxel by its instanceId
        let lastVoxelKey = null;
        for (const [vk, vd] of voxels.entries()) {
            if (vd.instanceId === instancedMesh.count - 1) {
                lastVoxelKey = vk;
                break;
            }
        }
        const lastVoxelData = voxels.get(lastVoxelKey);

        // Copy matrix and color from the last instance to the removed instance's slot
        instancedMesh.getMatrixAt(instancedMesh.count - 1, dummy.matrix);
        instancedMesh.setMatrixAt(removedInstanceId, dummy.matrix);

        instancedMesh.getColorAt(instancedMesh.count - 1, tempColor);
        instancedMesh.setColorAt(removedInstanceId, tempColor);

        // Update the map entry for the moved voxel to its new instanceId
        voxels.set(lastVoxelKey, { color: lastVoxelData.color, instanceId: removedInstanceId });
    }

    // Decrement the active instance count
    instancedMesh.count--;
    // Remove the voxel from the map
    voxels.delete(k);

    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;
}

// Function to recolor a voxel (updates InstancedMesh)
function recolorVoxel(gx, gy, gz, newColorHex, fromHistory = false) {
    const k = key(gx, gy, gz);
    if (!voxels.has(k)) {
        return; // Voxel does not exist
    }

    const existingData = voxels.get(k);
    if (existingData.color === newColorHex) {
        return; // Color is already the same
    }

    if (!fromHistory) {
        addCommand('recolor', gx, gy, gz, existingData.color, newColorHex);
    }

    const instanceId = existingData.instanceId;
    tempColor.set(newColorHex);
    instancedMesh.setColorAt(instanceId, tempColor);
    instancedMesh.instanceColor.needsUpdate = true;
    voxels.set(k, { color: newColorHex, instanceId: instanceId });
}

// NEW: Helper function to perform the actual voxel modification for a block
function performVoxelModification(baseX, baseY, baseZ, mode, color, blockSize = 1) {
    // Determine the two axes along which the block will extend
    let axis1, axis2;
    if (currentDrawingAxis === 'y') {
        axis1 = 'x';
        axis2 = 'z';
    } else if (currentDrawingAxis === 'x') {
        axis1 = 'y';
        axis2 = 'z';
    } else { // currentDrawingAxis === 'z'
        axis1 = 'x';
        axis2 = 'y';
    }

    for (let i = 0; i < blockSize; i++) {
        for (let j = 0; j < blockSize; j++) {
            let x = baseX, y = baseY, z = baseZ;

            // Adjust coordinates based on block size and current drawing axis
            if (axis1 === 'x') x = baseX + i;
            else if (axis1 === 'y') y = baseY + i;
            else if (axis1 === 'z') z = baseZ + i;

            if (axis2 === 'x') x = baseX + j;
            else if (axis2 === 'y') y = baseY + j;
            else if (axis2 === 'z') z = baseZ + j;

            // Ensure the fixed axis remains at its base coordinate
            if (currentDrawingAxis === 'x') x = baseX;
            else if (currentDrawingAxis === 'y') y = baseY;
            else if (currentDrawingAxis === 'z') z = baseZ;

            // Clamp coordinates to grid boundaries
            const clampedX = Math.max(0, Math.min(GRID - 1, x));
            const clampedY = Math.max(0, Math.min(GRID - 1, y));
            const clampedZ = Math.max(0, Math.min(GRID - 1, z));

            const voxelKey = key(clampedX, clampedY, clampedZ);
            const actualHasVoxel = voxels.has(voxelKey);

            switch (mode) {
                case Modes.ADD:
                    if (!actualHasVoxel) {
                        addVoxel(clampedX, clampedY, clampedZ, color);
                    }
                    break;
                case Modes.DELETE:
                    if (actualHasVoxel) {
                        removeVoxel(clampedX, clampedY, clampedZ);
                    }
                    break;
                case Modes.DRAW:
                    if (actualHasVoxel && voxels.get(voxelKey).color !== color) {
                        recolorVoxel(clampedX, clampedY, clampedZ, color);
                    }
                    break;
            }
        }
    }
}

// NEW: DDA (Digital Differential Analyzer) for 3D Line Drawing
function drawLineOfVoxels(start, end, mode, color, blockSize = 1) {
    let x = start.gx;
    let y = start.gy;
    let z = start.gz;
    const x2 = end.gx;
    const y2 = end.gy;
    const z2 = end.gz;

    const dx = x2 - x;
    const dy = y2 - y;
    const dz = z2 - z;

    const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

    if (steps === 0) {
        performVoxelModification(x, y, z, mode, color, blockSize);
        return;
    }

    const x_inc = dx / steps;
    const y_inc = dy / steps;
    const z_inc = dz / steps;

    for (let i = 0; i <= steps; i++) {
        // Apply modification for the base of the block
        performVoxelModification(Math.round(x), Math.round(y), Math.round(z), mode, color, blockSize);
        x += x_inc;
        y += y_inc;
        z += z_inc;
    }
}


// NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Voxels
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            // Dispose old geometry
            if (previewVoxelMesh.geometry) {
                previewVoxelMesh.geometry.dispose();
            }

            const blockDimX = (currentDrawingAxis === 'y' || currentDrawingAxis === 'z') ? currentBlockSize * VS : VS;
            const blockDimY = (currentDrawingAxis === 'x' || currentDrawingAxis === 'z') ? currentBlockSize * VS : VS;
            const blockDimZ = (currentDrawingAxis === 'x' || currentDrawingAxis === 'y') ? currentBlockSize * VS : VS;

            const tempGeometry = new THREE.BoxGeometry(blockDimX, blockDimY, blockDimZ);
            previewVoxelMesh.geometry = tempGeometry;

            // Calculate the center of the block relative to its (x,y,z) base corner
            const centerX = x * VS + blockDimX / 2;
            const centerY = y * VS + blockDimY / 2;
            const centerZ = z * VS + blockDimZ / 2;

            previewVoxelMesh.position.set(centerX, centerY, centerZ);

            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor); // Vorschau-Farbe an aktuelle Farbe anpassen
            // Optional: Passe die Opazität basierend auf dem Modus an
            if (currentMode === Modes.DELETE) {
                previewVoxelMaterial.opacity = 0.2; // Weniger sichtbar beim Löschen
            } else {
                previewVoxelMaterial.opacity = 0.5; // Standard Opazität
            }
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}
// ENDE NEU

// NEW helper function to set the fixed drag plane parameters
function setFixedDragPlane(clientX, clientY, mode) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);
    // Raycast against the instancedMesh for hit detection
    const intersects = raycaster.intersectObject(instancedMesh);

    if (intersects.length > 0) {
        const hit = intersects[0];
        // The face normal is in world coordinates for the hit face
        const hitNormal = hit.face.normal;
        // The instanceId is available on the hit object for InstancedMesh
        const instanceId = hit.instanceId;

        // Retrieve the matrix of the hit instance
        const instanceMatrix = new THREE.Matrix4();
        instancedMesh.getMatrixAt(instanceId, instanceMatrix);

        // Get the position of the hit instance
        const instancePosition = new THREE.Vector3();
        instancePosition.setFromMatrixPosition(instanceMatrix);

        // Convert instance position to grid coordinates (assuming VS=1)
        const hitVoxelX = Math.round(instancePosition.x - HALF);
        const hitVoxelY = Math.round(instancePosition.y - HALF);
        const hitVoxelZ = Math.round(instancePosition.z - HALF);

        let level, axis;

        const absNx = Math.abs(hitNormal.x);
        const absNy = Math.abs(hitNormal.y);
        const absNz = Math.abs(hitNormal.z);

        if (mode === Modes.ADD) {
            // When adding, we want to place on the *next* layer relative to the hit voxel
            // This means using the hit voxel's coordinate + the normal component for that axis
            if (absNy > absNx && absNy > absNz) { // Hit top/bottom face (Y-axis)
                axis = 'y';
                level = hitVoxelY + Math.round(hitNormal.y);
            } else if (absNx > absNy && absNx > absNz) { // Hit side face (X-axis)
                axis = 'x';
                level = hitVoxelX + Math.round(hitNormal.x);
            } else { // Hit side face (Z-axis)
                axis = 'z';
                level = hitVoxelZ + Math.round(hitNormal.z);
            }
        } else { // DELETE or DRAW mode: target the layer *of* the hit voxel
            // For delete/draw, the fixed plane should be at the level of the hit voxel
            if (absNy > absNx && absNy > absNz) {
                axis = 'y';
                level = hitVoxelY;
            } else if (absNx > absNy && absNx > absNz) {
                axis = 'x';
                level = hitVoxelX;
            } else {
                axis = 'z';
                level = hitVoxelZ;
            }
        }
        fixedDragPlaneParams.level = level;
        fixedDragPlaneParams.axis = axis;
    } else {
        // If no voxel is hit, default to the current active drawing level and axis
        // This is for drawing in empty space
        fixedDragPlaneParams.axis = currentDrawingAxis;
        fixedDragPlaneParams.level = activeDrawingLevel[currentDrawingAxis];
    }
}


// Modified calculateTargetVoxelCoords to use fixedDragPlaneParams
function calculateTargetVoxelCoords(clientX, clientY, mode, isDragging, isStackingAdd) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    // Exclude templateImageMesh from raycasting for voxel operations if it's locked
    const objectsToIntersect = [instancedMesh];
    if (templateImageMesh && !templateImageData.locked) {
        // If template is NOT locked, we still don't want to interact with it for VOXEL placement.
        // It's purely a visual guide. So, we never add it to objectsToIntersect for voxel ops.
    }

    let targetVoxelCoords = null;

    // Special case: Ctrl-drag for stacking
    if (isStackingAdd) {
        const intersects = raycaster.intersectObjects(objectsToIntersect); // Use objectsToIntersect
        if (intersects.length > 0) {
            const hit = intersects[0];
            const instanceMatrix = new THREE.Matrix4();
            instancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
            const instancePosition = new THREE.Vector3();
            instancePosition.setFromMatrixPosition(instanceMatrix);

            const gx = Math.round(instancePosition.x - HALF);
            const gz = Math.round(instancePosition.z - HALF);
            let highestY = -1;
            for (let y = 0; y < GRID; y++) {
                if (voxels.has(key(gx, y, gz))) {
                    highestY = y;
                }
            }
            targetVoxelCoords = { gx: gx, gy: highestY + 1, gz: gz };
        } else {
            // If stacking and nothing hit, use the active drawing level as a fallback plane
            const intersectionPoint = new THREE.Vector3();
            const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -(activeDrawingLevel.y * VS));
            raycaster.ray.intersectPlane(plane, intersectionPoint);
            if(intersectionPoint){
                targetVoxelCoords = {
                    gx: Math.floor(intersectionPoint.x / VS),
                    gy: activeDrawingLevel.y,
                    gz: Math.floor(intersectionPoint.z / VS)
                };
            } else {
                return null; // Cannot determine stacking target without intersection
            }
        }
    }
    // Fixed plane drawing for all other drags (Shift-drag, DblTap-drag, normal ADD/DELETE/DRAW drag)
    else if (isDragging && fixedDragPlaneParams.level !== null && fixedDragPlaneParams.axis !== null) {
        let planeNormal = new THREE.Vector3();
        if (fixedDragPlaneParams.axis === 'y') planeNormal.set(0, 1, 0);
        else if (fixedDragPlaneParams.axis === 'x') planeNormal.set(1, 0, 0);
        else if (fixedDragPlaneParams.axis === 'z') planeNormal.set(0, 0, 1);
        const drawingPlane = new THREE.Plane(planeNormal, -(fixedDragPlaneParams.level * VS));

        const intersectionPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

        if (intersectionPoint) {
            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // Force the coordinate on the fixed axis to be the fixed level
            if (fixedDragPlaneParams.axis === 'y') gy = fixedDragPlaneParams.level;
            else if (fixedDragPlaneParams.axis === 'x') gx = fixedDragPlaneParams.level;
            else if (fixedDragPlaneParams.axis === 'z') gz = fixedDragPlaneParams.level;

            targetVoxelCoords = { gx, gy, gz };
        }
    }
    // Single click or initial point of drag (non-stacking, non-fixed-plane drag)
    else {
        const intersects = raycaster.intersectObjects(objectsToIntersect); // Use objectsToIntersect
        if (intersects.length > 0) {
            const hit = intersects[0];
            const hitNormal = hit.face.normal;
            const instanceMatrix = new THREE.Matrix4();
            instancedMesh.getMatrixAt(hit.instanceId, instanceMatrix);
            const instancePosition = new THREE.Vector3();
            instancePosition.setFromMatrixPosition(instanceMatrix);

            // Convert instance position to grid coordinates (assuming VS=1)
            const hitVoxelX = Math.round(instancePosition.x - HALF);
            const hitVoxelY = Math.round(instancePosition.y - HALF);
            const hitVoxelZ = Math.round(instancePosition.z - HALF);

            if (mode === Modes.ADD) {
                // For ADD, place on the face normal to the hit voxel
                targetVoxelCoords = {
                    gx: hitVoxelX + hitNormal.x,
                    gy: hitVoxelY + hitNormal.y,
                    gz: hitVoxelZ + hitNormal.z
                };
            } else { // DELETE or DRAW
                // For DELETE/DRAW, target the hit voxel itself
                targetVoxelCoords = {
                    gx: hitVoxelX,
                    gy: hitVoxelY,
                    gz: hitVoxelZ
                };
            }
        } else if (mode === Modes.ADD) {
            // Fallback for ADD when nothing is hit, use activeDrawingLevel
            const intersectionPoint = new THREE.Vector3();
            let planeNormal = new THREE.Vector3();
            if (currentDrawingAxis === 'y') planeNormal.set(0, 1, 0);
            else if (currentDrawingAxis === 'x') planeNormal.set(1, 0, 0);
            else if (currentDrawingAxis === 'z') planeNormal.set(0, 0, 1);
            const drawingPlane = new THREE.Plane(planeNormal, -(activeDrawingLevel[currentDrawingAxis] * VS));

            raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);
            if (intersectionPoint) {
                let gx = Math.floor(intersectionPoint.x / VS);
                let gy = Math.floor(intersectionPoint.y / VS);
                let gz = Math.floor(intersectionPoint.z / VS);

                if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

                targetVoxelCoords = { gx, gy, gz };
            }
        }
    }

    if (targetVoxelCoords) {
        // Clamp coordinates to grid boundaries
        targetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gx));
        targetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gy));
    targetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gz));
        return targetVoxelCoords;
    }
    return null;
}

function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        addCommand('clearAll', null, null, null, null, null, oldState, []);
    }
    voxels.clear();
    instancedMesh.count = 0;
    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;
    rebuildHelpers(); // Ensure helpers are reset or updated appropriately
}

function clearAll() {
    clearAllInternal(false); // User initiated clear, adds to history
}


function fillActiveLevel() {
    // Capture the current state before the fill for undo/redo
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    // Clear current voxels to prepare for fill, without adding to history
    // We will build the new state and add one command for the whole fill operation
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x; // Use x as y-coordinate for horizontal plane
                gz = z; // Use z as z-coordinate
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z; // Use z as y-coordinate for horizontal plane
                gz = activeDrawingLevel.z;
            }
            const k = key(gx, gy, gz);
            if (voxels.has(k)) {
                voxelsToRemove.push(k);
            }
        }
    }
    // Remove all existing voxels on the plane
    voxelsToRemove.forEach(k => {
        const [gx, gy, gz] = parseKey(k);
        removeVoxel(gx, gy, gz, true); // true for fromHistory, to avoid adding individual delete commands
    });


    // Add new voxels for the fill
    const newState = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x;
                gz = z;
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z;
                gz = activeDrawingLevel.z;
            }
            addVoxel(gx, gy, gz, currentColor, true); // true for fromHistory, to avoid adding individual add commands
            newState.push({ gx, gy, gz, color: currentColor });
        }
    }
    
    // Update InstancedMesh once after all operations
    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;

    // Add a single command for the entire fill operation
    addCommand('fillLevel', null, null, null, null, null, oldState, newState);
}


// With InstancedMesh, this function primarily signals updates.
// The actual matrix and color updates happen in addVoxel, removeVoxel, recolorVoxel.
function updateVoxelGeometry() {
    // These flags are set in addVoxel, removeVoxel, recolorVoxel.
    // Calling them here ensures they are set if any batch operation (like loadJSON)
    // bypasses individual updates.
    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;
}


function saveJSON() {
    const data = {};
    voxels.forEach((value, key) => {
        data[key] = value.color; // Save color value directly
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        terrainHeightScale: terrainHeightScale,
        terrainFrequency: terrainFrequency,
        terrainOctaves: terrainOctaves,
        terrainLacunarity: terrainLacunarity,
        terrainGain: terrainGain,
        terrainSeed: terrainSeed,
        moveSpeed: moveSpeed, // Save fly speed
        currentBlockSize: currentBlockSize, // Save current block size
        templateImageData: templateImageData // NEW: Save template image data
    };

    const projectData = {
        voxels: data,
        settings: settings
    };

    const json = JSON.stringify(projectData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            const loadedVoxels = projectData.voxels;
            const loadedSettings = projectData.settings;

            // Clear current state and history before loading new project
            clearAllInternal(true); // Clear without adding to history

            // Remove existing template image if any
            removeImageTemplate(true); // true to prevent history logging for this internal operation

            // Load settings first to get the correct GRID size
            if (loadedSettings) {
                GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                localStorage.setItem('voxelEditorGridSize', GRID); // Ensure it's saved back
                console.log("Loaded GRID size from JSON:", GRID);
                // Rebuild helpers and reset camera will happen after all settings are loaded
            }

            // Dispose old InstancedMesh if it exists
            if (instancedMesh) {
                scene.remove(instancedMesh);
                instancedMesh.geometry.dispose();
                instancedMesh.material.dispose();
            }

            // Re-initialize InstancedMesh with potentially new GRID size
            const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
            // Material should NOT have vertexColors: true if we're using instanceColor attribute
            meshMaterial = new THREE.MeshLambertMaterial(); // Removed vertexColors: true
            
            // Apply shader patch for instance colors with Lambert material
            meshMaterial.onBeforeCompile = (shader) => {
                // Add varying declaration to vertex shader (at the top, before main)
                shader.vertexShader = `
                    varying vec3 vInstanceColor; // Declare varying here
                    ${shader.vertexShader}
                `.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                );

                // Assign instanceColor to vInstanceColor after instanceMatrix is processed
                // The #ifdef USE_INSTANCING_COLOR block already declares 'attribute vec3 instanceColor;'
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <color_vertex>', // This is a good place as it's after attributes are set up
                    `
                    #include <color_vertex>
                    #ifdef USE_INSTANCING_COLOR
                        vInstanceColor = instanceColor; // Assign instance color to varying
                    #else
                        vInstanceColor = vec3(1.0); // Default to white if not using instancing color
                    #endif
                    `
                );

                // Modify fragment shader to use vInstanceColor
                shader.fragmentShader = `
                    varying vec3 vInstanceColor; // Declare varying in fragment shader
                    ${shader.fragmentShader}
                `.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    // Multiply material's diffuse color by instance color
                    'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
                );
            };

            const maxVoxelsForLoadedGrid = GRID * GRID * GRID; // Max instances based on loaded GRID
            instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxVoxelsForLoadedGrid);
            
            // Ensure instanceMatrix and instanceColor are properly initialized
            // These should be created by the InstancedMesh constructor, but this adds robustness.
            if (!instancedMesh.instanceMatrix) {
                instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 16), 16);
                instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix); // Also link to geometry
            }
            if (!instancedMesh.instanceColor) {
                instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 3), 3);
                instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor); // Also link to geometry
            }

            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            scene.add(instancedMesh);
            instancedMesh.count = 0; // Reset instance count


            // Load voxels
            let instanceCounter = 0; // Reset instance counter for loading
            for (const k in loadedVoxels) {
                const colorValue = loadedVoxels[k];
                const parts = parseKey(k);
                if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                    const gx = parts[0];
                    const gy = parts[1];
                    const gz = parts[2];

                    // Only add if within the bounds of the newly loaded GRID size
                    if (gx < GRID && gy < GRID && gz < GRID) {
                        if (instanceCounter >= instancedMesh.maxInstancedCount) {
                            console.warn("Max instanced count reached during load. Some voxels may not be loaded.");
                            break;
                        }

                        // Set matrix for the instance
                        dummy.position.set(gx * VS + HALF, gy * VS + HALF, gz * VS + HALF);
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(instanceCounter, dummy.matrix);

                        // Set color for the instance
                        tempColor.set(colorValue);
                        instancedMesh.setColorAt(instanceCounter, tempColor);

                        // Store voxel data and its instanceId in the map
                        voxels.set(key(gx, gy, gz), { color: colorValue, instanceId: instanceCounter });
                        instanceCounter++;
                    }
                }
            }
            instancedMesh.count = instanceCounter; // Update total instance count
            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;


            // Continue loading other settings after GRID is set and InstancedMesh is re-initialized
            if (loadedSettings) {
                if (loadedSettings.cameraPosition) {
                    cam.position.fromArray(loadedSettings.cameraPosition);
                }
                if (loadedSettings.cameraQuaternion) {
                    cam.quaternion.fromArray(loadedSettings.cameraQuaternion);
                    // Update Euler angles for pointer lock control
                    euler.setFromQuaternion(cam.quaternion, 'YXZ');
                }
                if (loadedSettings.activeDrawingLevel) {
                    activeDrawingLevel = { ...loadedSettings.activeDrawingLevel };
                }
                if (loadedSettings.currentDrawingAxis) {
                    currentDrawingAxis = loadedSettings.currentDrawingAxis;
                }
                updateGridHelperPosition(); // Rebuild with correct drawing axis

                currentColor = loadedSettings.currentColor || '#ffffff';
                document.getElementById('color-picker').value = currentColor;

                if (loadedSettings.presetColors) {
                    for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                        presetColors[i] = loadedSettings.presetColors[i];
                        document.getElementById(`color-preset-${i + 1}`).style.backgroundColor = presetColors[i];
                        // Persist loaded preset colors to local storage
                        localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                    }
                }
                // Re-apply active preset status
                setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);

                // Load terrain parameters
                terrainHeightScale = loadedSettings.terrainHeightScale !== undefined ? loadedSettings.terrainHeightScale : 10;
                terrainFrequency = loadedSettings.terrainFrequency !== undefined ? loadedSettings.terrainFrequency : 0.05;
                terrainOctaves = loadedSettings.terrainOctaves !== undefined  ? loadedSettings.octaves : 4;
                terrainLacunarity = loadedSettings.lacunarity !== undefined ? loadedSettings.lacunarity : 2.0;
                terrainGain = loadedSettings.gain !== undefined ? loadedSettings.gain : 0.5;
                terrainSeed = loadedSettings.terrainSeed !== undefined ? loadedSettings.terrainSeed : '';

                document.getElementById('terrain-height-scale').value = terrainHeightScale;
                document.getElementById('terrain-frequency').value = terrainFrequency;
                document.getElementById('terrain-octaves').value = terrainOctaves;
                document.getElementById('terrain-lacunarity').value = terrainLacunarity;
                document.getElementById('terrain-gain').value = terrainGain;
                document.getElementById('terrain-seed').value = terrainSeed;
                // Update hasUserTypedSeed based on loaded terrainSeed
                hasUserTypedSeed = (terrainSeed !== '');


                // Load fly speed
                if (loadedSettings.moveSpeed !== undefined) {
                    moveSpeed = loadedSettings.moveSpeed;
                    document.getElementById('fly-speed-slider').value = moveSpeed;
                    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                }

                // Load block size
                if (loadedSettings.currentBlockSize !== undefined) {
                    setBlockSize(loadedSettings.currentBlockSize); // Use the setter to update UI
                }

                // NEW: Load template image data
                if (loadedSettings.templateImageData) {
                    templateImageData = loadedSettings.templateImageData;
                    console.log("Loading template image data:", templateImageData); // Debugging
                    const loader = new THREE.TextureLoader();
                    loader.load(templateImageData.src, (texture) => {
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                        // FIX: Use scaledWidth and scaledHeight from saved data
                        const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                        if (templateImageMesh) {
                            scene.remove(templateImageMesh);
                            templateImageMesh.geometry.dispose();
                            templateImageMesh.material.dispose();
                        }
                        templateImageMesh = new THREE.Mesh(geometry, material);
                        templateImageMesh.position.fromArray(templateImageData.position);
                        templateImageMesh.rotation.fromArray(templateImageData.rotation);
                        templateImageMesh.scale.fromArray(templateImageData.scale); // This should now be [1,1,1] if scaledWidth/Height are used
                        templateImageMesh.renderOrder = -1; // Render behind other objects
                        scene.add(templateImageMesh);
                        document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
                        document.getElementById('lockImageTemplateCheckbox').checked = templateImageData.locked;
                        toggleLockImageTemplate(true); // Apply locked state
                    }, undefined, (err) => {
                        console.error('Error loading template image texture:', err);
                        templateImageMesh = null; // Clear mesh if loading fails
                        templateImageData = null;
                        document.getElementById('removeImageTemplateBtn').style.display = 'none';
                        document.getElementById('lockImageTemplateCheckbox').checked = false;
                    });
                }


                // Re-initialize noise generator with loaded seed
                noise2D = new ValueNoise2D(terrainSeed);
            }

            // After loading, ensure history is reset or cleared to avoid issues with old state
            history.length = 0;
            historyPointer = -1;

            console.log('Project loaded successfully.');
            resetCameraPosition(); // Reset camera to view loaded terrain/voxels
            // updateGroundPlaneSize(); // NEW: Update ground plane size after loading - REMOVED
        } catch (error) {
            console.error('Error loading JSON file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine gültige Voxel-Projekt-JSON-Datei handelt.');
        }
    };
    reader.readAsText(file);
}


function exportSTL() {
    if (instancedMesh.count === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    // Create a temporary BufferGeometry by merging individual geometries
    const geometriesToMerge = [];
    const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    const tempMatrix = new THREE.Matrix4();
    const tempColorExport = new THREE.Color();

    for (let i = 0; i < instancedMesh.count; i++) {
        instancedMesh.getMatrixAt(i, tempMatrix);
        instancedMesh.getColorAt(i, tempColorExport);

        const instanceGeometry = tempBoxGeometry.clone();
        instanceGeometry.applyMatrix4(tempMatrix);

        // Assign color to each vertex of the instance
        const colorArray = [];
        for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
            colorArray.push(tempColorExport.r, tempColorExport.g, tempColorExport.b);
        }
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
        geometriesToMerge.push(instanceGeometry);
    }

    let mergedGeometry;
    if (geometriesToMerge.length > 0) {
        mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true);
    } else {
        mergedGeometry = new THREE.BufferGeometry();
    }

    const tempMesh = new THREE.Mesh(mergedGeometry, instancedMesh.material); // Use the same material

    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh); // Parse the temporary merged mesh

    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Dispose temporary geometries to free memory
    tempBoxGeometry.dispose();
    if (mergedGeometry) mergedGeometry.dispose();
    showMessageModal('Export erfolgreich', 'STL-Modell erfolgreich exportiert!');
}

// NEW: Function to import STL
function importSTL(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const loader = new THREE.STLLoader();
        try {
            const geometry = loader.parse(e.target.result);
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const size = new THREE.Vector3();
            bbox.getSize(size);

            // Clear current voxels before importing
            clearAllInternal(true);

            const oldState = [...voxels.entries()].map(([id, data]) => {
                const parts = parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            // Simple voxelization: Iterate through the bounding box and sample points
            // This is a basic approach and might not capture all details or handle complex meshes perfectly.
            const scaleFactor = Math.min(GRID / size.x, GRID / GRID / size.y, GRID / size.z); // Corrected scale factor calculation
            const offset = new THREE.Vector3(
                -bbox.min.x * scaleFactor,
                -bbox.min.y * scaleFactor,
                -bbox.min.z * scaleFactor
            );

            const tempMesh = new THREE.Mesh(geometry); // Create a temporary mesh for raycasting
            tempMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            tempMesh.position.copy(offset);
            tempMesh.updateMatrixWorld(true); // Ensure world matrix is updated

            const newVoxels = [];
            const color = new THREE.Color(currentColor); // Use current color for imported voxels

            // A simple voxelization approach: iterate through grid cells and check if center is inside mesh
            // This is computationally intensive and may not be accurate for complex shapes
            // A more advanced approach would involve raycasting or signed distance fields.
            for (let x = 0; x < GRID; x++) {
                for (let y = 0; y < GRID; y++) {
                    for (let z = 0; z < GRID; z++) {
                        const worldX = x * VS + HALF;
                        const worldY = y * VS + HALF;
                        const worldZ = z * VS + HALF;

                        // Check if this point is "inside" the mesh. This is a very rough check.
                        // A proper "point in mesh" test is complex. For simplicity, we'll just
                        // check if the mesh's bounding box contains the voxel center.
                        // For more accurate voxelization, consider libraries or more advanced algorithms.
                        const point = new THREE.Vector3(worldX, worldY, worldZ);
                        // Convert point to local space of the imported mesh for bounding box check
                        const localPoint = point.clone().applyMatrix4(tempMesh.matrixWorld.clone().invert());

                        if (geometry.boundingBox.containsPoint(localPoint)) {
                            // If the point is within the bounding box, add the voxel.
                            // This is not a true voxelization, but a quick approximation.
                            addVoxel(x, y, z, color.getHex(), true);
                            newVoxels.push({ gx: x, gy: y, gz: z, color: color.getHex() });
                        }
                    }
                }
            }
            updateVoxelGeometry();
            rebuildHelpers();
            resetCameraPosition();
            // updateGroundPlaneSize(); // NEW: Update ground plane size after importing - REMOVED

            addCommand('importSTL', null, null, null, null, null, oldState, newVoxels);
            showMessageModal('Import erfolgreich', 'STL-Modell erfolgreich importiert und in Voxel umgewandelt. Beachten Sie, dass die Voxelisierung eine Annäherung ist und bei komplexen Modellen zu Detailverlust führen kann.');

        } catch (error) {
            console.error('Error loading STL file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der STL-Datei. Stellen Sie sicher, dass es sich um eine gültige STL-Datei handelt.');
        }
    };
    reader.readAsArrayBuffer(file);
}

// NEW: Function to export OBJ
function exportOBJ() {
    if (instancedMesh.count === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const voxelsToExport = [];
    let maxX = 0, maxY = 0, maxZ = 0;

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        voxelsToExport.push({ x, y, z, c: 1 }); // VoxelShaperIO.voxToOBJ doesn't use color index directly for OBJ
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    const objText = VoxelShaperIO.voxToOBJ(voxModel, VS); // Use VS (1) as cubeSize

    VoxelShaperIO.saveBlob(objText, 'voxel_model.obj');
    showMessageModal('Export erfolgreich', 'OBJ-Modell erfolgreich exportiert!');
}

// NEW: Function to import OBJ
function importOBJ(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const objText = e.target.result;
            const voxModel = VoxelShaperIO.objToVox(objText, VS); // Use VS (1) as voxelSize

            // Clear current voxels before importing
            clearAllInternal(true);

            const oldState = [...voxels.entries()].map(([id, data]) => {
                const parts = parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            // Update GRID size based on imported model
            GRID = Math.max(voxModel.sizeX, voxModel.sizeY, voxModel.sizeZ);
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            const newVoxels = [];
            // Use current color for imported voxels as OBJ has no inherent palette in this context
            const importColor = currentColor;

            voxModel.voxels.forEach(v => {
                // Ensure imported voxels are within new GRID bounds
                if (v.x < GRID && v.y < GRID && v.z < GRID) {
                    addVoxel(v.x, v.y, v.z, importColor, true);
                    newVoxels.push({ gx: v.x, gy: v.y, gz: v.z, color: importColor });
                }
            });

            updateVoxelGeometry();
            rebuildHelpers();
            resetCameraPosition();
            // updateGroundPlaneSize(); // NEW: Update ground plane size after importing - REMOVED

            addCommand('importOBJ', null, null, null, null, null, oldState, newVoxels);
            showMessageModal('Import erfolgreich', 'OBJ-Modell erfolgreich importiert und in Voxel umgewandelt. Beachten Sie, dass die Voxelisierung eine Annäherung ist und bei komplexen Modellen zu Detailverlust führen kann.');

        } catch (error) {
            console.error('Error loading OBJ file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der OBJ-Datei. Stellen Sie sicher, dass es sich um eine gültige OBJ-Datei handelt.');
        }
    };
    reader.readAsText(file);
}

// NEW: Function to export VOX
function exportVOX() {
    if (instancedMesh.count === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const voxelsToExport = [];
    const uniqueColors = new Map(); // Map<hexColor, paletteIndex>
    let paletteIndexCounter = 1; // MagicaVoxel palette indices are 1-based (0 is empty)
    const palette = new Uint32Array(256);
    palette[0] = 0x00000000; // Transparent black for index 0

    let maxX = 0, maxY = 0, maxZ = 0;

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        voxelsToExport.push({ x, y, z, c: paletteIndexCounter }); // Use a dummy index for now, will be updated
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    // Populate palette and assign correct indices
    let currentPaletteIndex = 1;
    voxels.forEach((data, k) => {
        if (!uniqueColors.has(data.color)) {
            if (currentPaletteIndex < 256) {
                uniqueColors.set(data.color, currentPaletteIndex);
                palette[currentPaletteIndex] = (parseInt(data.color.substring(1), 16) << 8) | 0xFF; // Add alpha FF
                currentPaletteIndex++;
            } else {
                console.warn("More than 255 unique colors detected. Some colors may be lost during VOX export.");
            }
        }
    });

    // Re-map voxel colors to their palette indices
    const finalVoxelsToExport = [];
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        const paletteIndex = uniqueColors.has(data.color) ? uniqueColors.get(data.color) : 1; // Default to index 1 if color not found (shouldn't happen)
        finalVoxelsToExport.push({ x, y, z, c: paletteIndex });
    });


    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, finalVoxelsToExport, palette);
    const arrayBuffer = VoxelShaperIO.buildVox(voxModel);

    VoxelShaperIO.saveBlob(arrayBuffer, 'voxel_model.vox');
    showMessageModal('Export erfolgreich', 'VOX-Modell erfolgreich exportiert!');
}

// NEW: Function to import VOX
function importVOX(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const arrayBuffer = e.target.result;
            const voxModel = VoxelShaperIO.parseVox(arrayBuffer);

            console.log("VOX Model parsed:", voxModel);
            console.log("VOX Model dimensions (sizeX, sizeY, sizeZ):", voxModel ? voxModel.sizeX : 'N/A', voxModel ? voxModel.sizeY : 'N/A', voxModel ? voxModel.sizeZ : 'N/A');
            console.log("Number of voxels in VOX Model:", voxModel && Array.isArray(voxModel.voxels) ? voxModel.voxels.length : 'voxels property missing or not an array');

            // --- NEU: Umfassendere Validierung des geparsten Modells ---
            // Check for fundamental structural validity first
            if (!voxModel || !Array.isArray(voxModel.voxels)) {
                console.warn("Invalid VOX model structure received from parser.");
                showMessageModal('Import fehlgeschlagen', 'Die geladene VOX-Datei hat eine ungültige Struktur, die von der Bibliothek nicht verarbeitet werden kann. Überprüfen Sie die Konsole für weitere Details.');
                return; // Exit if the structure itself is invalid (e.g., voxModel is null or voxels is not an array)
            }

            // Handle empty model gracefully
            if (voxModel.voxels.length === 0) {
                clearAllInternal(true); // Clear current scene
                GRID = 10; // Set a default grid size
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                localStorage.setItem('voxelEditorGridSize', GRID);
                rebuildHelpers();
                resetCameraPosition();
                // updateGroundPlaneSize(); // NEW: Update ground plane size for empty scene - REMOVED
                showMessageModal('Import abgeschlossen', 'Die VOX-Datei wurde erfolgreich importiert, enthielt jedoch keine Voxel. Die Szene wurde auf eine leere Standardgröße zurückgesetzt.');
                return; // Exit after handling empty model
            }
            // --- ENDE NEU ---

            let offsetX = 0, offsetY = 0, offsetZ = 0;
            
            // Calculate min coordinates only if voxels exist
            // This block is now guaranteed to run only if voxModel.voxels.length > 0
            const minX = Math.min(...voxModel.voxels.map(v => v.x));
            const minY = Math.min(...voxModel.voxels.map(v => v.y));
            const minZ = Math.min(...voxModel.voxels.map(v => v.z));
            console.log(`Original Min Voxel Coords: X=${minX}, Y=${minY}, Z=${minZ}`);

            // Calculate offsets to make all coordinates non-negative
            if (minX < 0) offsetX = -minX;
            if (minY < 0) offsetY = -minY;
            if (minZ < 0) offsetZ = -minZ;

            if (offsetX > 0 || offsetY > 0 || offsetZ > 0) {
                console.log(`Applying offset: X+${offsetX}, Y+${offsetY}, Z+${offsetZ}`);
            }
            

            // Clear current voxels before importing
            clearAllInternal(true);

            const oldState = [...voxels.entries()].map(([id, data]) => {
                const parts = parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            // Update GRID size based on imported model, considering the new max dimensions after offset
            // Ensure sizeX/Y/Z are at least 0, even if the parser returns 0 (though unlikely if voxels exist)
            const newMaxX = (voxModel.sizeX || 0) + offsetX;
            const newMaxY = (voxModel.sizeY || 0) + offsetY;
            const newMaxZ = (voxModel.sizeZ || 0) + offsetZ;
            GRID = Math.max(newMaxX, newMaxY, newMaxZ, 10); // Ensure minimum GRID size
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            console.log("Updated GRID size to:", GRID);


            // Dispose old InstancedMesh if it exists
            if (instancedMesh) {
                scene.remove(instancedMesh);
                instancedMesh.geometry.dispose();
                instancedMesh.material.dispose();
            }

            // Re-initialize InstancedMesh with potentially new GRID size
            const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
            meshMaterial = new THREE.MeshLambertMaterial();
            meshMaterial.onBeforeCompile = (shader) => {
                shader.vertexShader = `
                    varying vec3 vInstanceColor;
                    ${shader.vertexShader}
                `.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                );
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <color_vertex>',
                    `
                    #include <color_vertex>
                    #ifdef USE_INSTANCING_COLOR
                        vInstanceColor = instanceColor;
                    #else
                        vInstanceColor = vec3(1.0);
                    #endif
                    `
                );
                shader.fragmentShader = `
                    varying vec3 vInstanceColor;
                    ${shader.fragmentShader}
                `.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
                );
            };

            const maxVoxelsForLoadedGrid = GRID * GRID * GRID;
            instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxVoxelsForLoadedGrid);
            if (!instancedMesh.instanceMatrix) {
                instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 16), 16);
                instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix);
            }
            if (!instancedMesh.instanceColor) {
                instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 3), 3);
                instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor);
            }
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            scene.add(instancedMesh);
            instancedMesh.count = 0; // Reset instance count


            const newVoxels = [];
            voxModel.voxels.forEach(v => {
                // MagicaVoxel color indices are 1-based. Index 0 is transparent.
                // Palette colors are RGBA, so we need to convert to hex string.
                let colorHex = '#ffffff'; // Default fallback color
                if (v.c > 0 && v.c <= 256 && voxModel.palette) {
                    const rgba = voxModel.palette[v.c];
                    // Extract RGB, ignore A for hex string
                    const r = (rgba >> 24) & 0xFF;
                    const g = (rgba >> 16) & 0xFF;
                    const b = (rgba >> 8) & 0xFF;
                    colorHex = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
                }

                // Apply offset
                const gx = v.x + offsetX;
                const gy = v.y + offsetY;
                const gz = v.z + offsetZ;

                // Ensure imported voxels are within new GRID bounds
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) {
                    addVoxel(gx, gy, gz, colorHex, true);
                    newVoxels.push({ gx, gy, gz, color: colorHex });
                } else {
                    console.warn(`Voxel at (${v.x}, ${v.y}, ${v.z}) (offsetted to ${gx},${gy},${gz}) is out of new grid bounds [0, ${GRID-1}]. Skipping.`);
                }
            });
            console.log("Total voxels added to scene:", instancedMesh.count);


            updateVoxelGeometry();
            rebuildHelpers();
            resetCameraPosition();
            // updateGroundPlaneSize(); // NEW: Update ground plane size after importing - REMOVED

            addCommand('importVOX', null, null, null, null, null, oldState, newVoxels);
            showMessageModal('Import erfolgreich', 'VOX-Modell erfolgreich importiert!');

        } catch (error) {
            console.error('Error loading VOX file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der VOX-Datei. Stellen Sie sicher, dass es sich um eine gültige MagicaVoxel (.vox) Datei handelt.');
        }
    };
    reader.readAsArrayBuffer(file);
}

// NEW: Generic message modal
function showMessageModal(title, message) {
    const modal = document.getElementById('messageModal');
    document.getElementById('messageModalTitle').textContent = title;
    document.getElementById('messageModalText').textContent = message;
    modal.style.display = 'flex';
}


function generateTerrain() {
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    clearAllInternal(true); // Clear existing voxels without history

    // Re-initialize noise generator with current seed before generating terrain
    noise2D = new ValueNoise2D(terrainSeed);

    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            // Get noise value for this (x,z) coordinate
            // Noise output is typically -1 to 1, scale it to 0 to 1, then to desired height
            const noiseVal = (noise2D.fbm(x, z, terrainOctaves, terrainLacunarity, terrainGain) + 1) * 0.5;
            let terrainHeight = Math.floor(noiseVal * terrainHeightScale);

            // Ensure terrainHeight is at least 1, so there's always a base layer
            terrainHeight = Math.max(1, Math.min(GRID, terrainHeight));

            for (let y = 0; y < terrainHeight; y++) {
                let voxelColor;
                // Placeholder colors - user needs to provide actual ranges
                // Adjusted these thresholds to be relative to the actual terrainHeightScale
                if (y < terrainHeightScale * 0.2) { // Example: Water
                    voxelColor = 0x6495ED; // CornflowerBlue
                } else if (y < terrainHeightScale * 0.6) { // Example: Earth
                    voxelColor = 0x8B4513; // SaddleBrown
                } else { // Example: Grass
                    voxelColor = 0x708237; // OliveDrab
                }
                addVoxel(x, y, z, voxelColor, true); // Add directly to InstancedMesh, true for fromHistory
            }
        }
    }
    // Update InstancedMesh once after all operations
    instancedMesh.instanceMatrix.needsUpdate = true;
    instancedMesh.instanceColor.needsUpdate = true;
    rebuildHelpers(); // Update helpers to new terrain size
    resetCameraPosition(); // Reset camera to view new terrain
    // updateGroundPlaneSize(); // NEW: Update ground plane size after terrain generation - REMOVED

    // Capture the state after terrain generation
    const newState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });
    addCommand('terrainGenerate', null, null, null, null, null, oldState, newState);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    // Ensure Euler angles are also reset to match the new camera orientation for pointer lock
    if (euler) { // Check if euler is defined before using
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
    }
}

// NEW: Function to load image as template
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

// NEW: Handle image file selection
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;

        // Create a temporary image element to get dimensions
        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS; // Make template width match grid width
            const planeHeight = planeWidth / aspectRatio;

            // Dispose old template mesh if it exists
            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight); // Use calculated dimensions

            templateImageMesh = new THREE.Mesh(geometry, material);

            // Position the plane at the back of the grid, centered
            templateImageMesh.position.set(
                (GRID * VS) / 2, // Centered horizontally
                (GRID * VS) / 2, // Centered vertically
                -0.5 * VS // Slightly behind the z=0 grid plane
            );
            templateImageMesh.rotation.y = Math.PI; // Face towards the camera

            templateImageMesh.renderOrder = -1; // Render behind other objects
            scene.add(templateImageMesh);

            // Store template data for persistence
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: templateImageMesh.scale.toArray(),
                locked: false, // Default to unlocked
                // Store the calculated scaled dimensions directly
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            console.log("Saving template image data:", templateImageData); // Debugging

            // Update UI
            document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
            document.getElementById('lockImageTemplateCheckbox').checked = false; // Ensure checkbox is unchecked initially
            toggleLockImageTemplate(false); // Apply unlocked state
        };
        img.src = base64Image;
    };
    reader.readAsDataURL(file);
}

// NEW: Function to remove the image template
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh);
        templateImageMesh.geometry.dispose();
        templateImageMesh.material.dispose();
        templateImageMesh = null;
        templateImageData = null;
        document.getElementById('removeImageTemplateBtn').style.display = 'none';
        document.getElementById('lockImageTemplateCheckbox').checked = false;
        if (!fromLoad) {
            // No history command needed for removal, as it's part of the project state
            // and handled by save/load.
        }
    }
}

// NEW: Function to toggle image template lock
function toggleLockImageTemplate(initialLoad = false) {
    const isLocked = document.getElementById('lockImageTemplateCheckbox').checked;
    if (templateImageData) {
        templateImageData.locked = isLocked;
    }

    if (templateImageMesh) {
        if (isLocked) {
            // Override raycast method to make it non-interactive
            templateImageMesh.raycast = function() {};
        } else {
            // Restore default raycast method
            delete templateImageMesh.raycast;
        }
    }
    if (!initialLoad) {
        // No history command needed for lock state, as it's part of the project state
        // and handled by save/load.
    }
}

// NEW: Function to update the ground plane size based on current GRID
function updateGroundPlaneSize() {
    // Remove the ground plane if it exists
    if (groundPlane) {
        scene.remove(groundPlane);
        groundPlane.geometry.dispose();
        groundPlane.material.dispose();
        groundPlane = null; // Ensure the reference is cleared
    }

    // No longer creating the ground plane
    // If you want to re-add it with different sizing, this is where you would do it.
    // For now, it's removed as per user request.
}


/* ---------- Initialisierung bei Fensterladung ---------- */
window.onload = function() {
    cvs = document.getElementById('voxelCanvas');
    containerDiv = document.getElementById('container'); // Get reference to the container div

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);

    // Camera
    const aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    resetCameraPosition(); // Set initial camera position and look-at
    euler = new THREE.Euler(0, 0, 0, 'YXZ'); // Initialize euler with 'YXZ' order for consistent rotation

    // Renderer
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(window.devicePixelRatio);
    ren.shadowMap.enabled = true; // Enable shadow maps
    ren.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
  
    // Lights
    const ambientLight = new THREE.AmbientLight(0x202020); // Soft white light, slightly reduced
    scene.add(ambientLight);

    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Intensity increased to 1.0
    mainDirectionalLight.position.set(10, 20, 15);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 2048; // Increased for better shadow quality
    mainDirectionalLight.shadow.mapSize.height = 2048;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    mainDirectionalLight.shadow.camera.left = -30; // Adjust shadow camera volume
    mainDirectionalLight.shadow.camera.right = 30;
    mainDirectionalLight.shadow.camera.top = 30;
    mainDirectionalLight.shadow.camera.bottom = -30;
    mainDirectionalLight.shadow.bias = -0.0005; // NEW: Reduce shadow acne
    mainDirectionalLight.shadow.normalBias = 0.02; // NEW: Reduce normal bias artifacts
    scene.add(mainDirectionalLight);

    // NEW: Zweites gerichtetes Licht (Fülllicht)
    fillDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3); // Lower intensity
    fillDirectionalLight.position.set(-10, 10, -15); // From a different angle
    scene.add(fillDirectionalLight);

    // NEW: Hemisphärenlicht
    hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); // Sky color, ground color, intensity
    scene.add(hemisphereLight);

    // NEW: Bodenplatte
    updateGroundPlaneSize(); // Call this here to ensure it's removed on initialization

    // Initialize InstancedMesh
    const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
    // Material should NOT have vertexColors: true if we're using instanceColor attribute
    meshMaterial = new THREE.MeshLambertMaterial(); // Removed vertexColors: true
    
    // Apply shader patch for instance colors with Lambert material
    meshMaterial.onBeforeCompile = (shader) => {
        // Add varying declaration to vertex shader (at the top, before main)
        shader.vertexShader = `
            varying vec3 vInstanceColor; // Declare varying here
            ${shader.vertexShader}
        `.replace(
            'void main() {',
            `
            void main() {
            `
        );

        // Assign instanceColor to vInstanceColor after instanceMatrix is processed
        // The #ifdef USE_INSTANCING_COLOR block already declares 'attribute vec3 instanceColor;'
        shader.vertexShader = shader.vertexShader.replace(
            '#include <color_vertex>', // This is a good place as it's after attributes are set up
            `
            #include <color_vertex>
            #ifdef USE_INSTANCING_COLOR
                vInstanceColor = instanceColor; // Assign instance color to varying
            #else
                vInstanceColor = vec3(1.0); // Default to white if not using instancing color
            #endif
            `
        );

        // Modify fragment shader to use vInstanceColor
        shader.fragmentShader = `
            varying vec3 vInstanceColor; // Declare varying in fragment shader
            ${shader.fragmentShader}
        `.replace(
            'vec4 diffuseColor = vec4( diffuse, opacity );',
            // Multiply material's diffuse color by instance color
            'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
        );
    };

    const initialMaxVoxels = 90 * 90 * 90; 
    instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, initialMaxVoxels);
    
    // Ensure instanceMatrix and instanceColor are properly initialized
    // These should be created by the InstancedMesh constructor, but this adds robustness.
    if (!instancedMesh.instanceMatrix) {
        instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(initialMaxVoxels * 16), 16);
        instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix); // Also link to geometry
    }
    if (!instancedMesh.instanceColor) {
        instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(initialMaxVoxels * 3), 3);
        instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor); // Also link to geometry
    }

    instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
    instancedMesh.castShadow = true;
    instancedMesh.receiveShadow = true;
    scene.add(instancedMesh);
    instancedMesh.count = 0; // Initially no instances

    // NEU: Vorschau-Voxel zur Szene hinzufügen
    scene.add(previewVoxelMesh);
    updatePreviewVoxel(0,0,0,false); // Initial verstecken

    // Helpers
    rebuildHelpers(); // Build initial grid and box helpers

    // Event Listeners
    window.addEventListener('resize', onResize);
    // Use containerDiv for pointer events to allow controls to be clickable
    containerDiv.addEventListener('pointerdown', onPointerDown);
    containerDiv.addEventListener('pointermove', onPointerMove);
    containerDiv.addEventListener('pointerup', onPointerUp);
    containerDiv.addEventListener('pointercancel', onPointerUp); // Treat cancel as up
    containerDiv.addEventListener('pointerleave', onPointerLeave); // NEW: Handle pointer leaving canvas
    containerDiv.addEventListener('wheel', onMouseWheel, { passive: false }); // Prevent default scroll

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    // NEW: Listen for pointer lock changes
    document.addEventListener('pointerlockchange', onPointerLockChange, false);


    // Prevent context menu on right click
    containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

    // UI event listeners
    document.getElementById('grid-size-slider').addEventListener('input', (e) => {
        const oldGrid = GRID; // Capture old GRID size for history
        GRID = parseInt(e.target.value);
        document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        localStorage.setItem('voxelEditorGridSize', GRID);
        console.log("Grid size changed to:", GRID);
        console.log("Saving 'voxelEditorGridSize' to localStorage:", localStorage.getItem('voxelEditorGridSize'));

        // Capture current voxel state before clear for history
        const oldVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        // Clear voxels outside new bounds and update InstancedMesh
        const voxelsToKeep = new Map();
        voxels.forEach((data, k) => {
            const [gx, gy, gz] = parseKey(k);
            if (gx < GRID && gy < GRID && gz < GRID) {
                voxelsToKeep.set(k, data);
            }
        });

        // Rebuild InstancedMesh from scratch with only kept voxels
        voxels.clear(); // Clear the original map
        instancedMesh.count = 0; // Reset instance count

        let newInstanceId = 0;
        voxelsToKeep.forEach((data, k) => {
            const [gx, gy, gz] = parseKey(k);
            
            dummy.position.set(gx * VS + HALF, gy * VS + HALF, gz * VS + HALF);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(newInstanceId, dummy.matrix);

            tempColor.set(data.color);
            instancedMesh.setColorAt(newInstanceId, tempColor);

            voxels.set(k, { color: data.color, instanceId: newInstanceId });
            newInstanceId++;
        });
        instancedMesh.count = newInstanceId;
        instancedMesh.instanceMatrix.needsUpdate = true;
        instancedMesh.instanceColor.needsUpdate = true;


        // Capture new voxel state after resize for history
        const newVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        addCommand('resizeGrid', null, null, null, null, null, oldVoxelState, newVoxelState, { oldGrid: oldGrid, newGrid: GRID });

        rebuildHelpers();
        resetCameraPosition(); // Reset camera to new grid center
        // updateGroundPlaneSize(); // NEW: Update ground plane size after grid resize - REMOVED
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        // Deactivate all presets when custom color is picked
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    });

    // Populate and add listeners for preset color boxes
    presetBoxes = [
        document.getElementById('color-preset-1'),
        document.getElementById('color-preset-2'),
        document.getElementById('color-preset-3')
    ];
    presetColors.forEach((color, index) => {
            const box = presetBoxes[index];
            box.style.backgroundColor = color;
            box.addEventListener('click', (e) => {
                if (e.shiftKey || e.ctrlKey || e.metaKey) { // Allow Shift, Ctrl, or Cmd to save
                    saveCurrentColorToPreset(index);
                } else {
                    setActivePreset(index);
                }
            });
        });
    // Set initial active preset if one was loaded
    if (activePresetIndex !== -1) {
        setActivePreset(activePresetIndex);
    } else {
        // If no preset was active, ensure current color is shown on picker and no preset box is active
        document.getElementById('color-picker').value = currentColor;
    }


    document.getElementById('modeToggle').addEventListener('click', cycleMode); // Use new cycleMode
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`; // Update initial display

    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'flex';
    });
    document.getElementById('saveAndClearBtn').addEventListener('click', () => {
        saveJSON();
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => {
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('cancelClearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'none';
    });

    // NEW: Message Modal Close Button
    document.getElementById('messageModalCloseBtn').addEventListener('click', () => {
        document.getElementById('messageModal').style.display = 'none';
    });


    document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
    document.getElementById('saveBtn').addEventListener('click', saveJSON);
    document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', loadJSON);
    document.getElementById('exportStlBtn').addEventListener('click', exportSTL);
    document.getElementById('importStlBtn').addEventListener('click', () => { // NEW: STL Import Button Listener
        document.getElementById('stlFileInput').click();
    });
    document.getElementById('stlFileInput').addEventListener('change', importSTL); // NEW: STL File Input Listener

    document.getElementById('exportObjBtn').addEventListener('click', exportOBJ); // NEW: OBJ Export Button Listener
    document.getElementById('importObjBtn').addEventListener('click', () => { // NEW: OBJ Import Button Listener
        document.getElementById('objFileInput').click();
    });
    document.getElementById('objFileInput').addEventListener('change', importOBJ); // NEW: OBJ File Input Listener

    document.getElementById('exportVoxBtn').addEventListener('click', exportVOX); // NEW: VOX Export Button Listener
    document.getElementById('importVoxBtn').addEventListener('click', () => { // NEW: VOX Import Button Listener
        document.getElementById('voxFileInput').click();
    });
    document.getElementById('voxFileInput').addEventListener('change', importVOX); // NEW: VOX File Input Listener


    document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
        moveSpeed = parseFloat(e.target.value);
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    });

    // Block Size buttons
    document.getElementById('block-size-1x1').addEventListener('click', () => setBlockSize(1));
    document.getElementById('block-size-4x4').addEventListener('click', () => setBlockSize(4));
    document.getElementById('block-size-8x8').addEventListener('click', () => setBlockSize(8));
    document.getElementById('block-size-10x10').addEventListener('click', () => setBlockSize(10)); // NEW: 10x10 Block Size


    // Info Box (Help) Toggle Logic
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');
    let showInfoBox = localStorage.getItem('showInfoBox') === 'true'; // Default to true if not set

    function updateInfoBoxVisibility() {
        infoBox.style.display = showInfoBox ? 'block' : 'none';
        helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
        localStorage.setItem('showInfoBox', showInfoBox);
    }
    helpToggleBtn.addEventListener('click', () => {
        showInfoBox = !showInfoBox;
        updateInfoBoxVisibility();
    });
    updateInfoBoxVisibility(); // Set initial visibility on load

    // Terrain Controls Toggle Logic
    const terrainControlsPanel = document.getElementById('terrainControlsPanel');
    const toggleTerrainControlsBtn = document.getElementById('toggleTerrainControlsBtn');
    let showTerrainControls = localStorage.getItem('showTerrainControls') === 'true';

    function updateTerrainControlsVisibility() {
        terrainControlsPanel.style.display = showTerrainControls ? 'flex' : 'none';
        toggleTerrainControlsBtn.textContent = showTerrainControls ? 'Gelände-Optionen ausblenden' : 'Gelände-Optionen anzeigen';
        localStorage.setItem('showTerrainControls', showTerrainControls);
    }
    toggleTerrainControlsBtn.addEventListener('click', () => {
        showTerrainControls = !showTerrainControls;
        updateTerrainControlsVisibility();
    });
    updateTerrainControlsVisibility();

    // Terrain parameter input event listeners
    document.getElementById('terrain-height-scale').addEventListener('input', (e) => terrainHeightScale = parseInt(e.target.value));
    document.getElementById('terrain-frequency').addEventListener('input', (e) => terrainFrequency = parseFloat(e.target.value));
    document.getElementById('terrain-octaves').addEventListener('input', (e) => terrainOctaves = parseInt(e.target.value));
    document.getElementById('terrain-lacunarity').addEventListener('input', (e) => terrainLacunarity = parseFloat(e.target.value));
    document.getElementById('terrain-gain').addEventListener('input', (e) => terrainGain = parseFloat(e.target.value));
    document.getElementById('terrain-seed').addEventListener('input', (e) => {
        terrainSeed = e.target.value;
        hasUserTypedSeed = (terrainSeed !== '');
    });

    document.getElementById('generateTerrainBtn').addEventListener('click', generateTerrain);

    // NEW: Add event listener for the "Return to Scene" button
    document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);

    // NEW: Image Template Event Listeners
    document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
    document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
    document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);
    document.getElementById('lockImageTemplateCheckbox').addEventListener('change', toggleLockImageTemplate);


    // Hamburger menu toggle for mobile
    const menuToggle = document.getElementById('menuToggle');
    menuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        if (controlsPanel.style.display === 'none' || controlsPanel.style.display === '') {
            controlsPanel.style.display = 'flex';
        } else {
            controlsPanel.style.display = 'none';
        }
    });

    // Check media query on load and resize
    const mediaQuery = window.matchMedia('(max-width: 768px)');
    function handleMediaQueryChange(e) {
        const controlsPanel = document.getElementById('controls');
        if (e.matches) {
            // Mobile view: hide controls by default, show menu toggle
            controlsPanel.style.display = 'none';
            menuToggle.style.display = 'block';
        } else {
            // Desktop view: show controls by default, hide menu toggle
            controlsPanel.style.display = 'flex';
            menuToggle.style.display = 'none';
        }
    }
    mediaQuery.addListener(handleMediaQueryChange); // Add listener for changes
    handleMediaQueryChange(mediaQuery); // Call once on load

    // Initialisiere noise2D mit dem aktuellen Seed
    noise2D = new ValueNoise2D(terrainSeed);

    // Start animation loop
    animate();
}; // END window.onload

/* ---------- Animations-Loop ---------- */
function animate() {
    requestAnimationFrame(animate);

    // Continuous keyboard movement when pointer is locked (fly mode)
    if (isPointerLocked) {
        const forward = cam.getWorldDirection(new THREE.Vector3());
        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();
        const up = new THREE.Vector3(0, 1, 0); // World up direction

        const currentMoveSpeed = moveSpeed * 5; // Adjust this multiplier for desired feel

        if (keyboard['w']) cam.position.addScaledVector(forward, currentMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(forward, -currentMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(right, -currentMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(right, currentMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(up, -currentMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(up, currentMoveSpeed);
    }

    ren.render(scene, cam);
}

/* ---------- Mouse / Pointer Input ---------- */
let pointerIsDown = false;
let lastX, lastY;
let currentHoveredVoxel = null; // Store {x, y, z} of the voxel currently hovered by the mouse


function onPointerDown(e) {
    if (e.pointerType === 'mouse' && e.button === 2) { // Right-click (mouse only)
        rotate = true;
        // Request pointer lock only on right click down
        cvs.requestPointerLock();
        e.preventDefault(); // Prevent context menu
        return;
    }

    // Only proceed with voxel actions if not in fly mode (pointer not locked)
    if (!isPointerLocked) {
        pointerIsDown = true;
        lastX = e.clientX;
        lastY = e.clientY;
        lastActionVoxelCoords = null; // NEW: Reset last acted-upon voxel on pointer down

        // Store initial position for drag detection (to differentiate click from drag)
        initialClickPos = { x: e.clientX, y: e.clientY };

        // Clear any previous long-press timer
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        isHoldDrawingActive = false; // Reset hold drawing flag

        // Start new long-press timer
        longPressTimer = setTimeout(() => {
            isHoldDrawingActive = true;
        }, LONG_PRESS_DELAY_MS);

        // Reset fixed drag plane parameters
        fixedDragPlaneParams.level = null;
        fixedDragPlaneParams.axis = null;

        if (e.pointerType === 'touch') {
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
            // Initialize prevTouch for single touch camera movement immediately
            if (activePointers.size === 1) {
                prevTouch = { x: e.clientX, y: e.clientY };
            }
            // NEW: Set isMultiTouchGestureActive if two or more fingers are down
            if (activePointers.size >= 2) {
                isMultiTouchGestureActive = true;
            }


            const now = performance.now();
            if (activePointers.size === 1) { // Only check for double tap if it's the first finger down
                if (now - lastTap < DT_MS && tapCandidate && Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH) {
                    dblTapActive = true;
                    isDblTapDragActive = true; // Activate double-tap-drag mode
                    activeGestureMode = 'dblTapDragDraw';
                    // Set fixed plane for dblTapDrag based on hit or current drawing level
                    setFixedDragPlane(e.clientX, e.clientY, currentMode);
                } else {
                    dblTapActive = false;
                    isDblTapDragActive = false;
                    activeGestureMode = 'singleTouchCamera'; // Assume single touch is for camera initially
                    tapCandidate = { x: e.clientX, y: e.clientY, time: now };
                }
            } else if (activePointers.size > 1) {
                // If a second finger comes down, it's a multi-touch camera gesture
                activeGestureMode = 'multiTouchCamera';
                dblTapActive = false; // Cancel any pending double tap
                isDblTapDragActive = false;
            }
            // handleGesture() is now called at the beginning of onPointerMove for touch
            // to ensure gesture state is updated before drawing logic.
        } else { // Mouse
            // Determine fixed drawing plane for Shift-drag OR normal drag (if not stacking)
            const isShiftOrNormalDrag = (shiftActive() || isDblTapDragActive) || (e.buttons === 1 && !e.ctrlKey);
            if (isShiftOrNormalDrag) {
                setFixedDragPlane(e.clientX, e.clientY, currentMode);
            }
        }
    }
}

function onPointerMove(e) {
    // Handle camera movement first, especially for pointer lock and multi-touch gestures
    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        handleGesture(); // This handles camera movement (pan/pinch) and dblTapDrag drawing

        // If in a camera gesture mode, hide preview and prevent drawing
        if (activeGestureMode === 'singleTouchCamera' || activeGestureMode === 'multiTouchCamera') {
            updatePreviewVoxel(0, 0, 0, false); // Hide preview during camera gestures
            return; // Exit early, no drawing during camera gestures
        }
    } else if (isPointerLocked) { // Mouse right-click rotation (Unreal Engine style)
        // Ignore the very first movement event after pointer lock to prevent initial jump
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            return;
        }

        const dx = e.movementX || 0;
        const dy = e.movementY || 0;

        // Rotation
        euler.y -= dx * rotSpeed; // Invert X-axis rotation for more intuitive feel
        euler.x -= dy * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); // Clamp vertical rotation
        cam.quaternion.setFromEuler(euler);
        return; // Exit early, no drawing during fly mode
    }

    // This part now only executes if not in pointer-locked mode (desktop right-click)
    // AND not in an active multi-touch camera gesture (for mobile)
    // AND not in a single-finger touch camera look mode (for mobile)
    // AND not in a double-tap-drag drawing mode (which is handled by handleGesture)

    const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, pointerIsDown, isControlDragging);

    // Update preview voxel for single-voxel modes, hide if drawing rectangle or in fly mode
    if (currentTargetVoxel && !isPointerLocked) {
        updatePreviewVoxel(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, true);
    } else {
        updatePreviewVoxel(0, 0, 0, false); // Hide single preview
    }

    // Only draw if pointer is down AND it's a drag (or special drag mode)
    // This ensures single clicks don't draw immediately on pointer down + move
    if (pointerIsDown) {
        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const isActualDrag = movedDistance > MOVE_PX;

        // Only proceed with drawing if it's an actual drag, or a hold-drawing, or a double-tap-drag
        if (isActualDrag || isHoldDrawingActive || activeGestureMode === 'dblTapDragDraw') {
            if (currentTargetVoxel) {
                // This condition now checks for ANY line drawing mode (Shift, Ctrl, DblTap, or the new normal drag fixed plane)
                // The fixedDragPlaneParams.level !== null check ensures we are in a fixed-plane drag mode
                if (shiftActive() || isControlDragging || activeGestureMode === 'dblTapDragDraw' || (fixedDragPlaneParams.level !== null && fixedDragPlaneParams.axis !== null)) {
                    if (!lastActionVoxelCoords ||
                        lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                        lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                        lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                        if (lastActionVoxelCoords) {
                            drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor, currentBlockSize);
                        } else {
                            performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
                        }
                        lastActionVoxelCoords = { ...currentTargetVoxel };
                    }
                } else { // Normal drag for DELETE or DRAW modes, or ADD mode if not on a fixed plane
                    if (!lastActionVoxelCoords ||
                        lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                        lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                        lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                        performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
                        lastActionVoxelCoords = { ...currentTargetVoxel };
                    }
                }
            }
        }
    }
}

function onPointerUp(e) {
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
    isHoldDrawingActive = false;

    let wasMultiTouchGesture = isMultiTouchGestureActive; // Capture state before releasing pointer

    if (e.pointerType === 'mouse') {
        if (e.button === 2) { // Right-click up
            rotate = false;
            document.exitPointerLock();
            return; // No further action for mouse right-click
        }

        // Mouse Left Click Up: Handle single click or end of drag
        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleClick = movedDistance <= MOVE_PX;

        if (pointerIsDown && !isPointerLocked) {
            if (wasSingleClick) { // Single click for other modes
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false);
                if (clickedVoxel) {
                    performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, currentMode, currentColor, currentBlockSize);
                }
            }
        }
        pointerIsDown = false; // Reset pointer down state for mouse
        lastTap = performance.now(); // Update lastTap for mouse
    } else if (e.pointerType === 'touch') {
        // Touch Up: Determine if it was a single tap or end of a drag/gesture
        releasePointer(e.pointerId); // Remove pointer from active list

        // Only process if no other active pointers (i.e., not part of a multi-touch gesture)
        // and it was a single tap (not a drag)
        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleTap = movedDistance <= TAP_DIST_TH; // Use TAP_DIST_TH for touch tap threshold

        if (!isPointerLocked && activePointers.size === 0) { // Ensure not in fly mode and all fingers are lifted
            // NEW: Prevent single tap cube placement if a multi-touch gesture was active
            if (wasSingleTap && !dblTapActive && !dblTapDrag && !wasMultiTouchGesture) {
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false);
                if (clickedVoxel) {
                    performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, currentMode, currentColor, currentBlockSize);
                }
            }
        }
    }

    // Common resets for both mouse and touch (after specific handling)
    updatePreviewVoxel(0, 0, 0, false);
    isControlDragging = false;
    isShiftDragging = false;
    dblTapDrag = false;
    isDblTapDragActive = false;
    activeGestureMode = 'none'; // Reset active gesture mode
    lastActionVoxelCoords = null;
    initialClickPos = null;
    isMultiTouchGestureActive = false; // NEW: Reset multi-touch gesture flag

    // Reset fixed drag plane parameters
    fixedDragPlaneParams.level = null;
    fixedDragPlaneParams.axis = null;
}

// NEW: Function to handle pointer leaving the canvas
function onPointerLeave(e) {
    // Only reset if it's a mouse pointer (touch pointers might leave briefly during gestures)
    if (e.pointerType === 'mouse') {
        pointerIsDown = false; // Crucial: Stop drawing when mouse leaves
        lastActionVoxelCoords = null;
        updatePreviewVoxel(0, 0, 0, false); // Hide preview voxel
    }
}

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true; // Reset flag to ignore first movement after lock
        // When pointer is locked, hide the preview voxel
        updatePreviewVoxel(0,0,0,false);

        // NEU: Synchronisiere Euler-Winkel mit der aktuellen Kameraausrichtung bei Zeigerfixierung
        euler.setFromQuaternion(cam.quaternion, 'YXZ');

    } else {
        isPointerLocked = false;
        rotate = false; // Ensure rotate is false if pointer lock is lost
    }
}

function onMouseWheel(e) {
    e.preventDefault(); // Prevent page scrolling

    const sensitivity = 0.005; // Adjust as needed for desired speed
    let zoomAmount = e.deltaY * sensitivity;

    if (e.altKey) {
        // Alt + Scroll for activeDrawingLevel on Y-axis
        if (e.shiftKey) { // Alt + Shift + Scroll for Z-axis
            activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
            currentDrawingAxis = 'z';
        } else if (e.ctrlKey) { // Alt + Ctrl + Scroll for X-axis
            activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
            currentDrawingAxis = 'x';
        } else { // Alt + Scroll for Y-axis
            activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
            currentDrawingAxis = 'y';
        }
        updateGridHelperPosition(); // Rebuild grid helper to reflect new level/axis
    } else {
        // NEW: Adjust fly speed with mouse wheel when not holding Alt
        const speedChange = -Math.sign(e.deltaY) * 0.01; // Adjust speed by 0.01 per scroll tick
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed + speedChange)); // Clamp speed to new max 1.0
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

        // Existing regular scroll for camera zoom (moving along camera's look direction)
        cam.position.addScaledVector(
            cam.getWorldDirection(new THREE.Vector3()),
            zoomAmount * moveSpeed * 5 // Faster zoom for mouse wheel
        );
    }
}

// Helper to get a point on a specific fixed plane
function getPointOnFixedPlane(clientX, clientY, axis, level) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    let planeNormal = new THREE.Vector3();
    if (axis === 'y') planeNormal.set(0, 1, 0);
    else if (axis === 'x') planeNormal.set(1, 0, 0);
    else if (axis === 'z') planeNormal.set(0, 0, 1);
    const drawingPlane = new THREE.Plane(planeNormal, -(level * VS));

    const intersectionPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

    if (intersectionPoint) {
        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        // Force the coordinate on the fixed axis to be the fixed level
        if (axis === 'y') gy = level;
        else if (axis === 'x') gx = level;
        else if (axis === 'z') gz = level;

        // Clamp coordinates to grid boundaries
        gx = Math.max(0, Math.min(GRID - 1, gx));
        gy = Math.max(0, Math.min(GRID - 1, gy));
        gz = Math.max(0, Math.min(GRID - 1, gz));

        return { gx, gy, gz };
    }
    return null;
}

// Function to set the current block size
function setBlockSize(size) {
    currentBlockSize = size;
    // Update active class for buttons
    document.querySelectorAll('.block-size-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`block-size-${size}x${size}`).classList.add('active');
    // Trigger a preview update if the mouse is currently over the canvas
    const rect = cvs.getBoundingClientRect();
    const mouseX = lastX - rect.left;
    const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: lastX,
            clientY: lastY,
            buttons: pointerIsDown ? 1 : 0
        });
        onPointerMove(mouseEvent);
    } else {
        updatePreviewVoxel(0,0,0,false); // Hide if mouse is outside
    }
}


/* ---------- Keyboard Input ---------- */
const keyboard = {};
function onKeyDown(e) {
    keyboard[e.key] = true;

    // Modifier keys for dragging (Shift and Control)
    if (e.key === 'Shift') {
        isShiftDragging = true;
    }
    if (e.key === 'Control' || e.key === 'Meta') { // Meta for Mac Command key
        isControlDragging = true;
    }

    // Undo/Redo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { // Ctrl+Z or Cmd+Z
        e.preventDefault(); // Prevent browser undo
        undo();
    }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { // Ctrl+Y or Cmd+Y, or Ctrl+Shift+Z / Cmd+Shift+Z
        e.preventDefault(); // Prevent browser redo
        redo();
    }

    // Other Shortcuts
    switch (e.key) {
        case 'Tab':
            e.preventDefault(); // Prevent tabbing through elements
            cycleMode();
            break; // Text content updated in cycleMode function
        case '1': setActivePreset(0); break;
        case '2': setActivePreset(1); break;
        case '3': setActivePreset(2); break;
    }
}

function onKeyUp(e) {
    keyboard[e.key] = false;

    if (e.key === 'Shift') {
        isShiftDragging = false;
    }
    if (e.key === 'Control' || e.key === 'Meta') {
        isControlDragging = false;
    }
}
</script>
</body>
</html>
