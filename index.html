<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>
<style>
/* CSS f√ºr den Body mit Safe-Area-Anpassungen */
body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;

    /* --- WICHTIG: ANPASSUNGEN F√úR SICHERE BEREICHE --- */
    /* Verschiebt den Inhalt nach unten, um Platz f√ºr die Statusleiste/Notch zu schaffen */
    padding-top: env(safe-area-inset-top);
    /* F√ºgt Polsterung f√ºr den unteren Bereich hinzu (z.B. f√ºr Home-Indikatoren auf iPhones) */
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Entscheidend: Stellt sicher, dass das Padding in der 100vh H√∂he enthalten ist */
    box-sizing: border-box;
    /* NEW: Prevent full page zoom on mobile */
    touch-action: pan-x pan-y;
    /* NEW: Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}

/* verhindert, dass das OS den Canvas als Text selektiert */
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;    /* iOS Kontextmen√º */
}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode{
    font-weight:700;
    color:#81c784;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
    /* Prevent accidental zooming */
    touch-action: none;
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box;
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    /* Removed display: none; from here to allow desktop visibility */
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
/* NEW: Apply to input[type="color"] as well */
.color-preset-box, input[type="color"].color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    /* Ensure input type color specific styles are overridden for rectangular shape */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0;
}

input[type="color"].color-preset-box::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"].color-preset-box::-webkit-color-swatch {
    border: none; /* Remove inner border from default swatch */
    border-radius: 3px; /* Slightly smaller radius than outer for visual effect */
}
input[type="color"].color-preset-box::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"].color-preset-box::-moz-color-swatch {
    border: none;
    border-radius: 3px;
}


.color-preset-box:hover, input[type="color"].color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active, input[type="color"].color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Modal Styles (kept for critical confirmations like Clear All) */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* ---------------------------------------------------
    HAMBURGER-BUTTON
    --------------------------------------------------- */
#menuToggle{
    position: fixed;
    top: calc(10px + env(safe-area-inset-top));
    right: 10px;
    z-index: 1500;
    width: 42px; height: 42px;
    font-size: 1.4em;
    line-height: 42px;
    text-align: center;
    background:#555c66;
    color:#e0e0e0;
    border:none;
    border-radius:8px;
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.4);
}
#menuToggle:hover{background:#6a727f}

/* ---------------------------------------------------
    Responsive-Regel: Auf Viewports ‚â§ 768 px wird
    das Bedienfeld anfangs versteckt.
    --------------------------------------------------- */
@media (max-width:768px){
    #controls{display:none;}
    /* Mobile button sizing */
    button {
        min-width: 44px;
        min-height: 44px; /* Meet touch target guidelines */
    }
}
/* Canvas & Container: KEINE default-Gesten */
#container,
#voxelCanvas{
    touch-action: none;
    -ms-touch-action: none;

    /* ‚Üê neu: sorge daf√ºr, dass die CSS-Border innen sitzt */
           box-sizing: border-box;
}

/* NEW: Accessibility - Screen Reader Only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

/* NEW: Touch Indicator */
.touch-indicator {
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(0, 150, 255, 0.3);
    transform: translate(-50%, -50%);
    pointer-events: none;
    animation: pulse 0.5s;
    display: none; /* Hidden by default */
    z-index: 2000; /* Ensure it's on top */
}


@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}

/* NEW: Mobile-specific controls */
.mobile-only {
    display: none; /* Hidden by default */
    position: absolute;
    bottom: calc(20px + env(safe-area-inset-bottom)); /* Adjust for safe area */
    right: calc(20px + env(safe-area-inset-right)); /* Adjust for safe area */
    flex-direction: column;
    gap: 12px;
    z-index: 1000;
}

@media (max-width: 768px) {
    .mobile-only {
        display: flex; /* Show on mobile */
    }
    
    .mobile-btn {
        width: 60px;
        height: 60px;
        font-size: 24px;
        border-radius: 50%;
        background: rgba(90, 90, 120, 0.8);
        color: white;
        border: 2px solid white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(0,0,0,.4);
    }
    .mobile-btn:hover {
        background: rgba(110, 110, 140, 0.9);
    }
}

/* NEW: Distance Display Style */
#distanceDisplay {
    position: absolute;
    bottom: 18px;
    right: 18px;
    padding: 8px 12px;
    background: rgba(0,0,0,0.6);
    color: #e0e0e0;
    border-radius: 5px;
    font-size: 0.9em;
    display: none; /* Hidden by default, shown on drag */
    z-index: 900; /* Below modals, above canvas */
}

/* Style for dynamic block size inputs */
.dynamic-block-input {
    width: 60px; /* Smaller width for number inputs */
    padding: 8px;
    border: none;
    border-radius: 5px;
    font-size: 1em;
    background: #555c66;
    color: #e0e0e0;
    text-align: center;
    -moz-appearance: textfield; /* Remove Firefox spinner */
}

/* Hide number input arrows for Chrome, Safari, Edge, Opera */
.dynamic-block-input::-webkit-outer-spin-button,
.dynamic-block-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

.dynamic-block-input-group {
    display: flex;
    align-items: center;
    gap: 5px;
}

.block-size-btn.active, #setDynamicBlockSizeBtn.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* NEW: Upload Modal Specific Styles */
.upload-modal-content {
    background-color: #3a3f47;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 500px;
    width: 90%;
    color: #e0e0e0;
    text-align: left; /* Align text left for form fields */
}

.upload-modal-content h3 {
    text-align: center;
    margin-top: 0;
    color: #90caf9;
    margin-bottom: 20px;
}

.upload-modal-content label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
}

.upload-modal-content input[type="text"],
.upload-modal-content textarea {
    width: calc(100% - 20px); /* Adjust for padding */
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #555c66;
    border-radius: 5px;
    background-color: #2d3748;
    color: #e0e0e0;
    box-sizing: border-box; /* Include padding in width */
}

.upload-modal-content textarea {
    resize: vertical;
    min-height: 80px;
}

.upload-modal-content .radio-group {
    display: flex;
    gap: 20px;
    margin-bottom: 15px;
}

.upload-modal-content .radio-group label {
    display: flex;
    align-items: center;
    font-weight: normal;
}

.upload-modal-content .radio-group input[type="radio"] {
    margin-right: 8px;
}

.upload-modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.upload-modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.upload-modal-buttons button.upload-confirm {
    background-color: #4CAF50; /* Green */
    color: white;
}

.upload-modal-buttons button.upload-cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.upload-modal-buttons button:hover {
    opacity: 0.9;
}

#loginLogoutBtn {
    background-color: #007bff; /* Blue for login/logout */
    color: white;
}
#loginLogoutBtn:hover {
    background-color: #0056b3;
}

#uploadToHubBtn {
    background-color: #ff9800; /* Orange for upload */
    color: white;
}
#uploadToHubBtn:hover {
    background-color: #fb8c00;
}

#userIdDisplay {
    font-weight: bold;
    color: #ADD8E6; /* Light blue */
    margin-left: 10px;
    margin-right: 10px;
    white-space: nowrap; /* Prevent wrapping */
    overflow: hidden; /* Hide overflow */
    text-overflow: ellipsis; /* Show ellipsis for overflow */
    max-width: 150px; /* Limit width */
}

/* NEW: Toast Message Styles */
#toast-container {
    position: fixed;
    top: calc(20px + env(safe-area-inset-top));
    left: 50%;
    transform: translateX(-50%);
    z-index: 2000; /* Above modals */
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: none; /* Allow clicks to pass through to elements below */
    width: 90%;
    max-width: 400px;
}

.toast-message {
    background-color: #3a3f47;
    color: #e0e0e0;
    padding: 15px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(-20px);
    pointer-events: auto; /* Re-enable clicks for the toast itself */
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.toast-message.show {
    opacity: 1;
    transform: translateY(0);
}

.toast-message .close-btn {
    background: none;
    border: none;
    color: #e0e0e0;
    font-size: 1.2em;
    cursor: pointer;
    margin-left: 10px;
}

.toast-message.info { background-color: #3f51b5; } /* Indigo */
.toast-message.success { background-color: #4CAF50; } /* Green */
.toast-message.error { background-color: #f44336; } /* Red */
.toast-message.warning { background-color: #ff9800; } /* Orange */

/* NEW: Auth Modal Styles */
.auth-modal-content {
    background-color: #3a3f47;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 450px;
    width: 90%;
    color: #e0e0e0;
    text-align: center;
}

.auth-modal-content h3 {
    margin-top: 0;
    color: #90caf9;
    margin-bottom: 20px;
}

.auth-modal-content .provider-buttons button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    padding: 12px;
    margin-bottom: 10px;
    border: none;
    border-radius: 5px;
    font-size: 1.1em;
    cursor: pointer;
    gap: 10px;
}

.auth-modal-content .provider-buttons button.google {
    background-color: #DB4437; /* Google Red */
    color: white;
}
.auth-modal-content .provider-buttons button.github {
    background-color: #333; /* GitHub Dark */
    color: white;
}
.auth-modal-content .provider-buttons button.email {
    background-color: #4285F4; /* Email Blue (similar to Google) */
    color: white;
}

.auth-modal-content .provider-buttons button:hover {
    opacity: 0.9;
}

.auth-modal-content .email-login-form {
    margin-top: 20px;
    border-top: 1px solid #555c66;
    padding-top: 20px;
}

.auth-modal-content .email-login-form input[type="email"],
.auth-modal-content .email-login-form input[type="password"] {
    width: calc(100% - 20px);
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #555c66;
    border-radius: 5px;
    background-color: #2d3748;
    color: #e0e0e0;
    box-sizing: border-box;
}

.auth-modal-content .email-login-form button {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 5px;
    background-color: #007bff;
    color: white;
    font-size: 1em;
    cursor: pointer;
}
.auth-modal-content .email-login-form button:hover {
    background-color: #0056b3;
}

.auth-modal-content .close-button-container {
    margin-top: 20px;
}

.auth-modal-content .close-button-container button {
    background-color: #555c66;
    color: #e0e0e0;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
.auth-modal-content .close-button-container button:hover {
    opacity: 0.9;
}

</style>
</head>
<body>
<button id="menuToggle" aria-label="Men√º umschalten">‚ò∞</button>

<div id="controls">
    <label for="grid-size-slider">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergr√∂√üe anpassen">
    <span id="grid-size-display">10√ó10√ó10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe w√§hlen">
    <!-- NEW: Preset color inputs are now type="color" -->
    <input type="color" id="color-preset-1" class="color-preset-box" value="#8B4513" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box" value="#708237" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box" value="#6495ED" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln">Modus wechseln</button><span id="current-mode">Modus: Hinzuf√ºgen</span>
    <button id="clearBtn" aria-label="Alles l√∂schen">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export">OBJ Export</button>

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen">
    <span id="fly-speed-display">0.10</span>

    <label>Feste Blockgr√∂√üe:</label>
    <button id="block-size-1x1" class="block-size-btn active" aria-label="Blockgr√∂√üe 1x1x1">1x1x1</button>
    <button id="block-size-4x4" class="block-size-btn" aria-label="Blockgr√∂√üe 4x4x4">4x4x4</button>
    <button id="block-size-8x8" class="block-size-btn" aria-label="Blockgr√∂√üe 8x8x8">8x8x8</button>
    <button id="block-size-10x10" class="block-size-btn" aria-label="Blockgr√∂√üe 10x10x10">10x10x10</button>

    <label>Dynamische Blockgr√∂√üe:</label>
    <div class="dynamic-block-input-group">
        <input type="number" id="dynamic-block-x" class="dynamic-block-input" value="1" min="1" max="180" aria-label="Dynamische Blockbreite (X)">
        <span>x</span>
        <input type="number" id="dynamic-block-y" class="dynamic-block-input" value="1" min="1" max="180" aria-label="Dynamische Blockh√∂he (Y)">
        <span>x</span>
        <input type="number" id="dynamic-block-z" class="dynamic-block-input" value="1" min="1" max="180" aria-label="Dynamische Blocktiefe (Z)">
    </div>
    <button id="setDynamicBlockSizeBtn" aria-label="Dynamische Gr√∂√üe festlegen">Gr√∂√üe festlegen</button>

    <button id="measureDistanceBtn" aria-label="Abstand messen">Abstand messen</button>

    <button id="helpToggleBtn" aria-label="Hilfe umschalten">Hilfe</button>
    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen">Zur Szene zur√ºckkehren</button>

    <!-- Image Template Controls -->
    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" style="display:none;" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" style="display:none;">

    <!-- NEW: Login/Logout and Upload to Hub Buttons -->
    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden">Anmelden</button>
    <span id="userIdDisplay"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" style="display:none;">Auf Hub hochladen</button>
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus ‚Üí Kamera drehen (Fly Mode)<br>
    WASD / E / Q ‚Üí bewegen<br>
    Linke MT ‚Üí Voxel hinzuf./l√∂schen/zeichnen<br>
    **Alt + Mausrad ‚Üí Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad ‚Üí Zeicheneben Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad ‚Üí Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel Aktion auf aktiver Ebene (Hinzuf√ºgen / L√∂schen / Zeichnen)**<br>
    **Control + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel ziehen zum Hinzuf√ºgen (Stapeln, nur im Hinzuf√ºgen-Modus)**<br>
    **NEU: Linien zeichnen (Modus "Hinzuf√ºgen", "L√∂schen", "Zeichnen")**<br>
    **Linke MT gedr√ºckt + Maus ziehen ‚Üí Linie von Voxeln zeichnen**<br>
    Mausrad ‚Üí Kamera Geschwindigkeit anpassen<<br>
    **Tab ‚Üí Modus wechseln (Hinzuf√ºgen / L√∂schen / Zeichnen / Messen)**<br>
    **1, 2, 3 ‚Üí Voreingestellte Farbe w√§hlen**<<br>
    **Strg + Z ‚Üí R√ºckg√§ngig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z ‚Üí Wiederholen (Redo)**<br>
    **NEU: Abstand messen (Modus "Messen")**<<br>
    **Linke MT ‚Üí Erster Klick setzt Startpunkt, Zweiter Klick setzt Endpunkt und zeigt Distanz**
    </div>
    <div id="touch-indicator" class="touch-indicator"></div>
    <input type="file" id="fileInput" accept=".json">
    <div id="distanceDisplay">Distanz: 0.00 mm</div>
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt l√∂schen</h3>
        <p>M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<!-- NEW: Upload Project Modal -->
<div id="uploadProjectModal" class="modal">
    <div class="upload-modal-content">
        <h3>Projekt auf Hub hochladen</h3>
        <label for="uploadTitle">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekr√§ftiger Titel f√ºr Ihr Projekt" maxlength="100">

        <label for="uploadDescription">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500"></textarea>

        <label for="uploadTags">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Geb√§ude" maxlength="100">

        <label>Sichtbarkeit:</label>
        <div class="radio-group">
            <label>
                <input type="radio" name="uploadVisibility" value="public" checked> √ñffentlich
            </label>
            <label>
                <input type="radio" name="uploadVisibility" value="private"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons">
            <button id="uploadConfirmBtn" class="upload-confirm">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel">Abbrechen</button>
        </div>
    </div>
</div>

<!-- NEW: Auth Modal -->
<div id="authModal" class="modal">
    <div class="auth-modal-content">
        <h3>Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons">
            <button id="signInGoogleBtn" class="google">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" style="width:20px; height:20px;">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" style="width:20px; height:20px;">
                Mit GitHub anmelden
            </button>
            <!-- Email/Password form can be toggled or shown directly -->
            <button id="showEmailLoginFormBtn" class="email">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form" style="display:none;">
            <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email">
            <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password">
            <button id="emailSignInBtn">Anmelden</button>
            <button id="emailSignUpBtn" style="margin-top: 10px;">Registrieren</button>
        </div>

        <div class="close-button-container">
            <button id="authModalCloseBtn">Schlie√üen</button>
        </div>
    </div>
</div>


<!-- NEW: Toast Container -->
<div id="toast-container"></div>


<!-- NEW: Mobile controls -->
<div id="mobile-controls" class="mobile-only">
    <button class="mobile-btn" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera wechseln">üì∑</button>
    <!-- Removed mobile-extrude-mode button -->
    <button class="mobile-btn" id="mobile-assist" aria-label="Touch-Assist umschalten">üß≤</button>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<!-- Firebase SDK imports -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut,
             GoogleAuthProvider, GithubAuthProvider, signInWithPopup,
             createUserWithEmailAndPassword, signInWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Expose Firebase functions to the global scope for use in the main script
    window.firebase = {
        initializeApp,
        getAuth,
        signInAnonymously,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    // Firebase configuration from hub.html
    const firebaseConfig = {
        apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA",
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJ5CNKZ5DR"
    };

    // Expose firebaseConfig to the global scope
    window.firebaseConfig = firebaseConfig;
</script>

<!-- VoxelShaperIO Library (embedded) -->
<script>
var VoxelShaperIO = (function() {
    // Helper to convert hex to RGBA for VOX palette
    function hexToRgba(hex) {
        if (!hex || hex.length !== 7) return 0x00000000; // Default to transparent black
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return (r << 24) | (g << 16) | (b << 8) | 0xFF; // RGBA
    }

    // Helper to convert RGBA to hex
    function rgbaToHex(rgba) {
        const r = (rgba >>> 24) & 0xFF;
        const g = (rgba >>> 16) & 0xFF;
        const b = (rgba >>> 8) & 0xFF;
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
    }

    class VoxModel {
        constructor(sizeX, sizeY, sizeZ, voxels = [], palette = new Uint32Array(256)) {
            this.sizeX = sizeX;
            this.sizeY = sizeY;
            this.sizeZ = sizeZ;
            this.voxels = voxels; // Array of {x, y, z, c} where c is palette index
            this.palette = palette; // Uint32Array of RGBA colors
            // Initialize default palette if not provided
            if (this.palette.every(val => val === 0)) {
                this.palette[1] = hexToRgba("#FF0000"); // Red
                this.palette[2] = hexToRgba("#00FF00"); // Green
                this.palette[3] = hexToRgba("#0000FF"); // Blue
                // ... add more default colors as needed
            }
        }
    }

    // Basic OBJ exporter (simplified, no materials)
    function voxToOBJ(voxModel, cubeSize = 1) {
        let obj = `# VoxelShaper OBJ Export\n`;
        let vertexCount = 0;

        voxModel.voxels.forEach(v => {
            const x = v.x * cubeSize;
            const y = v.y * cubeSize;
            const z = v.z * cubeSize;

            // Vertices for a cube
            obj += `v ${x} ${y} ${z}\n`;
            obj += `v ${x + cubeSize} ${y} ${z}\n`;
            obj += `v ${x + cubeSize} ${y + cubeSize} ${z}\n`;
            obj += `v ${x} ${y + cubeSize} ${z}\n`;
            obj += `v ${x} ${y} ${z + cubeSize}\n`;
            obj += `v ${x + cubeSize} ${y} ${z + cubeSize}\n`;
            obj += `v ${x + cubeSize} ${y + cubeSize} ${z + cubeSize}\n`;
            obj += `v ${x} ${y + cubeSize} ${z + cubeSize}\n`;

            // Faces (simplified, assuming no normals/texture coords for now)
            // Front face
            obj += `f ${vertexCount + 1} ${vertexCount + 2} ${vertexCount + 3} ${vertexCount + 4}\n`;
            // Back face
            obj += `f ${vertexCount + 5} ${vertexCount + 8} ${vertexCount + 7} ${vertexCount + 6}\n`;
            // Top face
            obj += `f ${vertexCount + 4} ${vertexCount + 3} ${vertexCount + 7} ${vertexCount + 8}\n`;
            // Bottom face
            obj += `f ${vertexCount + 1} ${vertexCount + 5} ${vertexCount + 6} ${vertexCount + 2}\n`;
            // Right face
            obj += `f ${vertexCount + 2} ${vertexCount + 6} ${vertexCount + 7} ${vertexCount + 3}\n`;
            // Left face
            obj += `f ${vertexCount + 5} ${vertexCount + 1} ${vertexCount + 4} ${vertexCount + 8}\n`;

            vertexCount += 8;
        });
        return obj;
    }

    // Helper for writing binary data
    class DataViewWriter {
        constructor(initialCapacity = 1024) {
            this.buffer = new ArrayBuffer(initialCapacity);
            this.dataView = new DataView(this.buffer);
            this.position = 0;
        }

        _ensureCapacity(bytesNeeded) {
            if (this.position + bytesNeeded > this.buffer.byteLength) {
                const newCapacity = Math.max(this.buffer.byteLength * 2, this.position + bytesNeeded);
                const newBuffer = new ArrayBuffer(newCapacity);
                new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
                this.buffer = newBuffer;
                this.dataView = new DataView(this.buffer);
            }
        }

        writeString(str) {
            this._ensureCapacity(str.length);
            for (let i = 0; i < str.length; i++) {
                this.dataView.setUint8(this.position++, str.charCodeAt(i));
            }
        }

        writeInt32(value) {
            this._ensureCapacity(4);
            this.dataView.setInt32(this.position, value, true); // Little-endian
            this.position += 4;
        }

        writeUint32(value) {
            this._ensureCapacity(4);
            this.dataView.setUint32(this.position, value, true); // Little-endian
            this.position += 4;
        }

        writeUint8(value) {
            this._ensureCapacity(1);
            this.dataView.setUint8(this.position++, value);
        }

        getBuffer() {
            return this.buffer.slice(0, this.position);
        }
    }

    // Helper for reading binary data
    class DataViewReader {
        constructor(arrayBuffer) {
            this.buffer = arrayBuffer;
            this.dataView = new DataView(arrayBuffer);
            this.position = 0;
        }

        readString(length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(this.dataView.getUint8(this.position++));
            }
            return str;
        }

        readInt32() {
            const value = this.dataView.getInt32(this.position, true); // Little-endian
            this.position += 4;
            return value;
        }

        readUint32() {
            const value = this.dataView.getUint32(this.position, true); // Little-endian
            this.position += 4;
            return value;
        }

        readUint8() {
            return this.dataView.getUint8(this.position++);
        }
    }

    function saveBlob(data, filename) {
        const blob = new Blob([data], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    return {
        VoxModel,
        voxToOBJ,
        saveBlob,
        rgbaToHex // Export rgbaToHex for debugging
    };
})();
</script>


<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;
const CHUNK_SIZE = 16; // Each chunk is CHUNK_SIZE x CHUNK_SIZE x CHUNK_SIZE voxels

/* ==============================================================
   FAST NUMERIC VOXEL-KEY  (max. GRID 0-1023 in jeder Achse)
   --------------------------------------------------------------
   ‚Äì 30-Bit-Packing:  x<<20 | y<<10 | z
   ‚Äì 100 % kollisionsfrei, >10√ó schneller als String-Hash,
     0 % GC-Druck
   ============================================================== */
// 10 Bit pro Achse  ‚Üí  0 ‚Ä¶ 1023
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;   // 0x3FF
const SHIFT_X  = VOX_BITS * 2;          // 20
const SHIFT_Y  = VOX_BITS;              // 10
// SHIFT_Z = 0

/**
 * Kombiniert (x,y,z) zu einem einzigen 30-Bit-Integer-Key.
 * - Alle Koordinaten m√ºssen 0 ‚â§ coord ‚â§ 1023 sein.
 */
function key(x, y, z) {
    // >>> 0 zwingt in den 32-Bit-Integer-Bereich
    return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0;
}

/**
 * Invers zu `key()` ‚Äì liefert [x, y, z].
 */
function parseKey(k) {
    return [
        (k >>> SHIFT_X) & VOX_MASK,
        (k >>> SHIFT_Y) & VOX_MASK,
        k & VOX_MASK
    ];
}

/* ---------- globale Variablen ---------- */
let isHoldDrawingActive = false;   // NEW: Verfolgt, ob ein Long-Press-Zeichnen aktiv ist
const LONG_PRESS_DELAY_MS = 500;   // NEW: Wartezeit (in Millisekunden) f√ºr Long-Press-Erkennung
const VOXEL_DRAG_THRESHOLD = 2; // NEW: Voxel-based threshold for axis locking during drag (Increased from 0.5)

/* ----------------------------------------------
   GLOBAL ‚Äì neue Hilfs-Variablen
---------------------------------------------- */
// --- Touch Gesture Constants ---
const PINCH_ZOOM_MULT = 40;     // Zoom-Geschwindigkeit ‚Üë
const TAP_DIST_TH = 10;         // max. Bewegung (px) f√ºr 'Tap'
const MOVE_PX = 10;             // ab hier gilt es als Drag
const DT_MS = 250;              // max. Abstand Taps (ms)
const PAN_PIX_TH = 10;          // ab px Bewegung ‚Üí Pan
const PINCH_REL_TH = 0.08;      // ‚â•8 % Distanz√§nderung ‚Üí Pinch
const ROTATE_SPEED_TOUCH = 0.004; // Drehgeschwindigkeit f√ºr Touch
const PAN_SPEED_TOUCH = 0.1;   // Pan-Geschwindigkeit f√ºr Touch

// --- Touch State ---
let activePointers = new Map(); // Map<pointerId, {x, y, pointerType}>
let gestureState = {
    type: 'none', // 'none', 'tap', 'pan', 'pinch', 'rotate'
    startDist: 0,
    startMid: { x: 0, y: 0 },
    lastMid: { x: 0, y: 0 },
    lastDist: 0,
    startTime: 0,
    initialPointerCount: 0,
};
let tapCandidate = null; // {x, y, time}
let doubleTapDragActive = false; // Flag for double-tap-and-drag drawing
let touchIndicator; // DOM element for visual feedback

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;   // Globale Drehgeschwindigkeit f√ºr Maus

let euler; // Declare euler globally
const voxels = new Map();   // Map<globalVoxelKey,{color}> - Stores ALL voxels for save/load/history
const chunks = new Map();   // Map<chunkKey, VoxelChunk> - Stores active chunks for rendering

let cvs;
let containerDiv; // Reference to the container div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt f√ºr aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse f√ºr Alt+Mausrad

// NEW: Global object to store fixed plane parameters for drag operations
let fixedDragPlaneParams = { level: null, axis: null };

// Lade die Farbe aus dem Local Storage oder nutze Wei√ü als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
// Lade die Gittergr√∂√üe aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10');

// Load other settings from local storage or set defaults
activeDrawingLevel.x = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
activeDrawingLevel.y = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
activeDrawingLevel.z = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';
let currentBlockSize = parseInt(localStorage.getItem('voxelEditorCurrentBlockSize') || '1'); // Declared here

// NEW: Dynamic block dimensions
let dynamicBlockDim = {
    x: parseInt(localStorage.getItem('voxelEditorDynamicBlockDimX') || '1'),
    y: parseInt(localStorage.getItem('voxelEditorDynamicBlockDimY') || '1'),
    z: parseInt(localStorage.getItem('voxelEditorDynamicBlockDimZ') || '1')
};
let useDynamicBlockDim = localStorage.getItem('voxelEditorUseDynamicBlockDim') === 'true';

// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgr√ºn (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen f√ºr Lichter, die Schatten werfen, um sie sp√§ter anpassen zu k√∂nnen
let mainDirectionalLight;
let fillDirectionalLight; // NEW: Zweites gerichtetes Licht
let hemisphereLight;      // NEW: Hemisph√§renlicht
let groundPlane;          // NEW: Bodenplatte

// Globale Variablen f√ºr Dragging-Status
let isShiftDragging = false;   // physische Shift-Taste

function shiftActive(){        // true, wenn Shift an
    return isShiftDragging;
}
let isControlDragging = false;
// Removed 'rotate' global variable as it's redundant with pointer lock
let isPointerLocked = false; // NEW: Track pointer lock status
let lastActionVoxelCoords = null; // NEW: Tracks the last voxel acted upon for drag drawing
let initialClickPos = null; // To differentiate click from drag
let firstMoveAfterLock = true; // NEW: Flag to ignore first movement after pointer lock

// Performance optimization: InstancedMesh
// Removed global instancedMesh, now managed by chunks
const dummy = new THREE.Object3D(); // For setting instance matrices
const tempColor = new THREE.Color(); // For setting instance colors

// NEU: Globale Variable f√ºr den Vorschau-Voxel
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // depthTest: false, damit er immer sichtbar ist
// NEW: Z-Fighting fix for preview voxel
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Initialize here
// ENDE NEU

// Modus-Enum
const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
    MEASURE: 'Messen', // NEW
};
let currentMode = Modes.ADD; // Standardmodus

// Undo/Redo History
let history = []; // Declared globally
let historyPointer = -1; // Declared globally
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// NEW: Global object to store voxels added/modified during the current drag operation
// Map<globalVoxelKey, {color, initialColor}>
// initialColor is needed for DRAW mode to know what color it was before the drag started.
let currentDragVoxels = new Map();
let previousFrameDragVoxels = new Set(); // Stores keys of voxels drawn in the *previous* onPointerMove frame

// NEW: Global variables for image template
let templateImageMesh = null;
// Updated templateImageData structure to store scaled dimensions
let templateImageData = null; // { src: base64, position: [], rotation: [], [], scaledWidth: number, scaledHeight: number }

// NEW: Mobile specific flags and variables
let isMobile = window.matchMedia('(max-width: 768px)').matches;
let touchAssistEnabled = false; // For magnetic targeting

// NEW: Distance measurement variables
let distanceDisplay;
let initialDragVoxelWorldPos = null;
let dragAxisLock = null; // Stores the axis locked for line drawing ('x', 'y', 'z' or null)

// NEW: Global variables for measurement
let measurementStartPoint = null; // {gx, gy, gz} of the first clicked voxel
let measurementEndPoint = null; // {gx, gy, gz} of the second clicked voxel

// Global for preview line InstancedMesh for measurement mode
let previewLineInstancedMesh;
const maxPreviewInstances = 180 * 3; // Max possible length of a line in a grid (GRID * 3, assuming max GRID is 180)
// Global array for preview voxels in measurement mode
let previewLineVoxels = [];

// NEW: Project metadata variables
let projectTitle = '';
let projectDescription = '';
let projectTags = []; // Stored as an array of strings
let projectRemixOf = ''; // NEW: Stores the ID of the model this was remixed from
let projectSourceJsonUrl = ''; // NEW: Stores the URL from which the project was loaded (if any)
let projectVisibility = 'public'; // Default visibility

// NEW: Firebase variables
let auth;
let db;
let currentUserId = null; // Stores the Firebase User ID

/* ---------- Chunking System Classes and Helpers ---------- */

function getChunkCoords(gx, gy, gz) {
    return {
        cx: Math.floor(gx / CHUNK_SIZE),
        cy: Math.floor(gy / CHUNK_SIZE),
        cz: Math.floor(gz / CHUNK_SIZE)
    };
}

function getChunkKey(cx, cy, cz) {
    return `${cx},${cy},${cz}`;
}

class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX;
        this.chunkY = chunkY;
        this.chunkZ = chunkZ;
        this.scene = scene;
        this.chunkSize = chunkSize; // FIX: Store chunkSize correctly

        // Global offset for this chunk
        this.offsetX = chunkX * chunkSize * VS;
        this.offsetY = chunkY * chunkSize * VS;
        this.offsetZ = chunkZ * chunkSize * VS;

        // Map from local voxel key (within this chunk) to {color, instanceId}
        this.voxels = new Map();
        // Map from global voxel key to local instanceId within this chunk's InstancedMesh
        this.globalToLocalInstanceIdMap = new Map();

        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();

        // Reverted to standard Three.js InstancedMesh color handling
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        // REMOVED: this.instancedMesh.geometry.setAttribute('instanceMatrix', this.instancedMesh.instanceMatrix); // This line caused the error
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);

        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true;
        this.instancedMesh.receiveShadow = true;
        this.instancedMesh.count = 0; // Initially no instances
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ); // Position the chunk mesh
        this.scene.add(this.instancedMesh);

        // Bounding box for frustum culling
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }

    // Helper to get local voxel key within chunk
    getLocalKey(gx, gy, gz) {
        const lx = gx % this.chunkSize;
        const ly = gy % this.chunkSize;
        const lz = gz % this.chunkSize;
        return key(lx, ly, lz); // Use the global key function for local keys too
    }

    addVoxel(gx, gy, gz, colorHex) {
        const localKey = this.getLocalKey(gx, gy, gz);
        const globalKey = key(gx, gy, gz);

        if (this.voxels.has(localKey)) {
            // Update existing voxel
            const instanceId = this.voxels.get(localKey).instanceId;
            this.voxels.set(localKey, { color: colorHex, instanceId });
            this.updateInstanceColor(instanceId, colorHex);
        } else {
            // Add new voxel
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(localKey, { color: colorHex, instanceId });
            this.globalToLocalInstanceIdMap.set(globalKey, instanceId); // Map global key to instance ID within this chunk

            const localX = gx % this.chunkSize;
            const localY = gy % this.chunkSize;
            const localZ = gz % this.chunkSize;

            dummy.position.set(localX * VS + HALF, localY * VS + HALF, localZ * VS + HALF);
            dummy.updateMatrix();
            this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true;
            this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }

    removeVoxel(gx, gy, gz) {
        const localKey = this.getLocalKey(gx, gy, gz);
        const globalKey = key(gx, gy, gz);

        if (!this.voxels.has(localKey)) return;

        const { instanceId: removedInstanceId } = this.voxels.get(localKey);

        this.voxels.delete(localKey);
        this.globalToLocalInstanceIdMap.delete(globalKey);

        // Swap the last instance with the removed one to maintain dense buffer
        const lastInstanceId = this.instancedMesh.count - 1;
        if (removedInstanceId !== lastInstanceId) {
            // Find the local key of the voxel that was at the lastInstanceId
            let lastVoxelLocalKey = null;
            for (const [lKey, data] of this.voxels.entries()) {
                if (data.instanceId === lastInstanceId) {
                    lastVoxelLocalKey = lKey;
                    break;
                }
            }
            
            if (lastVoxelLocalKey !== null) {
                // Copy matrix and color from last instance to removed instance's slot
                const tempMatrix = new THREE.Matrix4();
                this.instancedMesh.getMatrixAt(lastInstanceId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedInstanceId, tempMatrix);

                const lastVoxelColor = this.voxels.get(lastVoxelLocalKey).color;
                this.updateInstanceColor(removedInstanceId, lastVoxelColor);

                // Update the instanceId in the last voxel's data
                this.voxels.get(lastVoxelLocalKey).instanceId = removedInstanceId;
                // Update the globalToLocalInstanceIdMap for the moved voxel
                const [lx, ly, lz] = parseKey(lastVoxelLocalKey);
                const globalX = this.chunkX * this.chunkSize + lx;
                const globalY = this.chunkY * this.chunkSize + ly;
                const globalZ = this.chunkZ * this.chunkSize + lz;
                this.globalToLocalInstanceIdMap.set(key(globalX, globalY, globalZ), removedInstanceId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true;
        this.instancedMesh.instanceColor.needsUpdate = true;
    }

    recolorVoxel(gx, gy, gz, newColorHex) {
        const localKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(localKey)) return;

        const { instanceId } = this.voxels.get(localKey);
        this.voxels.set(localKey, { color: newColorHex, instanceId });
        this.updateInstanceColor(instanceId, newColorHex);
    }

    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex);
        // Set color using r, g, b components (0-1 range)
        this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }

    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose();
        this.instancedMesh.material.dispose();
        this.instancedMesh = null;
        this.voxels.clear();
        this.globalToLocalInstanceIdMap.clear();
    }
}


/* ---------- Hilfsfunktionen (alle vor window.onload verschoben) ---------- */

function onResize() {
    // Use containerDiv for sizing
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    // NEW: Adjust pixel ratio for mobile performance
    if (isMobile) {
        ren.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
    } else {
        ren.setPixelRatio(window.devicePixelRatio);
    }
}

function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    // --- Single-finger drag for camera rotation ---
    if (pointers.length === 1 && gestureState.type === 'rotate') {
        const p = pointers[0];
        const dx = p.x - gestureState.lastMid.x;
        const dy = p.y - gestureState.lastMid.y; // Corrected this line

        euler.y -= dx * ROTATE_SPEED_TOUCH;
        euler.x += dy * ROTATE_SPEED_TOUCH;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);

        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    // --- Multi-finger gestures (pan/pinch) ---
    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        // --- Determine gesture type on first move ---
        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;

            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > PAN_PIX_TH) {
                gestureState.type = 'pan';
            }
            return; // Wait for next move event to execute
        }

        // --- Execute Pinch (Zoom) ---
        else if (gestureState.type === 'pinch') {
            const scale = dist / gestureState.lastDist;
            // Invert pinch zoom direction
            const zoomDelta = (scale - 1) * PINCH_ZOOM_MULT * moveSpeed; // MODIFIED: (scale - 1) instead of (1 - scale)
            cam.position.addScaledVector(
                cam.getWorldDirection(new THREE.Vector3()),
                zoomDelta
            );
            gestureState.lastDist = dist;
        }
        // --- Execute Pan (Strafe) ---
        else if (gestureState.type === 'pan') {
            const panFactor = PAN_SPEED_TOUCH * moveSpeed;
            const dx = (midX - gestureState.lastMid.x) * panFactor;
            const dy = (midY - gestureState.lastMid.y) * panFactor;

            const dir = cam.getWorldDirection(new THREE.Vector3());
            const right = new THREE.Vector3().crossVectors(dir, cam.up).normalize();
            // Use world up for vertical panning to avoid disorienting movement
            const upVec = new THREE.Vector3(0, 1, 0);

            cam.position.addScaledVector(right, -dx);
            cam.position.addScaledVector(upVec, dy);

            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}


function releasePointer(id, eventType) { // Add eventType parameter
    activePointers.delete(id);

    // NEW: Handle three-finger swipe for undo/redo
    if (gestureState.initialPointerCount >= 3 && activePointers.size === 0 && initialClickPos && eventType.pointerType === 'touch') {
        const dx = eventType.clientX - initialClickPos.x;
        const absDx = Math.abs(dx);

        if (absDx > 50) { // Horizontal swipe threshold
            if (dx > 0) redo();
            else undo();
        }
    }

    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) {
            const last = [...activePointers.values()][0];
            gestureState.lastMid = { x: last.x, y: last.y };
        }
    }

    if (activePointers.size === 0) {
        doubleTapDragActive = false;
        lastActionVoxelCoords = null;
        touchIndicator.style.display = 'none';
        // Also reset fixed drag plane params for touch
        fixedDragPlaneParams = { level: null, axis: null };
        // Hide distance display on touch up
        // Only hide if not in measurement mode or if measurement is completed
        if (currentMode !== Modes.MEASURE || (currentMode === Modes.MEASURE && measurementStartPoint === null && measurementEndPoint === null)) {
            distanceDisplay.style.display = 'none';
        }
        initialDragVoxelWorldPos = null;
        dragAxisLock = null; // Reset drag axis lock
        
        // Clear preview line voxels on touch up
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
    }
}

function rebuildHelpers() {
    if (typeof THREE === 'undefined') {
        console.error("THREE is not defined in rebuildHelpers. Cannot rebuild helpers.");
        return;
    }
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.z = Math.PI / 2;
        gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    // Check if any input element has focus
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        // If an input element has focus, prevent mode change and return focus to canvas
        cvs.focus();
        return;
    }

    switch (currentMode) {
        case Modes.ADD:
            currentMode = Modes.DELETE;
            break;
        case Modes.DELETE:
            currentMode = Modes.DRAW;
            break;
        case Modes.DRAW:
            currentMode = Modes.MEASURE; // Cycle to Measure mode
            break;
        case Modes.MEASURE: // NEW: Cycle back to ADD mode
            currentMode = Modes.ADD;
            // Reset measurement state when exiting measure mode
            measurementStartPoint = null;
            measurementEndPoint = null;
            distanceDisplay.style.display = 'none';
            // Clear preview line voxels
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    fixedDragPlaneParams = { level: null, axis: null };
    lastActionVoxelCoords = null;
    updatePreviewVoxel(0, 0, 0, false); // Hide preview when changing mode
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor); // Save as current selected color

        // Update active class for visual feedback
        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index; // Store which preset is active
    }
}

// New function to save current color to a preset slot
function savePresetColor(index, colorValue) { // Modified to accept colorValue
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue; // Update the array with the new color
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue); // Persist to local storage
        // The input type="color" itself will update its background color
        // No need to call setActivePreset here, as it's a direct edit of the preset
        console.log(`Preset color ${index + 1} saved: ${colorValue}`);
    }
}

// NEW: Helper function to apply a state (set of voxels)
function applyVoxelState(state) {
    // Clear all current voxels
    for (const chunk of chunks.values()) {
        chunk.dispose();
    }
    chunks.clear();
    voxels.clear();

    // Add voxels from the provided state
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

function addCommand(type, oldState = null, newState = null, commandData = null) {
    // Clear redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    history.push({ type, oldState, newState, commandData });
    historyPointer++;

    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': // Handle batch commands for drag/multi-block operations
            if (reverse) {
                applyVoxelState(oldState);
            } else {
                applyVoxelState(newState);
            }
            break;
        case 'clearAll':
            if (reverse) {
                applyVoxelState(oldState);
            } else {
                clearAllInternal(true); // Clear directly without history
            }
            break;
        case 'fillLevel':
            if (reverse) {
                applyVoxelState(oldState);
            } else {
                applyVoxelState(newState);
            }
            break;
        case 'resizeGrid':
            const targetGridSize = reverse ? commandData.oldGrid : commandData.newGrid;
            GRID = targetGridSize;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            applyVoxelState(reverse ? oldState : newState);
            break;
    }
    rebuildHelpers(); // Ensure helpers reflect the new state
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // true for reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // false for forward
    }
}

// Internal helper: Directly adds a single voxel to the scene and global map
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const globalKey = key(gx, gy, gz);
    voxels.set(globalKey, { color: colorHex });

    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const chunkKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(chunkKey);
    if (!chunk) {
        chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene);
        chunks.set(chunkKey, chunk);
    }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

// Internal helper: Directly removes a single voxel from the scene and global map
function _removeSingleVoxel(gx, gy, gz) {
    const globalKey = key(gx, gy, gz);
    if (!voxels.has(globalKey)) return;

    voxels.delete(globalKey);

    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const chunkKey = getChunkKey(cx, cy, cz);
    if (chunks.has(chunkKey)) {
        const chunk = chunks.get(chunkKey);
        chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) {
            chunk.dispose();
            chunks.delete(chunkKey);
        }
    }
}

// Internal helper: Directly recolors a single voxel in the scene and global map
function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const globalKey = key(gx, gy, gz);
    if (!voxels.has(globalKey)) return;

    voxels.set(globalKey, { color: newColorHex });

    const { cx, cy, cz } = getChunkCoords(gx, gy, gz);
    const chunkKey = getChunkKey(cx, cy, cz);
    if (chunks.has(chunkKey)) {
        chunks.get(chunkKey).recolorVoxel(gx, gy, gz, newColorHex);
    }
}

// NEW: Helper function to perform the actual voxel modification for a single 1x1x1 voxel
// This is now always called with 1x1x1 dimensions.
function performVoxelModification(gx, gy, gz, mode, color) {
    const globalKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(globalKey);

    switch (mode) {
        case Modes.ADD:
            // Only add if it doesn't exist or color is different
            if (!hasVoxel || voxels.get(globalKey).color !== color) {
                _addSingleVoxel(gx, gy, gz, color);
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(gx, gy, gz);
            }
            break;
        case Modes.DRAW:
            if (hasVoxel && voxels.get(globalKey).color !== color) {
                _recolorSingleVoxel(gx, gy, gz, color);
            }
            break;
    }
}


// NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Voxels
// Now takes explicit dimX, dimY, dimZ, but for MEASURE mode, it will override to 1x1x1
function updatePreviewVoxel(x, y, z, visible, dimX = 1, dimY = 1, dimZ = 1) {
    if (previewVoxelMesh) {
        if (visible) {
            // For MEASURE mode, always show a 1x1x1 preview
            if (currentMode === Modes.MEASURE) {
                dimX = 1;
                dimY = 1;
                dimZ = 1;
            }

            // Dispose old geometry if dimensions change
            if (previewVoxelMesh.geometry.parameters.width !== dimX * VS ||
                previewVoxelMesh.geometry.parameters.height !== dimY * VS ||
                previewVoxelMesh.geometry.parameters.depth !== dimZ * VS) {
                previewVoxelMesh.geometry.dispose();
                const tempGeometry = new THREE.BoxGeometry(dimX * VS, dimY * VS, dimZ * VS);
                previewVoxelMesh.geometry = tempGeometry;
            }


            // Calculate the center of the block relative to its (x,y,z) base corner
            const centerX = x * VS + (dimX * VS) / 2;
            const centerY = y * VS + (dimY * VS) / 2;
            const centerZ = z * VS + (dimZ * VS) / 2;

            previewVoxelMesh.position.set(centerX, centerY, centerZ);

            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor); // Vorschau-Farbe an aktuelle Farbe anpassen
            // Optional: Passe die Opazit√§t basierend auf dem Modus an
            if (currentMode === Modes.DELETE) {
                previewVoxelMaterial.opacity = 0.2; // Weniger sichtbar beim L√∂schen
            } else {
                previewVoxelMaterial.opacity = 0.5; // Standard Opazit√§t
            }
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}
// ENDE NEU

// NEW helper function to set the fixed drag plane parameters
function setFixedDragPlane(clientX, clientY, mode) {
    // Only set fixed drag plane for ADD mode
    if (mode !== Modes.ADD) {
        fixedDragPlaneParams = { level: null, axis: null };
        return;
    }

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);
    
    // Raycast against all active chunk meshes
    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    const intersects = raycaster.intersectObjects(objectsToIntersect);

    if (intersects.length > 0) {
        const hit = intersects[0];
        // The face normal is in world coordinates for the hit face
        const hitNormal = hit.face.normal.clone();
        
        // BUGFIX: Move the intersection point slightly *inside* the hit voxel
        // This ensures that flooring the coordinate gives the coordinate of the HIT voxel, not the next one.
        const hitPoint = hit.point.clone().sub(hitNormal.multiplyScalar(0.01));

        // Convert world position to grid coordinates
        const hitVoxelX = Math.floor(hitPoint.x / VS);
        const hitVoxelY = Math.floor(hitPoint.y / VS);
        const hitVoxelZ = Math.floor(hitPoint.z / VS);

        let level, axis;

        // The normal needs to be reset for axis detection after being used for the offset calculation
        const axisNormal = hit.face.normal;
        const absX = Math.abs(axisNormal.x);
        const absY = Math.abs(axisNormal.y);
        const absZ = Math.abs(axisNormal.z);

        // When adding, we want to place on the *next* layer relative to the hit voxel
        if (absY > absX && absY > absZ) { 
            axis = 'y';
            level = hitVoxelY + Math.round(axisNormal.y);
        } else if (absX > absY && absX > absZ) {
            axis = 'x';
            level = hitVoxelX + Math.round(axisNormal.x);
        } else {
            axis = 'z';
            level = hitVoxelZ + Math.round(axisNormal.z);
        }
        fixedDragPlaneParams.level = level;
        fixedDragPlaneParams.axis = axis;
    } else {
        // If no voxel is hit, default to the current active drawing level and axis
        fixedDragPlaneParams.axis = currentDrawingAxis;
        fixedDragPlaneParams.level = activeDrawingLevel[currentDrawingAxis];
    }
}

// NEW: Magnetic targeting helper for touch assist
function getNearestVoxelCenter(intersectionPoint) {
    const gx = Math.floor(intersectionPoint.x / VS);
    const gy = Math.floor(intersectionPoint.y / VS);
    const gz = Math.floor(intersectionPoint.z / VS);

    // Calculate the center of the grid cell
    return new THREE.Vector3(
        gx * VS + HALF,
        gy * VS + HALF,
        gz * VS + HALF
    );
}

// Helper function to find the closest point on a line (defined by point and direction) to a ray
const tempVector1 = new THREE.Vector3();
const tempVector2 = new THREE.Vector3();

function closestPointOnLineToRay(rayOrigin, rayDirection, linePoint, lineDirection) {
    const a = rayDirection.dot(rayDirection); // |rayDirection|^2
    const b = rayDirection.dot(lineDirection); // dot product of directions
    const c = lineDirection.dot(lineDirection); // |lineDirection|^2

    // Vector from linePoint to rayOrigin
    const r = tempVector1.subVectors(rayOrigin, linePoint);

    const denominator = a * c - b * b;

    if (denominator === 0) { // Lines are parallel or collinear
        // In this case, just project rayOrigin onto the line
        return linePoint.clone().add(lineDirection.clone().multiplyScalar(r.dot(lineDirection) / c));
    }

    // Parameter 't' for the ray (P_ray = rayOrigin + t * rayDirection)
    // Parameter 's' for the line (P_line = linePoint + s * lineDirection)
    // We want to find 's' for the point on the line closest to the ray
    const s = (a * r.dot(lineDirection) - b * r.dot(rayDirection)) / denominator;

    return linePoint.clone().add(lineDirection.clone().multiplyScalar(s));
}


/**
 * Berechnet die Ziel-Voxel-Koordinaten basierend auf der Mausposition und dem Modus.
 * Diese Funktion gibt die rohen Gitterkoordinaten zur√ºck, ohne Ankerpunkt-Offset oder Klemmen.
 *
 * @param {number} clientX - X-Koordinate des Mauszeigers im Client-Bereich.
 * @param {number} clientY - Y-Koordinate des Mauszeigers im Client-Bereich.
 * @param {string} mode - Aktueller Modus (ADD, DELETE, DRAW, MEASURE).
 * @param {string} pointerType - Typ des Pointers ('mouse' oder 'touch').
 * @returns {object|null} - Objekt mit gx, gy, gz oder null, wenn kein Ziel gefunden wurde.
 */
function calculateTargetVoxelCoords(clientX, clientY, mode, pointerType) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    let targetVoxelCoords = null;
    let intersectionPoint = new THREE.Vector3();

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const hitNormal = hit.face.normal.clone();
        intersectionPoint.copy(hit.point);

        // Berechne die Koordinaten des *getroffenen* Voxels.
        // Verschiebe den Schnittpunkt leicht *innerhalb* des getroffenen Voxels, um das Abrunden zu erleichtern.
        const hitPointInside = hit.point.clone().sub(hitNormal.multiplyScalar(0.001)); // Kleinerer Offset f√ºr Pr√§zision
        const hitVoxelX = Math.floor(hitPointInside.x / VS);
        const hitVoxelY = Math.floor(hitPointInside.y / VS);
        const hitVoxelZ = Math.floor(hitPointInside.z / VS);

        if (mode === Modes.ADD) {
            // Im Hinzuf√ºgen-Modus ist das Ziel das Voxel *neben* dem getroffenen
            // in Richtung der Normalen.
            let normalX = 0, normalY = 0, normalZ = 0;
            const absX = Math.abs(hit.face.normal.x);
            const absY = Math.abs(hit.face.normal.y);
            const absZ = Math.abs(hit.face.normal.z);

            // Bestimme die dominante Normalkomponente, um eine saubere achsenparallele Platzierung zu gew√§hrleisten
            if (absX > absY && absX > absZ) {
                normalX = Math.sign(hit.face.normal.x);
            } else if (absY > absX && absY > absZ) {
                normalY = Math.sign(hit.face.normal.y);
            } else if (absZ > absX && absZ > absY) {
                normalZ = Math.sign(hit.face.normal.z);
            }
            // Fallback f√ºr Kanten-/Eckf√§lle, bei denen mehrere Komponenten gleich oder nahezu gleich sein k√∂nnten
            if (normalX === 0 && normalY === 0 && normalZ === 0) {
                if (Math.abs(hit.face.normal.y) > 0.01) normalY = Math.sign(hit.face.normal.y);
                else if (Math.abs(hit.face.normal.x) > 0.01) normalX = Math.sign(hit.face.normal.x);
                else if (Math.abs(hit.face.normal.z) > 0.01) normalZ = Math.sign(hit.face.normal.z);
            }

            targetVoxelCoords = {
                gx: hitVoxelX + normalX,
                gy: hitVoxelY + normalY,
                gz: hitVoxelZ + normalZ
            };
        } else { // DELETE, DRAW, MEASURE
            // In anderen Modi ist das Ziel das *getroffene* Voxel selbst.
            targetVoxelCoords = { gx: hitVoxelX, gy: hitVoxelY, gz: hitVoxelZ };
        }
    } else { // Kein Voxel getroffen
        if (mode === Modes.ADD) {
            // Wenn kein Voxel getroffen wird, verwende im Hinzuf√ºgen-Modus die aktive Zeichenebene.
            let planeNormal = new THREE.Vector3();
            let planeConstant = 0;
            if (currentDrawingAxis === 'y') {
                planeNormal.set(0, 1, 0);
                planeConstant = -(activeDrawingLevel.y * VS);
            } else if (currentDrawingAxis === 'x') {
                planeNormal.set(1, 0, 0);
                planeConstant = -(activeDrawingLevel.x * VS);
            } else if (currentDrawingAxis === 'z') {
                planeNormal.set(0, 0, 1);
                planeConstant = -(activeDrawingLevel.z * VS);
            }
            const drawingPlane = new THREE.Plane(planeNormal, planeConstant);

            if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
                let gx = Math.floor(intersectionPoint.x / VS);
                let gy = Math.floor(intersectionPoint.y / VS);
                let gz = Math.floor(intersectionPoint.z / VS);

                if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

                targetVoxelCoords = { gx, gy, gz };
            } else {
                // KRITISCHER FALLBACK: Wenn der Strahl die Ebene nicht schneidet, Standard auf die Mitte der aktiven Zeichenebene.
                targetVoxelCoords = {
                    gx: Math.floor(GRID / 2),
                    gy: Math.floor(GRID / 2),
                    gz: Math.floor(GRID / 2)
                };
                if (currentDrawingAxis === 'y') targetVoxelCoords.gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') targetVoxelCoords.gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') targetVoxelCoords.gz = activeDrawingLevel.z;
            }
        }
        // Wenn nicht im Hinzuf√ºgen-Modus und keine Schnittmenge, bleibt targetVoxelCoords null.
    }

    // Wende Touch-Assist (magnetische Zielerfassung) an, wenn f√ºr Touch-Ger√§te aktiviert
    if (targetVoxelCoords && pointerType === 'touch' && touchAssistEnabled && intersectionPoint) {
        const snappedPos = getNearestVoxelCenter(intersectionPoint);
        targetVoxelCoords.gx = Math.round(snappedPos.x / VS - HALF);
        targetVoxelCoords.gy = Math.round(snappedPos.y / VS - HALF);
        targetVoxelCoords.gz = Math.round(snappedPos.z / VS - HALF);
    }
    
    // Ankerpunkt-Offset und Klemmen werden vom Aufrufer (onPointerDown/onPointerMove) angewendet.
    return targetVoxelCoords;
}


function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        // Capture old state for undo
        const oldState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        addCommand('clearAll', oldState, []);
    }
    // Dispose all chunks and clear the chunks map
    for (const chunk of chunks.values()) {
        chunk.dispose();
    }
    chunks.clear();
    voxels.clear(); // Clear global voxel map
    rebuildHelpers(); // Ensure helpers are reset or updated appropriately
}

function clearAll() {
    clearAllInternal(false); // User initiated clear, adds to history
}


function fillActiveLevel() {
    // Capture the current state before the fill for undo/redo
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    // Clear existing voxels on the plane for fill, without adding to history
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x; // Use x as y-coordinate for horizontal plane
                gz = z; // Use z as z-coordinate
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z; // Use z as y-coordinate for horizontal plane
                gz = activeDrawingLevel.z;
            }
            const k = key(gx, gy, gz);
            if (voxels.has(k)) {
                voxelsToRemove.push(k);
            }
        }
    }
    // Remove all existing voxels on the plane
    voxelsToRemove.forEach(k => {
        const [gx, gy, gz] = parseKey(k);
        _removeSingleVoxel(gx, gy, gz);
    });


    // Add new voxels for the fill
    const newState = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x;
                gz = z;
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z;
                gz = activeDrawingLevel.z;
            }
            _addSingleVoxel(gx, gy, gz, currentColor);
            newState.push({ gx, gy, gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
        }
    }

    // Add a single command for the entire fill operation
    addCommand('fillLevel', oldState, newState);
}


function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => { // k is now a number
        const [gx,gy,gz] = parseKey(k); // Parse the numeric key back to coords
        data[`${gx},${gy},${gz}`] = value.color; // Save as string key
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed, // Save fly speed
        currentBlockSize: currentBlockSize, // Save current block size
        dynamicBlockDim: dynamicBlockDim, // NEW: Save dynamic block dimensions
        useDynamicBlockDim: useDynamicBlockDim, // NEW: Save dynamic block flag
        templateImageData: templateImageData // NEW: Save template image data
    };

const projectData = {
  title: projectTitle,
  description: projectDescription,
  remixOf: projectRemixOf,
  sourceJsonUrl: projectSourceJsonUrl,
  tags: projectTags,
  visibility: projectVisibility,

  downloads: 0,
  rating: 0,
  ratingCount: 0,
  verified: false,

  fileName: `${projectTitle.replace(/\s+/g, "_")}.json`,
  timestamp: new Date(),

  uploaderEmail: currentUser?.email || "",
  uploaderUid: currentUser?.uid || "",
  uploaderPhotoURL: currentUser?.photoURL || "",

  projectData: {
    description: "",
    remixOf: "",
    sourceJsonUrl: "",
    settings: settings,
    activeDrawingLevel: activeDrawingLevel,
    activePresetIndex: activePresetIndex,
    cameraPosition: [
      cam.position.x,
      cam.position.y,
      cam.position.z
    ],
    cameraQuaternion: [
      cam.quaternion.x,
      cam.quaternion.y,
      cam.quaternion.z,
      cam.quaternion.w
    ],
    currentAnchorPoint: {
      x: "start",
      y: "start",
      z: "start"
    },
    currentBlockSize: currentBlockSize,
    currentColor: currentColor,
    currentDrawingAxis: currentDrawingAxis,
    dynamicBlockDim: dynamicBlockDim,
    gridSize: GRID,
    moveSpeed: moveSpeed,
    presetColors: presetColors,
    templateImageData: null,
    useDynamicBlockDim: useDynamicBlockDim,
    voxels: data
  }
};


    const json = JSON.stringify(projectData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success');
}

function resetToDefaultProject() {
    clearAllInternal(true); // Clear everything without adding to history
    GRID = 10;
    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    localStorage.setItem('voxelEditorGridSize', GRID);

    currentColor = '#ffffff';
    document.getElementById('color-picker').value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);

    activeDrawingLevel = { x: 0, y: 0, z: 0 };
    currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);

    moveSpeed = 0.1;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

    currentBlockSize = 1;
    setFixedBlockSize(currentBlockSize); // Use setFixedBlockSize
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);

    // NEW: Reset dynamic block size
    dynamicBlockDim = { x: 1, y: 1, z: 1 };
    useDynamicBlockDim = false;
    localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x);
    localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y);
    localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z); // Fixed typo in local storage key
    localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);
    document.getElementById('dynamic-block-x').value = dynamicBlockDim.x;
    document.getElementById('dynamic-block-y').value = dynamicBlockDim.y;
    document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;
    updateBlockSizeButtonsActiveState(); // Update active state for buttons

    // Reset preset colors to defaults
    presetColors[0] = '#8B4513';
    presetColors[1] = '#708237';
    presetColors[2] = '#6495ED';
    localStorage.setItem('voxelPresetColor1', presetColors[0]);
    localStorage.setItem('voxelPresetColor2', presetColors[1]);
    localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => {
        // For input type="color", setting value directly updates its visual
        box.value = presetColors[i];
        box.classList.remove('active');
    });
    activePresetIndex = -1;

    removeImageTemplate(true); // Remove template without history logging

    history.length = 0;
    historyPointer = -1;

    // Reset measurement state
    measurementStartPoint = null;
    measurementEndPoint = null;
    distanceDisplay.style.display = 'none';
    previewLineInstancedMesh.count = 0; // Clear preview line
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];

    // NEW: Reset project metadata fields (internal variables only)
    projectTitle = '';
    projectDescription = '';
    projectTags = [];
    projectRemixOf = ''; // Clear remixOf for new project
    projectSourceJsonUrl = ''; // Clear sourceJsonUrl for new project
    projectVisibility = 'public';

    rebuildHelpers();
    resetCameraPosition();
    showToast('Projekt zur√ºckgesetzt', 'Das Projekt wurde auf den Standardzustand zur√ºckgesetzt.', 'info');
    console.log('Project reset to default state.');
}

// Refactored function to load project data from a parsed JSON object
function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.voxels;
        const loadedSettings = projectData.settings;

        // Clear current state and history before loading new project
        clearAllInternal(true); // Clear without adding to history

        // Remove existing template image if any
        removeImageTemplate(true); // true to prevent history logging for this internal operation

        // NEW: Load project metadata fields into internal variables
        projectTitle = projectData.title || '';
        projectDescription = projectData.description || '';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; // Load remixOf
        projectSourceJsonUrl = projectData.sourceJsonUrl || ''; // Load sourceJsonUrl
        projectVisibility = projectData.visibility || 'public'; // Default to public if not found

        // Load settings first to get the correct GRID size
        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID); // Ensure it's saved back
            console.log("Loaded GRID size from JSON:", GRID);
        } else {
            console.warn("No settings found in JSON, using default GRID size.");
        }

        // Load voxels into the global map and create chunks as needed
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k];
            const parts = k.split(',').map(Number); 
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0];
                const gy = parts[1];
                const gz = parts[2];

                // Only add if within the bounds of the newly loaded GRID size
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) {
                    _addSingleVoxel(gx, gy, gz, colorValue); // Use internal helper
                }
            }
        }

        // Continue loading other settings after GRID is set and InstancedMesh is re-initialized
        if (loadedSettings) {
            if (loadedSettings.cameraPosition) {
                cam.position.fromArray(loadedSettings.cameraPosition);
            }
            if (loadedSettings.cameraQuaternion) {
                cam.quaternion.fromArray(loadedSettings.cameraQuaternion);
                euler.setFromQuaternion(cam.quaternion, 'YXZ');
            }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = { ...loadedSettings.activeDrawingLevel };
                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) {
                currentDrawingAxis = loadedSettings.currentDrawingAxis;
                localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
            }
            updateGridHelperPosition();

            currentColor = loadedSettings.currentColor || '#ffffff';
            document.getElementById('color-picker').value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i];
                    // For input type="color", setting value directly updates its visual
                    document.getElementById(`color-preset-${i + 1}`).value = presetColors[i];
                    localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);

            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed;
                document.getElementById('fly-speed-slider').value = moveSpeed;
                document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }

            if (loadedSettings.currentBlockSize !== undefined) {
                setFixedBlockSize(loadedSettings.currentBlockSize); // Use setFixedBlockSize
                localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
            }

            // NEW: Load dynamic block dimensions and flag
            if (loadedSettings.dynamicBlockDim) {
                dynamicBlockDim = { ...loadedSettings.dynamicBlockDim };
                document.getElementById('dynamic-block-x').value = dynamicBlockDim.x;
                document.getElementById('dynamic-block-y').value = dynamicBlockDim.y;
                document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;
                localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x);
                localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y);
                localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z);
            }
            if (loadedSettings.useDynamicBlockDim !== undefined) {
                useDynamicBlockDim = loadedSettings.useDynamicBlockDim;
                localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);
            }
            updateBlockSizeButtonsActiveState(); // Update active state for buttons


            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                console.log("Loading template image data:", templateImageData);
                const loader = new THREE.TextureLoader();
                loader.load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) {
                        scene.remove(templateImageMesh);
                        templateImageMesh.geometry.dispose();
                        templateImageMesh.material.dispose();
                    }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position);
                    templateImageMesh.rotation.fromArray(templateImageData.rotation);
                    templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1;
                    scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
                }, undefined, (err) => {
                    console.error('Error loading template image texture:', err);
                    templateImageMesh = null;
                    templateImageData = null;
                    document.getElementById('removeImageTemplateBtn').style.display = 'none';
                });
            }
        }

        history.length = 0;
        historyPointer = -1;

        // Reset measurement state on load
        measurementStartPoint = null;
        measurementEndPoint = null;
        distanceDisplay.style.display = 'none';
        previewLineInstancedMesh.count = 0; // Clear preview line
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        console.log('Project loaded successfully.');
        resetCameraPosition();
    } catch (error) {
        console.error('Error loading JSON file:', error);
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige Voxel-Projekt-JSON-Datei handelt. Fehler: ' + error.message, 'error');
        resetToDefaultProject(); // Reset to safe state on error
    }
}

// Original loadJSON function, now calls loadProjectData
function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            // When loading from a local file, it's a new "source" for remixing
            projectRemixOf = '';
            projectSourceJsonUrl = ''; // Clear previous source
            loadProjectData(projectData);
        } catch (error) {
            console.error('Error parsing file JSON:', error);
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error');
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}


function exportSTL() {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning');
        return;
    }

    const geometriesToMerge = [];
    const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    const tempMatrix = new THREE.Matrix4();
    const tempColorExport = new THREE.Color();

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        dummy.updateMatrix();
        tempMatrix.copy(dummy.matrix); // Use dummy for matrix calculation

        tempColorExport.set(data.color);

        const instanceGeometry = tempBoxGeometry.clone();
        instanceGeometry.applyMatrix4(tempMatrix);

        const vertexColorArray = [];
        for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
            vertexColorArray.push(tempColorExport.r, tempColorExport.g, tempColorExport.b);
        }
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColorArray, 3));
        geometriesToMerge.push(instanceGeometry);
    });

    let mergedGeometry;
    if (geometriesToMerge.length > 0) {
        mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true);
    } else {
        mergedGeometry = new THREE.BufferGeometry();
    }

    // Create a temporary mesh for the exporter
    const tempMesh = new THREE.Mesh(mergedGeometry); // No material needed for STL export
    
    // Ensure the exporter is available
    if (typeof THREE.STLExporter === 'undefined') {
        console.error("STLExporter is not loaded. Make sure the script is included.");
        showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error');
        return;
    }

    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh);

    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    tempBoxGeometry.dispose();
    if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success');
}

// NEW: Function to export OBJ
function exportOBJ() {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning');
        return;
    }

    const voxelsToExport = [];
    let maxX = 0, maxY = 0, maxZ = 0;

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        voxelsToExport.push({ x, y, z, c: 1 }); // VoxelShaperIO.voxToOBJ doesn't use color index directly for OBJ
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    const objText = VoxelShaperIO.voxToOBJ(voxModel, VS); // Use VS (1) as cubeSize

    VoxelShaperIO.saveBlob(objText, 'voxel_model.obj');
    showToast('Export erfolgreich', 'OBJ-Modell erfolgreich exportiert!', 'success');
}

// NEW: Toast message function
function showToast(title, message, type = 'info', duration = 3000) {
    const toastContainer = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast-message ${type}`;
    toast.innerHTML = `
        <div>
            <strong>${title}</strong><br>
            <span>${message}</span>
        </div>
        <button class="close-btn">&times;</button>
    `;

    toastContainer.appendChild(toast);

    // Trigger reflow to ensure transition plays
    void toast.offsetWidth;
    toast.classList.add('show');

    const closeBtn = toast.querySelector('.close-btn');
    closeBtn.addEventListener('click', () => {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
    });

    setTimeout(() => {
        if (toast.parentNode) { // Check if toast hasn't been manually closed
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }
    }, duration);
}


function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) {
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
    }
}

// NEW: Function to load image as template
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

// NEW: Handle image file selection
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;

        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set(
                (GRID * VS) / 2,
                (GRID * VS) / 2,
                -0.5 * VS
            );
            templateImageMesh.rotation.y = Math.PI; // Rotate 180 degrees around Y-axis
            templateImageMesh.renderOrder = -1;
            scene.add(templateImageMesh);

            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1], 
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            console.log("Saving template image data:", templateImageData);

            document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success');
        };
        img.src = base64Image;
    };
    reader.readAsDataURL(file);
}

// NEW: Function to remove the image template
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh);
        templateImageMesh.geometry.dispose();
        templateImageMesh.material.dispose();
        templateImageMesh = null;
        templateImageData = null;
        document.getElementById('removeImageTemplateBtn').style.display = 'none';
        if (!fromLoad) {
            showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info');
        }
    }
}

// NEW: Function to update the ground plane size based on current GRID
function updateGroundPlaneSize() {
    // Remove the ground plane if it's not needed or exists
    if (groundPlane) {
        scene.remove(groundPlane);
        groundPlane.geometry.dispose();
        groundPlane.material.dispose();
        groundPlane = null;
    }
    // If you want a ground plane, re-add it here, e.g.:
    // const groundGeometry = new THREE.PlaneGeometry(GRID * VS, GRID * VS);
    // const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
    // groundPlane = new THREE.Mesh(groundGeometry, groundMaterial);
    // groundPlane.rotation.x = -Math.PI / 2;
    // groundPlane.position.y = -0.01; // Slightly below grid
    // groundPlane.receiveShadow = true;
    // scene.add(groundPlane);
}

// Helper to get current block dimensions based on active mode
function getCurrentBlockDimensions() {
    let dimX, dimY, dimZ; // Declare them here for clarity

    if (useDynamicBlockDim) {
        dimX = dynamicBlockDim.x;
        dimY = dynamicBlockDim.y;
        dimZ = dynamicBlockDim.z;
    } else {
        // Fixed block size logic (2D square on active plane)
        dimX = 1;
        dimY = 1;
        dimZ = 1;
        if (currentDrawingAxis === 'y') {
            dimX = currentBlockSize;
            dimZ = currentBlockSize;
        } else if (currentDrawingAxis === 'x') {
            dimY = currentBlockSize;
            dimZ = currentBlockSize;
        } else { // currentDrawingAxis === 'z'
            dimX = currentBlockSize;
            dimY = currentBlockSize;
        }
    }
    // Ensure dimensions are at least 1
    dimX = Math.max(1, dimX);
    dimY = Math.max(1, dimY);
    dimZ = Math.max(1, dimZ);

    console.log("getCurrentBlockDimensions: ", { dimX, dimY, dimZ });
    return { dimX, dimY, dimZ };
}

// NEW: Function to handle login/logout
async function loginLogout() {
    if (auth.currentUser) {
        // User is logged in, sign out
        try {
            await window.firebase.signOut(auth);
            showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info');
        } catch (error) {
            console.error("Error signing out:", error);
            showToast('Fehler beim Abmelden', `Fehler: ${error.message}`, 'error');
        }
    } else {
        // No user logged in, open auth modal
        openAuthModal();
    }
}

// NEW: Function to open the upload modal
function openUploadModal() {
    if (!currentUserId) {
        showToast('Anmeldung erforderlich', 'Bitte melden Sie sich an, um Ihr Projekt hochzuladen.', 'warning');
        return;
    }
    // Pre-fill fields if project metadata exists
    document.getElementById('uploadTitle').value = projectTitle;
    document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true;

    document.getElementById('uploadProjectModal').style.display = 'flex';
}

// NEW: Function to handle project upload to Firestore
async function uploadProjectToHub() {
    if (!currentUserId) {
        showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error');
        return;
    }

    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;

    if (!title) {
        showToast('Fehler', 'Bitte geben Sie einen Titel f√ºr Ihr Projekt ein.', 'warning');
        return;
    }

    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);

    try {
        // Generate voxel map
        const voxelMap = {};
        voxels.forEach((value, k) => {
            const [gx, gy, gz] = parseKey(k);
            voxelMap[`${gx},${gy},${gz}`] = value.color;
        });

        const settings = {
            gridSize: GRID,
            cameraPosition: cam.position.toArray(),
            cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel,
            currentDrawingAxis: currentDrawingAxis,
            currentColor: currentColor,
            presetColors: presetColors,
            activePresetIndex: activePresetIndex,
            moveSpeed: moveSpeed,
            currentBlockSize: currentBlockSize,
            dynamicBlockDim: dynamicBlockDim,
            useDynamicBlockDim: useDynamicBlockDim,
            templateImageData: templateImageData
        };

        // Compose the full Firestore document
        const firestoreDocument = {
            title: title,
            description: description,
            tags: tags,
            visibility: visibility,
            remixOf: projectRemixOf || "",
            sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`,
            downloads: 0,
            rating: 0,
            ratingCount: 0,
            verified: false,
            userId: currentUserId,
            uploaderEmail: currentUser?.email || "",
            uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "",
            timestamp: window.firebase.serverTimestamp(),

            projectData: {
                description: "",
                remixOf: "",
                sourceJsonUrl: "",
                settings: settings,
                activeDrawingLevel: activeDrawingLevel,
                activePresetIndex: activePresetIndex,
                cameraPosition: settings.cameraPosition,
                cameraQuaternion: settings.cameraQuaternion,
                currentAnchorPoint: { x: "start", y: "start", z: "start" },
                currentBlockSize: currentBlockSize,
                currentColor: currentColor,
                currentDrawingAxis: currentDrawingAxis,
                dynamicBlockDim: dynamicBlockDim,
                gridSize: GRID,
                moveSpeed: moveSpeed,
                presetColors: presetColors,
                templateImageData: null,
                useDynamicBlockDim: useDynamicBlockDim,
                voxels: voxelMap
            }
        };

        const modelsCollectionRef = window.firebase.collection(db, "models");
        const docRef = await window.firebase.addDoc(modelsCollectionRef, firestoreDocument);

        // Update local metadata
        projectTitle = title;
        projectDescription = description;
        projectTags = tags;
        projectVisibility = visibility;

        if (!projectSourceJsonUrl) {
            projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        }

        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success');
    } catch (error) {
        console.error("Error uploading project:", error);
        showToast('Fehler beim Hochladen', `Fehler: ${error.message}`, 'error');
    } finally {
        document.getElementById('uploadProjectModal').style.display = 'none';
    }
}
// NEW: Auth Modal functions
function openAuthModal() {
    document.getElementById('authModal').style.display = 'flex';
    document.getElementById('emailLoginForm').style.display = 'none'; // Hide email form initially
}

function closeAuthModal() {
    document.getElementById('authModal').style.display = 'none';
}

async function signInWithGoogle() {
    try {
        const provider = new window.firebase.GoogleAuthProvider();
        await window.firebase.signInWithPopup(auth, provider);
        showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success');
        closeAuthModal();
    } catch (error) {
        console.error("Error signing in with Google:", error);
        showToast('Anmeldefehler', `Google: ${error.message}`, 'error');
    }
}

async function signInWithGithub() {
    try {
        const provider = new window.firebase.GithubAuthProvider();
        await window.firebase.signInWithPopup(auth, provider);
        showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success');
        closeAuthModal();
    } catch (error) {
        console.error("Error signing in with GitHub:", error);
        showToast('Anmeldefehler', `GitHub: ${error.message}`, 'error');
    }
}

async function signInEmailPassword() {
    const email = document.getElementById('emailInput').value;
    const password = document.getElementById('passwordInput').value;
    try {
        await window.firebase.signInWithEmailAndPassword(auth, email, password);
        showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success');
        closeAuthModal();
    } catch (error) {
        console.error("Error signing in with Email/Password:", error);
        showToast('Anmeldefehler', `E-Mail: ${error.message}`, 'error');
    }
}

async function signUpEmailPassword() {
    const email = document.getElementById('emailInput').value;
    const password = document.getElementById('passwordInput').value;
    try {
        await window.firebase.createUserWithEmailAndPassword(auth, email, password);
        showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success');
        closeAuthModal();
    } catch (error) {
        console.error("Error signing up with Email/Password:", error);
        showToast('Registrierungsfehler', `E-Mail: ${error.message}`, 'error');
    }
}


/* ---------- Initialisierung bei Fensterladung ---------- */
window.onload = async function() { // Made async to await Firebase auth
    cvs = document.getElementById('voxelCanvas');
    containerDiv = document.getElementById('container');
    touchIndicator = document.getElementById('touch-indicator');
    distanceDisplay = document.getElementById('distanceDisplay'); // Get distance display element

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);

    // Camera
    const aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    resetCameraPosition();
    euler = new THREE.Euler(0, 0, 0, 'YXZ');

    // Renderer
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight); // Use containerDiv.clientHeight for full height
    // NEW: Set pixel ratio based on device and mobile flag
    isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (isMobile) {
        ren.setPixelRatio(Math.min(1.5, window.devicePixelRatio)); // Cap pixel ratio for mobile performance
    } else {
        ren.setPixelRatio(window.devicePixelRatio);
    }
    ren.shadowMap.enabled = true;
    ren.shadowMap.type = THREE.PCFSoftShadowMap;
  
    // Lights
    const ambientLight = new THREE.AmbientLight(0x202020);
    scene.add(ambientLight);

    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    mainDirectionalLight.position.set(10, 20, 15);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 2048;
    mainDirectionalLight.shadow.mapSize.height = 2048;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    mainDirectionalLight.shadow.camera.left = -30;
    mainDirectionalLight.shadow.camera.right = 30;
    mainDirectionalLight.shadow.camera.top = 30;
    mainDirectionalLight.shadow.camera.bottom = -30;
    mainDirectionalLight.shadow.bias = -0.0005;
    mainDirectionalLight.shadow.normalBias = 0.02;
    scene.add(mainDirectionalLight);

    fillDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillDirectionalLight.position.set(-10, 10, -15);
    scene.add(fillDirectionalLight);

    hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemisphereLight);

    updateGroundPlaneSize();

    scene.add(previewVoxelMesh);
    updatePreviewVoxel(0,0,0,false);

    // NEW: Initialize preview line InstancedMesh for measurement mode
    const previewVoxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
    const previewVoxelLineMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false });
    previewLineInstancedMesh = new THREE.InstancedMesh(previewVoxelBaseGeometry, previewVoxelLineMaterial, maxPreviewInstances);
    previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
    previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
    scene.add(previewLineInstancedMesh);


    // Helpers
    rebuildHelpers();

    // Event Listeners
    window.addEventListener('resize', onResize);
    containerDiv.addEventListener('pointerdown', onPointerDown);
    containerDiv.addEventListener('pointermove', onPointerMove);
    containerDiv.addEventListener('pointerup', onPointerUp);
    containerDiv.addEventListener('pointercancel', onPointerUp);
    containerDiv.addEventListener('pointerleave', onPointerLeave);
    containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
    // NEW: Prevent mobile scrolling on touchmove if pointers are active
    containerDiv.addEventListener('touchmove', (e) => {
        if (activePointers.size > 0) e.preventDefault();
    }, { passive: false });


    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('pointerlockchange', onPointerLockChange, false);


    // Prevent context menu on right click
    containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

    // UI event listeners
    document.getElementById('grid-size-slider').addEventListener('input', (e) => {
        const oldGrid = GRID;
        const newGrid = parseInt(e.target.value); // Get the new grid size first

        // Capture old state before clearing
        const oldVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        // Clear all existing chunks and global voxels map
        for (const chunk of chunks.values()) {
            chunk.dispose();
        }
        chunks.clear();
        voxels.clear();

        // Determine which voxels should be kept in the new grid size
        const voxelsToKeep = oldVoxelState.filter(v => 
            v.gx < newGrid && v.gy < newGrid && v.gz < newGrid
        );

        // Update GRID *after* filtering voxels, but before re-adding them
        GRID = newGrid;
        document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        localStorage.setItem('voxelEditorGridSize', GRID);
        console.log("Grid size changed to:", GRID);
        console.log("Saving 'voxelEditorGridSize' to localStorage:", localStorage.getItem('voxelEditorGridSize'));

        // Re-add kept voxels to rebuild chunks
        voxelsToKeep.forEach(v => {
            _addSingleVoxel(v.gx, v.gy, v.gz, v.color);
        });
        
        const newVoxelState = [...voxels.entries()].map(([id, data]) => {
            const [gx, gy, gz] = parseKey(id);
            return { gx, gy, gz, color: data.color };
        });

        addCommand('resizeGrid', oldVoxelState, newVoxelState, { oldGrid: oldGrid, newGrid: GRID });

        rebuildHelpers();
        resetCameraPosition();
        showToast('Gittergr√∂√üe ge√§ndert', `Gittergr√∂√üe auf ${GRID}x${GRID}x${GRID} ge√§ndert.`, 'info');
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    });
    // NEW: Add blur listener for color picker
    document.getElementById('color-picker').addEventListener('blur', (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        // No need to update preset active state here, as it's a direct edit
    });


    presetBoxes = [
        document.getElementById('color-preset-1'),
        document.getElementById('color-preset-2'),
        document.getElementById('color-preset-3')
    ];
    presetColors.forEach((color, index) => {
            const box = presetBoxes[index];
            box.value = color; // Set initial value for input type="color"
            box.addEventListener('click', (e) => {
                // Clicking the preset box sets the main color picker to its color
                // No modifier key needed for saving anymore, as it's a direct input
                setActivePreset(index);
            });
            box.addEventListener('input', (e) => {
                // Changing the color via the preset's own color picker
                savePresetColor(index, e.target.value);
            });
        });
    if (activePresetIndex !== -1) {
        setActivePreset(activePresetIndex);
    } else {
        document.getElementById('color-picker').value = currentColor;
    }


    document.getElementById('modeToggle').addEventListener('click', cycleMode);
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'flex';
    });
    document.getElementById('saveAndClearBtn').addEventListener('click', () => {
        saveJSON();
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => {
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('cancelClearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'none';
    });

    // Removed messageModal and its listeners, replaced by showToast
    // document.getElementById('messageModalCloseBtn').addEventListener('click', () => {
    //     document.getElementById('messageModal').style.display = 'none';
    // });


    document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
    document.getElementById('saveBtn').addEventListener('click', saveJSON);
    document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', loadJSON); // This now calls the refactored loadJSON
    document.getElementById('exportStlBtn').addEventListener('click', exportSTL);

    document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);

    document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
        moveSpeed = parseFloat(e.target.value);
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    });

    // Block Size buttons
    document.getElementById('block-size-1x1').addEventListener('click', () => setFixedBlockSize(1));
    document.getElementById('block-size-4x4').addEventListener('click', () => setFixedBlockSize(4));
    document.getElementById('block-size-8x8').addEventListener('click', () => setFixedBlockSize(8));
    document.getElementById('block-size-10x10').addEventListener('click', () => setFixedBlockSize(10));

    // NEW: Dynamic block size inputs and button
    const dynamicXInput = document.getElementById('dynamic-block-x');
    const dynamicYInput = document.getElementById('dynamic-block-y');
    const dynamicZInput = document.getElementById('dynamic-block-z');
    const setDynamicBlockSizeBtn = document.getElementById('setDynamicBlockSizeBtn');

    dynamicXInput.addEventListener('input', (e) => {
        dynamicBlockDim.x = parseInt(e.target.value) || 1;
        localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x);
    });
    dynamicYInput.addEventListener('input', (e) => {
        dynamicBlockDim.y = parseInt(e.target.value) || 1;
        localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y);
    });
    dynamicZInput.addEventListener('input', (e) => {
        dynamicBlockDim.z = parseInt(e.target.value) || 1;
        localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z);
    });

    setDynamicBlockSizeBtn.addEventListener('click', () => {
        setDynamicBlockDimensions();
    });

    // NEW: Add keydown listener to dynamic block inputs to prevent Tab from changing mode
    [dynamicXInput, dynamicYInput, dynamicZInput].forEach(input => {
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.stopPropagation(); // Prevent Tab from bubbling up to document.onKeyDown
            }
        });
        input.addEventListener('focus', () => {
            // When an input is focused, ensure WASD doesn't control camera
            // This is implicitly handled by pointerlock, but good to be explicit
            isPointerLocked = false;
            document.exitPointerLock(); // Exit pointer lock if active
        });
        input.addEventListener('blur', () => {
            // Return focus to canvas after blur, so WASD can control camera again
            cvs.focus();
        });
    });


    // NEW: Measure distance button
    document.getElementById('measureDistanceBtn').addEventListener('click', () => {
        currentMode = Modes.MEASURE;
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
        // Reset any ongoing measurement
        measurementStartPoint = null;
        measurementEndPoint = null;
        distanceDisplay.style.display = 'none';
        updatePreviewVoxel(0, 0, 0, false); // Hide preview when changing mode
        // Clear preview line voxels
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
    });

    // Info Box (Help) Toggle Logic
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');
    // Changed: Default to false if not explicitly true in localStorage
    let showInfoBox = localStorage.getItem('showInfoBox') === 'true'; 

    function updateInfoBoxVisibility() {
        infoBox.style.display = showInfoBox ? 'block' : 'none';
        helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
        localStorage.setItem('showInfoBox', showInfoBox);
    }
    helpToggleBtn.addEventListener('click', () => {
        showInfoBox = !showInfoBox;
        updateInfoBoxVisibility();
    });
    updateInfoBoxVisibility(); // Call on load to set initial visibility

    document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);

    document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
    document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
    document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);


    // Hamburger menu toggle for mobile
    const menuToggle = document.getElementById('menuToggle');
    menuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        if (controlsPanel.style.display === 'none' || controlsPanel.style.display === '') {
            controlsPanel.style.display = 'flex';
        } else {
            controlsPanel.style.display = 'none';
        }
    });

    // Check media query on load and resize
    const mediaQuery = window.matchMedia('(max-width: 768px)');
    function handleMediaQueryChange(e) {
        isMobile = e.matches; // Update isMobile flag
        const controlsPanel = document.getElementById('controls');
        if (e.matches) {
            controlsPanel.style.display = 'none';
            menuToggle.style.display = 'block';
        } else {
            controlsPanel.style.display = 'flex';
            menuToggle.style.display = 'none';
        }
        onResize(); // Also call onResize to adjust pixel ratio
    }
    mediaQuery.addListener(handleMediaQueryChange);
    handleMediaQueryChange(mediaQuery);

    // NEW: Mobile controls event listeners
    document.getElementById('mobile-undo').addEventListener('click', undo);
    document.getElementById('mobile-redo').addEventListener('click', redo);
    document.getElementById('mobile-save').addEventListener('click', saveJSON);
    document.getElementById('mobile-camera').addEventListener('click', () => {
        // Toggle between camera modes or reset camera view
        resetCameraPosition(); // Simple reset for now
    });
    document.getElementById('mobile-assist').addEventListener('click', () => {
        touchAssistEnabled = !touchAssistEnabled;
        const assistButton = document.getElementById('mobile-assist');
        assistButton.style.borderColor = touchAssistEnabled ? '#90caf9' : 'white';
        showToast('Touch Assist', `Magnetisches Zielen ist jetzt ${touchAssistEnabled ? 'aktiviert' : 'deaktiviert'}.`, 'info');
    });

    // Initialize UI elements with loaded values
    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    document.getElementById('color-picker').value = currentColor;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    document.getElementById('dynamic-block-x').value = dynamicBlockDim.x;
    document.getElementById('dynamic-block-y').value = dynamicBlockDim.y;
    document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;

    // Set initial active state for block size buttons
    updateBlockSizeButtonsActiveState();

    // --- Firebase Initialization and Deep Link Handling ---
    // Use the Firebase configuration provided by the environment
    const firebaseConfig = window.firebaseConfig; // Use the globally exposed config

    const app = window.firebase.initializeApp(firebaseConfig);
    auth = window.firebase.getAuth(app); // Assign to global auth
    db = window.firebase.getFirestore(app); // Assign to global db

    const loginLogoutBtn = document.getElementById('loginLogoutBtn');
    const uploadToHubBtn = document.getElementById('uploadToHubBtn');
    const userIdDisplay = document.getElementById('userIdDisplay');

    // Firebase authentication state observer
    window.firebase.onAuthStateChanged(auth, (user) => {
        if (user) {
            currentUserId = user.uid;
            loginLogoutBtn.textContent = 'Abmelden';
            userIdDisplay.textContent = `Angemeldet als: ${user.uid.substring(0, 8)}...`; // Show truncated ID
            uploadToHubBtn.style.display = 'inline-block'; // Show upload button
            // showToast('Angemeldet', `Willkommen, ${user.uid.substring(0, 8)}...`, 'success'); // Only show on initial login, not every state change
        } else {
            currentUserId = null;
            loginLogoutBtn.textContent = 'Anmelden';
            userIdDisplay.textContent = '';
            uploadToHubBtn.style.display = 'none'; // Hide upload button
            // showToast('Abgemeldet', 'Sie sind jetzt abgemeldet.', 'info'); // Only show on initial logout
        }
    });

    // Initial Firebase authentication attempt
    try {
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        if (initialAuthToken) {
            await window.firebase.signInWithCustomToken(auth, initialAuthToken);
            console.log("Firebase authenticated with custom token.");
        } else {
            // No anonymous sign-in on load, user must explicitly click "Anmelden"
            console.log("No initial auth token. User needs to sign in manually.");
        }
    } catch (error) {
        console.error("Error during Firebase authentication:", error);
        let errorMessage = 'Fehler bei der Anmeldung. Einige Funktionen sind m√∂glicherweise eingeschr√§nkt.';
        if (error.code === 'auth/custom-token-mismatch') {
            errorMessage = 'Fehler bei der Anmeldung: Ung√ºltiges Authentifizierungstoken. Bitte versuchen Sie, die Seite neu zu laden oder wenden Sie sich an den Support.';
        } else if (error.code === 'auth/admin-restricted-operation') {
            errorMessage = 'Fehler bei der Anmeldung: Anonyme Authentifizierung ist nicht aktiviert. Bitte aktivieren Sie die anonyme Authentifizierung in Ihrer Firebase-Konsole (Authentifizierung -> Anmeldemethode).';
        } else {
            errorMessage += ` Details: ${error.message}`;
        }
        showToast('Anmeldefehler', errorMessage, 'error');
    }

    // Event listeners for new buttons
    loginLogoutBtn.addEventListener('click', loginLogout);
    uploadToHubBtn.addEventListener('click', openUploadModal);

    // Upload modal event listeners
    document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
    document.getElementById('uploadCancelBtn').addEventListener('click', () => {
        document.getElementById('uploadProjectModal').style.display = 'none';
    });

    // Auth modal event listeners
    document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
    document.getElementById('signInGoogleBtn').addEventListener('click', signInWithGoogle);
    document.getElementById('signInGithubBtn').addEventListener('click', signInWithGithub);
    document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => {
        document.getElementById('emailLoginForm').style.display = 'block';
    });
    document.getElementById('emailSignInBtn').addEventListener('click', signInEmailPassword);
    document.getElementById('emailSignUpBtn').addEventListener('click', signUpEmailPassword);


    // Function to load project from modelId
    async function loadProjectFromModelId(modelId) {
        showToast('Lade Projekt', 'Lade Modell von VoxelShaper Hub...', 'info');
        try {
            // Ensure auth is ready before attempting Firestore operations
            if (!auth.currentUser) {
                console.warn("Firebase authentication not ready for Firestore operation. Attempting anonymous sign-in for load.");
                try {
                    await window.firebase.signInAnonymously(auth);
                    console.log("Signed in anonymously for load operation.");
                } catch (anonError) {
                    console.error("Failed to sign in anonymously for load:", anonError);
                    showToast('Anmeldefehler', 'Anmeldung f√ºr Ladevorgang fehlgeschlagen. Bitte manuell anmelden.', 'error');
                    return;
                }
            }

            const docRef = window.firebase.doc(db, "models", modelId);
            const docSnap = await window.firebase.getDoc(docRef);

            if (docSnap.exists()) {
                const modelData = docSnap.data();
                const projectData = modelData.projectData;
                if (projectData) {
                    // Set remixOf and sourceJsonUrl when loading from hub
                    projectRemixOf = modelId;
                    projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${modelId}`;
                    loadProjectData(projectData);
                    showToast('Projekt geladen', 'Modell erfolgreich vom Hub geladen!', 'success');
                } else {
                    showToast('Ladefehler', 'Projektdaten im Modell nicht gefunden.', 'error');
                    resetToDefaultProject();
                }
            } else {
                showToast('Ladefehler', 'Modell mit der angegebenen ID nicht gefunden.', 'error');
                resetToDefaultProject();
            }
        } catch (error) {
            console.error("Error loading project from modelId:", error);
            showToast('Ladefehler', `Fehler beim Laden des Modells: ${error.message}`, 'error');
            resetToDefaultProject();
        }
    }

    // --- Check for URL parameters on load ---
    const urlParams = new URLSearchParams(window.location.search);
    const modelId = urlParams.get('modelId');
    const encodedJson = urlParams.get('projectJson'); // Keep existing projectJson logic

    if (modelId) {
        console.log("Found modelId in URL:", modelId);
        await loadProjectFromModelId(modelId);
    } else if (encodedJson) {
        try {
            const decodedJsonString = decodeURIComponent(encodedJson);
            const projectData = JSON.parse(decodedJsonString);
            // Set remixOf and sourceJsonUrl when loading from direct JSON URL
            projectRemixOf = 'Direct JSON Load';
            projectSourceJsonUrl = window.location.href;
            loadProjectData(projectData); // Load project from URL
            showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success');
            console.log("Project loaded from URL parameter (projectJson).");
        } catch (error) {
            console.error("Error loading project from URL parameter (projectJson):", error);
            showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ung√ºltige oder besch√§digte Projektdaten. Fehler: ' + error.message, 'error');
            resetToDefaultProject(); // Reset to default if URL load fails
        }
    } else {
        // If no URL parameter, load default project or from local storage
        console.log("No projectJson or modelId URL parameter found. Loading default or local storage project.");
        // Clear source fields for a fresh start
        projectRemixOf = '';
        projectSourceJsonUrl = '';
        // Existing logic for loading from local storage or starting fresh
        // (already handled by the initial variable assignments and UI updates)
    }
    // --- END Firebase Initialization and Deep Link Handling ---

    animate();
}; // END window.onload


/* ---------- Animations-Loop ---------- */
const frustum = new THREE.Frustum();
const tempCameraMatrix = new THREE.Matrix4();
// NEW: Bounding box for frustum culling
const voxelBoundingBox = new THREE.Box3();
const voxelMin = new THREE.Vector3(-HALF, -HALF, -HALF);
const voxelMax = new THREE.Vector3(HALF, HALF, HALF);

function animate() {
    requestAnimationFrame(animate);

    // Continuous keyboard movement when pointer is locked (fly mode)
    if (isPointerLocked) {
        const forward = cam.getWorldDirection(new THREE.Vector3());
        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();
        const up = new THREE.Vector3(0, 1, 0); // World up direction

        const currentMoveSpeed = moveSpeed * 5;

        if (keyboard['w']) cam.position.addScaledVector(forward, currentMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(forward, -currentMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(right, -currentMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(right, currentMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(up, -currentMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(up, currentMoveSpeed);
    }

    // Frustum Culling for Chunks
    cam.updateMatrixWorld(); // Ensure camera matrices are up-to-date
    tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);

    for (const chunk of chunks.values()) {
        if (frustum.intersectsBox(chunk.boundingBox)) {
            chunk.instancedMesh.visible = true;
        } else {
            chunk.instancedMesh.visible = false;
        }
    }

    ren.render(scene, cam);
}

/* ---------- Mouse / Pointer Input ---------- */
let pointerIsDown = false;
let lastX, lastY;
let suppressNextTap = false; // NEW: To prevent tap after a drag gesture
let initialDragVoxelCoords = null; // NEW: Stores the starting voxel for line drawing
let voxelsAtDragStart = null; // NEW: Snapshot of voxels at the start of a drag operation


/**
 * Handles pointer down events (mouse or touch).
 * This is the starting point for voxel actions and camera control.
 *
 * @param {PointerEvent} e - The PointerEvent object.
 * @returns {void}
 */
function onPointerDown(e) {
    // Prevent context menu on right click
    if (e.button === 2) {
        e.preventDefault();
    }

    // --- Desktop: Right-click for Pointer Lock Camera Control ---
    if (e.pointerType === 'mouse' && e.button === 2) {
        // If right mouse button is pressed, we want to control the camera.
        // Immediately reset all active left-click drawing states.
        pointerIsDown = false;
        lastActionVoxelCoords = null;
        initialDragVoxelCoords = null; // Reset for line drawing
        voxelsAtDragStart = null; // Reset snapshot
        dragAxisLock = null; // Reset axis lock
        currentDragVoxels.clear(); // Clear current drag voxels
        previousFrameDragVoxels.clear(); // Clear previous frame drag voxels

        // Fix: Focus canvas *before* requesting Pointer Lock
        cvs.focus(); 
        cvs.requestPointerLock();
        return; // Important: Exit, as this pointer event is for camera control
    }

    // If pointer is locked (i.e., RMB is already controlling camera), ignore other clicks.
    if (isPointerLocked) return;

    dragAxisLock = null; // Reset axis lock on new pointer down

    // --- Touch Input Handling ---
    if (e.pointerType === 'touch') {
        if (suppressNextTap) {
            suppressNextTap = false;
            return;
        }

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.display = 'block';
        touchIndicator.style.left = `${e.clientX}px`;
        touchIndicator.style.top = `${e.clientY}px`;

        const now = performance.now();
        // Check for double-tap and drag for drawing
        if (tapCandidate && (now - tapCandidate.time < DT_MS) && (Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH)) {
            doubleTapDragActive = true;
            tapCandidate = null;
            
            // For line drawing, set the start point on double-tap drag
            // Only draw lines if not in MEASURE mode
            if (currentMode !== Modes.MEASURE) {
                // Get raw target voxel coordinates
                let rawTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                if (rawTargetVoxel) {
                    const { dimX, dimY, dimZ } = getCurrentBlockDimensions();

                    // Clamp initialDragVoxelCoords to the grid boundaries considering block size
                    rawTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, rawTargetVoxel.gx));
                    rawTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, rawTargetVoxel.gy));
                    rawTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, rawTargetVoxel.gz));

                    initialDragVoxelCoords = rawTargetVoxel; // Set clamped coordinates
                    
                    voxelsAtDragStart = new Map(voxels); // Snapshot of current voxels for line drawing
                    currentDragVoxels.clear(); // Clear current drag voxels for new drag operation
                    previousFrameDragVoxels.clear(); // Clear previous frame drag voxels

                    // Perform the initial action for the first voxel/block
                    const initialVoxels = getVoxelsOnLine(initialDragVoxelCoords, initialDragVoxelCoords, currentMode, currentColor, dimX, dimY, dimZ);
                    for (const voxel of initialVoxels) {
                        const globalKey = key(voxel.gx, voxel.gy, voxel.gz);
                        const hasVoxelBeforeDrag = voxelsAtDragStart.has(globalKey);
                        const initialColor = hasVoxelBeforeDrag ? voxelsAtDragStart.get(globalKey).color : null;

                        performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor); // Perform for 1x1x1
                        currentDragVoxels.set(globalKey, { color: currentColor, initialColor: initialColor });
                        previousFrameDragVoxels.add(globalKey); // Add to previous frame for diffing
                    }

                    lastActionVoxelCoords = { ...initialDragVoxelCoords }; // Set last action for DDA
                    initialDragVoxelWorldPos = new THREE.Vector3(initialDragVoxelCoords.gx * VS + HALF, initialDragVoxelCoords.gy * VS + HALF, initialDragVoxelCoords.gz * VS + HALF);
                    distanceDisplay.style.display = 'block';
                }
            }
        } else { // Single tap or start of multi-finger gesture
            tapCandidate = { x: e.clientX, y: e.clientY, time: now };
            initialDragVoxelCoords = null; // Reset for new tap sequence
            voxelsAtDragStart = null; // Reset snapshot
            initialDragVoxelWorldPos = null;
            currentDragVoxels.clear(); // Clear current drag voxels
            previousFrameDragVoxels.clear(); // Clear previous frame drag voxels

            if (currentMode === Modes.MEASURE) { // Handle single tap for measurement
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                if (clickedVoxel) {
                    const { dimX, dimY, dimZ } = getCurrentBlockDimensions();
                    clickedVoxel.gx = Math.max(0, Math.min(GRID - dimX, clickedVoxel.gx));
                    clickedVoxel.gy = Math.max(0, Math.min(GRID - dimY, clickedVoxel.gy));
                    clickedVoxel.gz = Math.max(0, Math.min(GRID - dimZ, clickedVoxel.gz));

                    if (measurementStartPoint === null) {
                        measurementStartPoint = { ...clickedVoxel };
                        measurementEndPoint = null; // Reset endpoint
                        distanceDisplay.style.display = 'none'; // Hide until second point
                        // Update preview line
                        previewLineVoxels = [{ gx: measurementStartPoint.gx, gy: measurementStartPoint.gy, gz: measurementStartPoint.gz }];
                        updatePreviewLineMesh();
                    } else {
                        measurementEndPoint = { ...clickedVoxel };
                        const dist = new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(
                                     new THREE.Vector3(measurementEndPoint.gx * VS, measurementEndPoint.gy * VS, measurementEndPoint.gz * VS));
                        distanceDisplay.textContent = `Distanz: ${dist.toFixed(2)} mm`;
                        distanceDisplay.style.display = 'block';
                        // Clear preview line after measurement
                        previewLineInstancedMesh.count = 0;
                        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                        previewLineVoxels = [];
                        // Prepare for next measurement
                        measurementStartPoint = null;
                        measurementEndPoint = null;
                    }
                }
                // Do not set pointerIsDown for measurement clicks
                return; // Exit, as we handled the measurement click
            }
        }

        const pointers = [...activePointers.values()];
        gestureState.initialPointerCount = pointers.length;

        if (pointers.length === 1) {
            gestureState.type = 'rotate'; // One-finger drag for rotation
            gestureState.lastMid = { x: e.clientX, y: e.clientY };
        } else if (pointers.length >= 2) {
            // Multi-finger gestures (pan/pinch)
            const [p0, p1] = pointers;
            const midX = (p0.x + p1.x) * 0.5;
            const midY = (p0.y + p1.y) * 0.5;
            const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; // Determined on first move
            gestureState.startMid = { x: midX, y: midY };
            gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = dist;
            gestureState.lastDist = dist;
        }
        initialClickPos = { x: e.clientX, y: e.clientY }; // For differentiating tap/drag
        return;
    }

    // --- Desktop: Left-click for Voxel Interaction / Measurement ---
    if (e.pointerType === 'mouse' && e.button === 0) { // Ensure it's the left mouse button
        pointerIsDown = true;
        lastX = e.clientX; // Save for preview updates
        lastY = e.clientY; // Save for preview updates
        initialClickPos = { x: e.clientX, y: e.clientY }; // For differentiating click vs. drag

        if (currentMode === Modes.MEASURE) {
            const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (clickedVoxel) {
                const { dimX, dimY, dimZ } = getCurrentBlockDimensions();
                clickedVoxel.gx = Math.max(0, Math.min(GRID - dimX, clickedVoxel.gx));
                clickedVoxel.gy = Math.max(0, Math.min(GRID - dimY, clickedVoxel.gy));
                clickedVoxel.gz = Math.max(0, Math.min(GRID - dimZ, clickedVoxel.gz));

                if (measurementStartPoint === null) {
                    measurementStartPoint = { ...clickedVoxel };
                    measurementEndPoint = null; // Reset endpoint
                    distanceDisplay.style.display = 'none'; // Hide until second point
                    // Update preview line
                    previewLineVoxels = [{ gx: measurementStartPoint.gx, gy: measurementStartPoint.gy, gz: measurementStartPoint.gz }];
                    updatePreviewLineMesh();
                } else {
                    measurementEndPoint = { ...clickedVoxel };
                    const dist = new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(
                                 new THREE.Vector3(measurementEndPoint.gx * VS, measurementEndPoint.gy * VS, measurementEndPoint.gz * VS));
                    distanceDisplay.textContent = `Distanz: ${dist.toFixed(2)} mm`;
                    distanceDisplay.style.display = 'block';
                    // Clear preview line after measurement
                    previewLineInstancedMesh.count = 0;
                    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                    previewLineVoxels = [];
                    // Prepare for next measurement
                    measurementStartPoint = null;
                    measurementEndPoint = null;
                }
            }
            pointerIsDown = false; // Measurement clicks are not "drag" actions for drawing
            return; // Exit, as we handled the measurement click
        }
        
        // Get raw target voxel coordinates from raycast
        let rawTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
        
        // Adjust rawTargetVoxel based on modifiers for initialDragVoxelCoords
        if (isControlDragging && currentMode === Modes.ADD) {
            // For Control-drag (stacking): initialDragVoxelCoords is the start point for stacking.
            // We need to project the mouse ray onto a vertical line from initialDragVoxelCoords.
            if (rawTargetVoxel) { // Only proceed if a target voxel is found
                initialDragVoxelCoords = {
                    gx: rawTargetVoxel.gx,
                    gy: rawTargetVoxel.gy,
                    gz: rawTargetVoxel.gz
                };
                dragAxisLock = 'y'; // Explicitly lock to Y-axis for stacking
            } else {
                // If no rawTargetVoxel, cannot stack.
                pointerIsDown = false;
                initialClickPos = null;
                initialDragVoxelCoords = null;
                voxelsAtDragStart = null;
                currentDragVoxels.clear();
                previousFrameDragVoxels.clear();
                distanceDisplay.style.display = 'none';
                initialDragVoxelWorldPos = null;
                console.warn("onPointerDown (Control-Drag): No valid initial target voxel found. Action suppressed.");
                return; // Exit
            }
        } else if (isShiftDragging) {
            // For Shift-drag (on active plane): Project the ray onto the active plane.
            initialDragVoxelCoords = getPointOnFixedPlane(e.clientX, e.clientY, currentDrawingAxis, activeDrawingLevel[currentDrawingAxis]);
            if (!initialDragVoxelCoords && rawTargetVoxel) { // Fallback: If plane intersection fails, but a voxel was hit
                initialDragVoxelCoords = rawTargetVoxel;
            }
            dragAxisLock = null; // No axis lock for Shift-drag, it's plane-locked initially, but can become axis-locked
        } else {
            // Normal click/drag: Use the raw target voxel directly as the initial drag point
            initialDragVoxelCoords = rawTargetVoxel;
            dragAxisLock = null; // No axis lock for free-form drag initially
        }

        console.log("onPointerDown: initialDragVoxelCoords (before clamping) =", initialDragVoxelCoords);

        if (initialDragVoxelCoords) {
            const { dimX, dimY, dimZ } = getCurrentBlockDimensions();
            // Apply clamping *once* to the initialDragVoxelCoords
            initialDragVoxelCoords.gx = Math.max(0, Math.min(GRID - dimX, initialDragVoxelCoords.gx));
            initialDragVoxelCoords.gy = Math.max(0, Math.min(GRID - dimY, initialDragVoxelCoords.gy));
            initialDragVoxelCoords.gz = Math.max(0, Math.min(GRID - dimZ, initialDragVoxelCoords.gz));

            console.log("onPointerDown: initialDragVoxelCoords (after clamping) =", initialDragVoxelCoords);

            voxelsAtDragStart = new Map(voxels); // Snapshot of current voxels
            currentDragVoxels.clear(); // Clear current drag voxels for new drag operation
            previousFrameDragVoxels.clear(); // Clear previous frame drag voxels

            // Perform the initial action for the first voxel/block
            const initialVoxels = getVoxelsOnLine(initialDragVoxelCoords, initialDragVoxelCoords, currentMode, currentColor, dimX, dimY, dimZ);
            for (const voxel of initialVoxels) {
                const globalKey = key(voxel.gx, voxel.gy, voxel.gz);
                const hasVoxelBeforeDrag = voxelsAtDragStart.has(globalKey);
                const initialColor = hasVoxelBeforeDrag ? voxelsAtDragStart.get(globalKey).color : null;

                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor); // Perform for 1x1x1
                currentDragVoxels.set(globalKey, { color: currentColor, initialColor: initialColor });
                previousFrameDragVoxels.add(globalKey); // Add to previous frame for diffing
            }

            lastActionVoxelCoords = { ...initialDragVoxelCoords }; // Set last action for DDA
            initialDragVoxelWorldPos = new THREE.Vector3(initialDragVoxelCoords.gx * VS + HALF, initialDragVoxelCoords.gy * VS + HALF, initialDragVoxelCoords.gz * VS + HALF);
            distanceDisplay.style.display = 'block';
        } else {
            pointerIsDown = false;
            initialClickPos = null;
            initialDragVoxelCoords = null;
            voxelsAtDragStart = null;
            currentDragVoxels.clear(); // Clear current drag voxels
            previousFrameDragVoxels.clear(); // Clear previous frame drag voxels
            distanceDisplay.style.display = 'none';
            initialDragVoxelWorldPos = null;
            console.warn("onPointerDown: No valid initial target voxel found. Action suppressed.");
        }
    }
}


/**
 * Handles pointer move events (mouse or touch).
 * This is used for camera control, voxel preview, and drag drawing.
 *
 * @param {PointerEvent} e - The PointerEvent object.
 * @returns {void}
 */
function onPointerMove(e) {
    e.preventDefault();

    // --- 1. Pointer Lock Camera Control (RMB) ---
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            return;
        }
        const dx = e.movementX || 0;
        const dy = e.movementY || 0;
        euler.y -= dx * rotSpeed;
        euler.x -= dy * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        return; // IMPORTANT: Exit, as the pointer is locked for camera control
    }

    // Declare dimensions here, so they are available for all branches
    const { dimX, dimY, dimZ } = getCurrentBlockDimensions();

    // --- 2. Touch Input Handling (Gestures or Drag Drawing) ---
    if (e.pointerType === 'touch') {
        if (!activePointers.has(e.pointerId)) return; // Pointer not tracked

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType }); // Update pointer position
        touchIndicator.style.left = `${e.clientX}px`;
        touchIndicator.style.top = `${e.clientY}px`;

        if (doubleTapDragActive && currentMode !== Modes.MEASURE) { // Only draw lines if not in MEASURE mode
            let rawCurrentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
            let finalTargetVoxelForDrawing = null;
            
            if (rawCurrentTargetVoxel && initialDragVoxelCoords) { // Ensure initial point for line drawing is set
                // Determine dragAxisLock only if not already set (for mobile, we might want some initial locking)
                if (dragAxisLock === null) {
                    const dx = Math.abs(rawCurrentTargetVoxel.gx - initialDragVoxelCoords.gx);
                    const dy = Math.abs(rawCurrentTargetVoxel.gy - initialDragVoxelCoords.gy);
                    const dz = Math.abs(rawCurrentTargetVoxel.gz - initialDragVoxelCoords.gz);

                    if (dx > VOXEL_DRAG_THRESHOLD || dy > VOXEL_DRAG_THRESHOLD || dz > VOXEL_DRAG_THRESHOLD) {
                        // For touch, just lock to the dominant axis
                        if (dx >= dy && dx >= dz) dragAxisLock = 'x';
                        else if (dy >= dx && dy >= dz) dragAxisLock = 'y';
                        else dragAxisLock = 'z';
                    }
                }

                if (dragAxisLock) {
                    const snappedTargetVoxel = { ...rawCurrentTargetVoxel };
                    if (dragAxisLock === 'x') {
                        snappedTargetVoxel.gy = initialDragVoxelCoords.gy;
                        snappedTargetVoxel.gz = initialDragVoxelCoords.gz;
                    } else if (dragAxisLock === 'y') {
                        // For control-drag (stacking), Y is derived from mouse, X/Z are fixed
                        snappedTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedTargetVoxel.gz = initialDragVoxelCoords.gz;
                        snappedTargetVoxel.gy = rawCurrentTargetVoxel.gy; // Use raw Y for stacking
                    } else if (dragAxisLock === 'z') {
                        snappedTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedTargetVoxel.gy = initialDragVoxelCoords.gy;
                    }
                    finalTargetVoxelForDrawing = snappedTargetVoxel;
                } else {
                    finalTargetVoxelForDrawing = rawCurrentTargetVoxel; // For preview, if no lock yet
                }

                // Apply clamping to finalTargetVoxelForDrawing
                if (finalTargetVoxelForDrawing) {
                    finalTargetVoxelForDrawing.gx = Math.max(0, Math.min(GRID - dimX, finalTargetVoxelForDrawing.gx));
                    finalTargetVoxelForDrawing.gy = Math.max(0, Math.min(GRID - dimY, finalTargetVoxelForDrawing.gy));
                    finalTargetVoxelForDrawing.gz = Math.max(0, Math.min(GRID - dimZ, finalTargetVoxelForDrawing.gz));
                }

                // Only perform drawing if an axis lock has been established
                if (dragAxisLock && finalTargetVoxelForDrawing) {
                    const voxelsToDrawThisFrame = getVoxelsOnLine(initialDragVoxelCoords, finalTargetVoxelForDrawing, currentMode, currentColor, dimX, dimY, dimZ);
                    const currentFrameVoxelsSet = new Set(voxelsToDrawThisFrame.map(v => key(v.gx, v.gy, v.gz)));

                    // Identify voxels to remove (were in previousFrameDragVoxels but not in currentFrameVoxelsSet)
                    for (const globalKey of previousFrameDragVoxels) {
                        if (!currentFrameVoxelsSet.has(globalKey)) {
                            const [gx, gy, gz] = parseKey(globalKey);
                            if (voxelsAtDragStart.has(globalKey)) {
                                _addSingleVoxel(gx, gy, gz, voxelsAtDragStart.get(globalKey).color);
                            } else {
                                _removeSingleVoxel(gx, gy, gz);
                            }
                            currentDragVoxels.delete(globalKey);
                        }
                    }

                    // Identify voxels to add/recolor (are in currentFrameVoxelsSet)
                    for (const voxel of voxelsToDrawThisFrame) {
                        const globalKey = key(voxel.gx, voxel.gy, voxel.gz);
                        if (!currentDragVoxels.has(globalKey)) {
                            const hasVoxelBeforeDrag = voxelsAtDragStart.has(globalKey);
                            const initialColor = hasVoxelBeforeDrag ? voxelsAtDragStart.get(globalKey).color : null;

                            performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor); // Perform for 1x1x1
                            currentDragVoxels.set(globalKey, { color: currentColor, initialColor: initialColor });
                        } else {
                            if (currentMode === Modes.DRAW && voxels.has(globalKey) && voxels.get(globalKey).color !== currentColor) {
                                _recolorSingleVoxel(voxel.gx, voxel.gy, voxel.gz, currentColor);
                                currentDragVoxels.get(globalKey).color = currentColor;
                            }
                        }
                    }
                    previousFrameDragVoxels = currentFrameVoxelsSet;

                    lastActionVoxelCoords = { ...finalTargetVoxelForDrawing };

                    const currentVoxelWorldPos = new THREE.Vector3(finalTargetVoxelForDrawing.gx * VS + HALF, finalTargetVoxelForDrawing.gy * VS + HALF, finalTargetVoxelForDrawing.gz * VS + HALF);
                    const distance = initialDragVoxelWorldPos.distanceTo(currentVoxelWorldPos);
                    distanceDisplay.textContent = `Distanz: ${distance.toFixed(2)} mm`;
                }
            }
            updatePreviewVoxel(0, 0, 0, false); // Hide preview during active touch drag operation
            return;
        } else if (currentMode === Modes.MEASURE && measurementStartPoint) { // Preview measurement line
            const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
            if (currentTargetVoxel) {
                const { dimX, dimY, dimZ } = getCurrentBlockDimensions(); // Still need dimensions for clamping
                currentTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, currentTargetVoxel.gx));
                currentTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, currentTargetVoxel.gy));
                currentTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, currentTargetVoxel.gz));

                const dist = new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(
                             new THREE.Vector3(currentTargetVoxel.gx * VS, currentTargetVoxel.gy * VS, currentTargetVoxel.gz * VS));
                distanceDisplay.textContent = `Distanz: ${dist.toFixed(2)} mm`;
                distanceDisplay.style.display = 'block';
                // Update preview voxels of the line
                previewLineVoxels = getVoxelsOnLine(measurementStartPoint, currentTargetVoxel, currentMode, currentColor, 1, 1, 1); // Pass 1x1x1 for preview
                updatePreviewLineMesh();
            } else {
                distanceDisplay.style.display = 'none';
                previewLineInstancedMesh.count = 0; // Clear preview line if no target
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
            }
            return; // Exit, handled by measurement preview
        }

        // If not double-tap drag or measurement, handle camera gestures. These should NOT draw cubes.
        handleGesture(); // Handles one-finger rotation, multi-finger pan/zoom
        updatePreviewVoxel(0, 0, 0, false); // Hide preview during gestures
        distanceDisplay.style.display = 'none'; // Hide distance display during camera gestures
        previewLineInstancedMesh.count = 0; // Clear preview line during camera gestures
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];
        return;
    }

    // --- 3. Desktop: Mouse Hover and Left-click Drag for Voxel Interaction / Measurement ---
    // Update lastX, lastY for preview voxel calculation when not dragging.
    lastX = e.clientX;
    lastY = e.clientY;

    const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    // The condition for isDraggingVoxelAction is crucial.
    // It is true if the pointer is down AND (it has moved significantly OR Shift/Control are held)
    const isDraggingVoxelAction = pointerIsDown && (movedDistance > MOVE_PX || isShiftDragging || isControlDragging);

    if (currentMode === Modes.MEASURE) {
        if (measurementStartPoint) {
            const tempTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (tempTargetVoxel) {
                const { dimX, dimY, dimZ } = getCurrentBlockDimensions(); // Still need dimensions for clamping
                tempTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, tempTargetVoxel.gx));
                tempTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, tempTargetVoxel.gy));
                tempTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, tempTargetVoxel.gz));

                const dist = new THREE.Vector3(measurementStartPoint.gx * VS, measurementStartPoint.gy * VS, measurementStartPoint.gz * VS).distanceTo(
                             new THREE.Vector3(tempTargetVoxel.gx * VS, tempTargetVoxel.gy * VS, tempTargetVoxel.gz * VS));
                distanceDisplay.textContent = `Distanz: ${dist.toFixed(2)} mm`;
                distanceDisplay.style.display = 'block';
                previewLineVoxels = getVoxelsOnLine(measurementStartPoint, tempTargetVoxel, currentMode, currentColor, 1, 1, 1); // Pass 1x1x1 for preview
                updatePreviewLineMesh();
            } else {
                distanceDisplay.style.display = 'none';
                previewLineInstancedMesh.count = 0;
                previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
                previewLineVoxels = [];
            }
        } else {
            const tempTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (tempTargetVoxel) {
                const { dimX, dimY, dimZ } = getCurrentBlockDimensions(); // Still need dimensions for clamping
                tempTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, tempTargetVoxel.gx));
                tempTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, tempTargetVoxel.gy));
                tempTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, tempTargetVoxel.gz));
                updatePreviewVoxel(tempTargetVoxel.gx, tempTargetVoxel.gy, tempTargetVoxel.gz, true, 1, 1, 1);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
        }
        return;
    } else { // Normal drawing/deleting/recoloring
        let rawCurrentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
        let finalTargetVoxelForDrawing = null; // This will be the actual end point for the line

        if (isDraggingVoxelAction && rawCurrentTargetVoxel && initialDragVoxelCoords) {
            // Determine dragAxisLock if not already set
            if (dragAxisLock === null) {
                const dx = Math.abs(rawCurrentTargetVoxel.gx - initialDragVoxelCoords.gx);
                const dy = Math.abs(rawCurrentTargetVoxel.gy - initialDragVoxelCoords.gy);
                const dz = Math.abs(rawCurrentTargetVoxel.gz - initialDragVoxelCoords.gz);

                if (dx > VOXEL_DRAG_THRESHOLD || dy > VOXEL_DRAG_THRESHOLD || dz > VOXEL_DRAG_THRESHOLD) {
                    // Prioritize control/shift drag if active
                    if (isControlDragging && currentMode === Modes.ADD) {
                        dragAxisLock = 'y'; // Force Y for stacking
                    } else if (isShiftDragging) {
                        // For shift-drag, lock to an axis on the active plane
                        if (currentDrawingAxis === 'y') { // Y-plane, so lock to X or Z
                            if (dx >= dz) dragAxisLock = 'x';
                            else dragAxisLock = 'z';
                        } else if (currentDrawingAxis === 'x') { // X-plane, so lock to Y or Z
                            if (dy >= dz) dragAxisLock = 'y';
                            else dragAxisLock = 'z';
                        } else { // Z-plane, so lock to X or Y
                            if (dx >= dy) dragAxisLock = 'x';
                            else dragAxisLock = 'y';
                        }
                    } else { // No modifier, free-form drag, lock to dominant axis
                        if (dx >= dy && dx >= dz) dragAxisLock = 'x';
                        else if (dy >= dx && dy >= dz) dragAxisLock = 'y';
                        else dragAxisLock = 'z';
                    }
                }
            }

            // Apply axis lock if set
            if (dragAxisLock) {
                const snappedTargetVoxel = { ...rawCurrentTargetVoxel };
                if (dragAxisLock === 'x') {
                    snappedTargetVoxel.gy = initialDragVoxelCoords.gy;
                    snappedTargetVoxel.gz = initialDragVoxelCoords.gz;
                } else if (dragAxisLock === 'y') {
                    // For control-drag, we need to ensure the Y-coordinate is derived from the mouse's vertical position
                    // relative to the initial click, while X and Z remain fixed to initialDragVoxelCoords.
                    snappedTargetVoxel.gx = initialDragVoxelCoords.gx;
                    snappedTargetVoxel.gz = initialDragVoxelCoords.gz;
                    snappedTargetVoxel.gy = rawCurrentTargetVoxel.gy; // Use raw Y for stacking
                } else if (dragAxisLock === 'z') {
                    snappedTargetVoxel.gx = initialDragVoxelCoords.gx;
                    snappedTargetVoxel.gy = initialDragVoxelCoords.gy;
                }
                finalTargetVoxelForDrawing = snappedTargetVoxel;
            } else {
                // If no axis lock yet, don't draw, just update preview based on raw target
                finalTargetVoxelForDrawing = rawCurrentTargetVoxel; // Use raw for preview, drawing happens only if lock is set
            }

            // Apply clamping to finalTargetVoxelForDrawing
            if (finalTargetVoxelForDrawing) {
                finalTargetVoxelForDrawing.gx = Math.max(0, Math.min(GRID - dimX, finalTargetVoxelForDrawing.gx));
                finalTargetVoxelForDrawing.gy = Math.max(0, Math.min(GRID - dimY, finalTargetVoxelForDrawing.gy));
                finalTargetVoxelForDrawing.gz = Math.max(0, Math.min(GRID - dimZ, finalTargetVoxelForDrawing.gz));
            }

            // Only perform drawing if an axis lock has been established
            if (dragAxisLock && finalTargetVoxelForDrawing) {
                const voxelsToDrawThisFrame = getVoxelsOnLine(initialDragVoxelCoords, finalTargetVoxelForDrawing, currentMode, currentColor, dimX, dimY, dimZ);
                const currentFrameVoxelsSet = new Set(voxelsToDrawThisFrame.map(v => key(v.gx, v.gy, v.gz)));

                    // Identify voxels to remove (were in previousFrameDragVoxels but not in currentFrameVoxelsSet)
                for (const globalKey of previousFrameDragVoxels) {
                    if (!currentFrameVoxelsSet.has(globalKey)) {
                        const [gx, gy, gz] = parseKey(globalKey);
                        if (voxelsAtDragStart.has(globalKey)) {
                            _addSingleVoxel(gx, gy, gz, voxelsAtDragStart.get(globalKey).color);
                        } else {
                            _removeSingleVoxel(gx, gy, gz);
                        }
                        currentDragVoxels.delete(globalKey);
                    }
                }

                // Identify voxels to add/recolor (are in currentFrameVoxelsSet)
                for (const voxel of voxelsToDrawThisFrame) {
                    const globalKey = key(voxel.gx, voxel.gy, voxel.gz);
                    if (!currentDragVoxels.has(globalKey)) {
                        const hasVoxelBeforeDrag = voxelsAtDragStart.has(globalKey);
                        const initialColor = hasVoxelBeforeDrag ? voxelsAtDragStart.get(globalKey).color : null;
                        performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
                        currentDragVoxels.set(globalKey, { color: currentColor, initialColor: initialColor });
                    } else {
                        if (currentMode === Modes.DRAW && voxels.has(globalKey) && voxels.get(globalKey).color !== currentColor) {
                            _recolorSingleVoxel(voxel.gx, voxel.gy, voxel.gz, currentColor);
                            currentDragVoxels.get(globalKey).color = currentColor;
                        }
                    }
                }
                previousFrameDragVoxels = currentFrameVoxelsSet;

                lastActionVoxelCoords = { ...finalTargetVoxelForDrawing }; // Update the last action for continuous feedback

                // Update distance display
                const currentVoxelWorldPos = new THREE.Vector3(finalTargetVoxelForDrawing.gx * VS + HALF, finalTargetVoxelForDrawing.gy * VS + HALF, finalTargetVoxelForDrawing.gz * VS + HALF);
                const distance = initialDragVoxelWorldPos.distanceTo(currentVoxelWorldPos);
                distanceDisplay.textContent = `Distanz: ${distance.toFixed(2)} mm`;
                distanceDisplay.style.display = 'block';
            } else {
                distanceDisplay.style.display = 'none'; // Hide if no axis lock yet
            }

            // Update preview voxel based on the potentially snapped target, even if not drawing yet
            if (finalTargetVoxelForDrawing) {
                updatePreviewVoxel(finalTargetVoxelForDrawing.gx, finalTargetVoxelForDrawing.gy, finalTargetVoxelForDrawing.gz, true, dimX, dimY, dimZ);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }

        } else { // Not dragging, just hovering
            distanceDisplay.style.display = 'none';
            let hoverTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            if (hoverTargetVoxel) {
                hoverTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, hoverTargetVoxel.gx));
                hoverTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, hoverTargetVoxel.gy));
                hoverTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, hoverTargetVoxel.gz));
                updatePreviewVoxel(hoverTargetVoxel.gx, hoverTargetVoxel.gy, hoverTargetVoxel.gz, true, dimX, dimY, dimZ);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
            }
        }
    }
}


/**
 * Handles pointer up events (mouse or touch).
 * This completes voxel actions and ends camera controls.
 *
 * @param {PointerEvent} e - The PointerEvent object.
 * @returns {void}
 */
function onPointerUp(e) {
    // Declare dimensions here for use in this function
    const { dimX, dimY, dimZ } = getCurrentBlockDimensions();

    // --- Touch Input Release ---
    if (e.pointerType === 'touch') {
        if (suppressNextTap) {
            suppressNextTap = false;
        } else if (activePointers.size === 1 && !doubleTapDragActive && currentMode !== Modes.MEASURE) {
            // This block handles single-finger taps for drawing, if it wasn't a camera rotation drag
            const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
            if (movedDistance <= TAP_DIST_TH) { // It was a tap, not a drag
                 const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
                 if (clickedVoxel) {
                     // Apply clamping directly to clickedVoxel
                     clickedVoxel.gx = Math.max(0, Math.min(GRID - dimX, clickedVoxel.gx));
                     clickedVoxel.gy = Math.max(0, Math.min(GRID - dimY, clickedVoxel.gy));
                     clickedVoxel.gz = Math.max(0, Math.min(GRID - dimZ, clickedVoxel.gz));

                     const oldState = [...voxels.entries()].map(([id, data]) => {
                         const parts = parseKey(id);
                         return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
                     });
                     // For a single tap, perform the modification for the block directly
                     const voxelsToModify = getVoxelsOnLine(clickedVoxel, clickedVoxel, currentMode, currentColor, dimX, dimY, dimZ);
                     for(const voxel of voxelsToModify) {
                         performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
                     }
                     const newState = [...voxels.entries()].map(([id, data]) => {
                         const [gx, gy, gz] = parseKey(id);
                         return { gx, gy, gz, color: data.color };
                     });
                     addCommand('batch', oldState, newState);
                 }
            }
        }
        if (doubleTapDragActive && currentMode !== Modes.MEASURE && initialDragVoxelCoords) {
            // Revert all voxels that were part of currentDragVoxels to their state before the drag started
            for (const [globalKey, data] of currentDragVoxels.entries()) {
                const [gx, gy, gz] = parseKey(globalKey);
                if (voxelsAtDragStart.has(globalKey)) {
                    _addSingleVoxel(gx, gy, gz, voxelsAtDragStart.get(globalKey).color); // Revert to original color
                } else {
                    _removeSingleVoxel(gx, gy, gz); // Remove if it was newly added in this drag
                }
            }

            const oldStateForHistory = [...voxelsAtDragStart.entries()].map(([id, data]) => {
                const [gx, gy, gz] = parseKey(id);
                return { gx, gy, gz, color: data.color };
            });

            let rawFinalTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'touch');
            let finalTargetVoxel = initialDragVoxelCoords;

            if (rawFinalTargetVoxel) {
                // Apply axis lock to the final target voxel for touch drag drawing
                if (dragAxisLock) {
                    const snappedFinalTargetVoxel = { ...rawFinalTargetVoxel };
                    if (dragAxisLock === 'x') {
                        snappedFinalTargetVoxel.gy = initialDragVoxelCoords.gy;
                        snappedFinalTargetVoxel.gz = initialDragVoxelCoords.gz;
                    } else if (dragAxisLock === 'y') {
                        snappedFinalTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedFinalTargetVoxel.gz = initialDragVoxelCoords.gz;
                        snappedFinalTargetVoxel.gy = rawFinalTargetVoxel.gy; // Use raw Y for stacking
                    } else if (dragAxisLock === 'z') {
                        snappedFinalTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedFinalTargetVoxel.gy = initialDragVoxelCoords.gy;
                    }
                    finalTargetVoxel = snappedFinalTargetVoxel;
                } else { // If no axis lock was established (e.g., too small movement), just the initial click
                    finalTargetVoxel = initialDragVoxelCoords;
                }

                // Apply clamping directly to finalTargetVoxel
                if (finalTargetVoxel) {
                    finalTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, finalTargetVoxel.gx));
                    finalTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, finalTargetVoxel.gy));
                    finalTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, finalTargetVoxel.gz));
                }
            }

            const finalVoxelsToDraw = getVoxelsOnLine(initialDragVoxelCoords, finalTargetVoxel, currentMode, currentColor, dimX, dimY, dimZ);
            for (const voxel of finalVoxelsToDraw) {
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
            }

            const newStateForHistory = [...voxels.entries()].map(([id, data]) => {
                const [gx, gy, gz] = parseKey(id);
                return { gx, gy, gz, color: data.color };
            });
            addCommand('batch', oldStateForHistory, newStateForHistory);
        }
        releasePointer(e.pointerId, e);
        // Hide distance display only if not in measurement mode or if measurement is completed
        if (currentMode !== Modes.MEASURE || (currentMode === Modes.MEASURE && measurementStartPoint === null && measurementEndPoint === null)) {
            distanceDisplay.style.display = 'none';
        }
        initialDragVoxelWorldPos = null;
        dragAxisLock = null; // Reset axis lock
        currentDragVoxels.clear(); // Clear current drag voxels
        previousFrameDragVoxels.clear(); // Clear previous frame drag voxels
        return;
    }

    // --- Desktop: Mouse Release ---
    if (e.pointerType === 'mouse') {
        if (e.button === 2) { // Right-click release
            document.exitPointerLock();
            return;
        }

        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleClick = movedDistance <= MOVE_PX;

        if (currentMode === Modes.MEASURE) {
            // Distance display should not hide immediately on mouse up in measure mode,
            // it should remain visible until a new measurement starts or mode changes.
            // Logic to reset measurementStartPoint/EndPoint is in onPointerDown.
            // Only hide preview voxel and clear preview line.
            updatePreviewVoxel(0, 0, 0, false);
            previewLineInstancedMesh.count = 0;
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            pointerIsDown = false; // Ensure pointerIsDown is reset
            return; // Exit, handled by measure mode
        }

        if (pointerIsDown && !isPointerLocked && initialDragVoxelCoords) { // Only if a drag was initiated
            // Revert all voxels that were part of currentDragVoxels to their state before the drag started
            for (const [globalKey, data] of currentDragVoxels.entries()) {
                const [gx, gy, gz] = parseKey(globalKey);
                if (voxelsAtDragStart.has(globalKey)) {
                    _addSingleVoxel(gx, gy, gz, voxelsAtDragStart.get(globalKey).color); // Revert to original color
                } else {
                    _removeSingleVoxel(gx, gy, gz); // Remove if it was newly added in this drag
                }
            }

            const oldStateForHistory = [...voxelsAtDragStart.entries()].map(([id, data]) => {
                const [gx, gy, gz] = parseKey(id);
                return { gx, gy, gz, color: data.color };
            });

            // Now, redraw the *final* line segment and capture the newState for history
            let finalVoxelsToDraw = [];
            let rawFinalTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            let finalTargetVoxel = initialDragVoxelCoords; // Default to initial if no valid target on leave or if no drag happened

            if (rawFinalTargetVoxel) {
                // Apply modifiers/axis lock to finalTargetVoxel
                if (dragAxisLock) { // Use the established axis lock
                    const snappedFinalTargetVoxel = { ...rawFinalTargetVoxel };
                    if (dragAxisLock === 'x') {
                        snappedFinalTargetVoxel.gy = initialDragVoxelCoords.gy;
                        snappedFinalTargetVoxel.gz = initialDragVoxelCoords.gz;
                    } else if (dragAxisLock === 'y') {
                        snappedFinalTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedFinalTargetVoxel.gz = initialDragVoxelCoords.gz;
                        snappedFinalTargetVoxel.gy = rawFinalTargetVoxel.gy; // Use raw Y for stacking
                    } else if (dragAxisLock === 'z') {
                        snappedFinalTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedFinalTargetVoxel.gy = initialDragVoxelCoords.gy;
                    }
                    finalTargetVoxel = snappedFinalTargetVoxel;
                } else if (wasSingleClick) { // If it was a single click, the target is just the clicked voxel
                    finalTargetVoxel = rawFinalTargetVoxel;
                } else { // If it was a drag but no axis lock was established (e.g., too small movement), treat as single voxel
                    finalTargetVoxel = initialDragVoxelCoords;
                }

                // Apply clamping directly to finalTargetVoxel
                if (finalTargetVoxel) {
                    finalTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, finalTargetVoxel.gx));
                    finalTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, finalTargetVoxel.gy));
                    finalTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, finalTargetVoxel.gz));
                }
            }

            if (finalTargetVoxel) {
                finalVoxelsToDraw = getVoxelsOnLine(initialDragVoxelCoords, finalTargetVoxel, currentMode, currentColor, dimX, dimY, dimZ);
            } else { // Should not happen if initialDragVoxelCoords was set, but for safety
                finalVoxelsToDraw = [];
            }

            for (const voxel of finalVoxelsToDraw) {
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
            }

            const newStateForHistory = [...voxels.entries()].map(([id, data]) => {
                const [gx, gy, gz] = parseKey(id);
                return { gx, gy, gz, color: data.color };
            });
            addCommand('batch', oldStateForHistory, newStateForHistory);
        }
    }

    // --- General Cleanup ---
    pointerIsDown = false;
    isControlDragging = false; // Reset Control drag on pointer up
    isShiftDragging = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialDragVoxelCoords = null; // Reset initial drag point
    voxelsAtDragStart = null; // Reset snapshot
    fixedDragPlaneParams = { level: null, axis: null }; // Always reset on pointer up
    // Hide distance display only if not in measurement mode or if measurement is completed
    if (currentMode !== Modes.MEASURE || (currentMode === Modes.MEASURE && measurementStartPoint === null && measurementEndPoint === null)) {
        distanceDisplay.style.display = 'none';
    }
    initialDragVoxelWorldPos = null;
    dragAxisLock = null; // Reset axis lock
    currentDragVoxels.clear(); // Clear current drag voxels
    previousFrameDragVoxels.clear(); // Clear previous frame drag voxels
}


function onPointerLeave(e) {
    if (e.pointerType === 'mouse') {
        // Only reset drag state if a drag was active
        if (pointerIsDown && initialDragVoxelCoords) {
            // Revert all voxels that were part of currentDragVoxels to their state before the drag started
            for (const [globalKey, data] of currentDragVoxels.entries()) {
                const [gx, gy, gz] = parseKey(globalKey);
                if (voxelsAtDragStart.has(globalKey)) {
                    _addSingleVoxel(gx, gy, gz, voxelsAtDragStart.get(globalKey).color); // Revert to original color
                } else {
                    _removeSingleVoxel(gx, gy, gz); // Remove if it was newly added in this drag
                }
            }
            // Add the final state of the drag to history as a batch
            const oldStateForHistory = [...voxelsAtDragStart.entries()].map(([id, data]) => {
                const [gx, gy, gz] = parseKey(id);
                return { gx, gy, gz, color: data.color };
            });
            // Recalculate the final line to ensure it's correct after potential mouseleave
            const { dimX, dimY, dimZ } = getCurrentBlockDimensions();
            let rawFinalTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, 'mouse');
            let finalTargetVoxel = initialDragVoxelCoords; // Default to initial if no valid target on leave

            if (rawFinalTargetVoxel) {
                // Apply modifiers/axis lock to finalTargetVoxel
                if (dragAxisLock) { // Use the established axis lock
                    const snappedFinalTargetVoxel = { ...rawFinalTargetVoxel };
                    if (dragAxisLock === 'x') {
                        snappedFinalTargetVoxel.gy = initialDragVoxelCoords.gy;
                        snappedFinalTargetVoxel.gz = initialDragVoxelCoords.gz;
                    } else if (dragAxisLock === 'y') {
                        snappedFinalTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedFinalTargetVoxel.gz = initialDragVoxelCoords.gz;
                        snappedFinalTargetVoxel.gy = rawFinalTargetVoxel.gy; // Use raw Y for stacking
                    } else if (dragAxisLock === 'z') {
                        snappedFinalTargetVoxel.gx = initialDragVoxelCoords.gx;
                        snappedFinalTargetVoxel.gy = initialDragVoxelCoords.gy;
                    }
                    finalTargetVoxel = snappedFinalTargetVoxel;
                } else { // If no axis lock was established, just use the raw target
                    finalTargetVoxel = rawFinalTargetVoxel;
                }

                // Apply clamping
                if (finalTargetVoxel) {
                    finalTargetVoxel.gx = Math.max(0, Math.min(GRID - dimX, finalTargetVoxel.gx));
                    finalTargetVoxel.gy = Math.max(0, Math.min(GRID - dimY, finalTargetVoxel.gy));
                    finalTargetVoxel.gz = Math.max(0, Math.min(GRID - dimZ, finalTargetVoxel.gz));
                }
            }

            const finalVoxelsToDraw = getVoxelsOnLine(initialDragVoxelCoords, finalTargetVoxel, currentMode, currentColor, dimX, dimY, dimZ);
            for (const voxel of finalVoxelsToDraw) {
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
            }

            const newStateForHistory = [...voxels.entries()].map(([id, data]) => {
                const [gx, gy, gz] = parseKey(id);
                return { gx, gy, gz, color: data.color };
            });
            addCommand('batch', oldStateForHistory, newStateForHistory);
        }

        pointerIsDown = false;
        lastActionVoxelCoords = null;
        initialDragVoxelCoords = null; // Reset initial drag point
        voxelsAtDragStart = null; // Reset snapshot
        updatePreviewVoxel(0, 0, 0, false);
        // Only hide distance display if not in measurement mode and a measurement is not ongoing
        if (currentMode !== Modes.MEASURE || (currentMode === Modes.MEASURE && measurementStartPoint === null && measurementEndPoint === null)) {
            distanceDisplay.style.display = 'none';
        }
        initialDragVoxelWorldPos = null;
        dragAxisLock = null; // NEW: Reset drag axis lock
        currentDragVoxels.clear(); // Clear current drag voxels
        previousFrameDragVoxels.clear(); // Clear previous frame drag voxels
    }
}

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true;
        updatePreviewVoxel(0,0,0,false);
        euler.setFromQuaternion(cam.quaternion, 'YXZ');

    } else {
        isPointerLocked = false;
    }
}

function onMouseWheel(e) {
    e.preventDefault();

    const sensitivity = 0.005;
    let zoomAmount = e.deltaY * sensitivity;

    if (e.altKey) {
        // Only allow axis lock changes in ADD mode
        if (currentMode === Modes.ADD) {
            if (e.shiftKey) {
                activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
                currentDrawingAxis = 'z';
            } else if (e.ctrlKey) {
                activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
                currentDrawingAxis = 'x';
            } else {
                activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
                currentDrawingAxis = 'y';
            }
            updateGridHelperPosition();
        } else {
            // If not in ADD mode, just zoom
            cam.position.addScaledVector(
                cam.getWorldDirection(new THREE.Vector3()),
                zoomAmount * moveSpeed * 5
            );
        }
    } else {
        const speedChange = -Math.sign(e.deltaY) * 0.01;
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed + speedChange));
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

        cam.position.addScaledVector(
            cam.getWorldDirection(new THREE.Vector3()),
            zoomAmount * moveSpeed * 5
        );
    }
}

// Helper to get a point on a specific fixed plane
function getPointOnFixedPlane(clientX, clientY, axis, level) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    let planeNormal = new THREE.Vector3();
    if (axis === 'y') planeNormal.set(0, 1, 0);
    else if (axis === 'x') planeNormal.set(1, 0, 0);
    else if (axis === 'z') planeNormal.set(0, 0, 1);
    const drawingPlane = new THREE.Plane(planeNormal, -(level * VS));

    const intersectionPoint = new THREE.Vector3();
    const intersectResult = raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

    if (intersectResult) { // Check if intersection occurred
        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        if (axis === 'y') gy = level;
        else if (axis === 'x') gx = level;
        else if (axis === 'z') gz = level;

        // Clamping here for the fixed plane
        const { dimX, dimY, dimZ } = getCurrentBlockDimensions();
        gx = Math.max(0, Math.min(GRID - dimX, gx));
        gy = Math.max(0, Math.min(GRID - dimY, gy));
        gz = Math.max(0, Math.min(GRID - dimZ, gz));

        return { gx, gy, gz };
    }
    return null;
}

// Function to set the current fixed block size
function setFixedBlockSize(size) {
    currentBlockSize = size;
    useDynamicBlockDim = false; // Deactivate dynamic mode
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
    localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);
    updateBlockSizeButtonsActiveState(); // Update active state for buttons
    
    // Trigger a mouse move to update preview voxel
    const rect = cvs.getBoundingClientRect();
    const mouseX = lastX - rect.left;
    const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: lastX,
            clientY: lastY,
            buttons: pointerIsDown ? 1 : 0
        });
        onPointerMove(mouseEvent);
    } else {
        updatePreviewVoxel(0,0,0,false);
    }
}

// NEW: Function to set dynamic block dimensions
function setDynamicBlockDimensions() {
    const x = parseInt(document.getElementById('dynamic-block-x').value);
    const y = parseInt(document.getElementById('dynamic-block-y').value);
    const z = parseInt(document.getElementById('dynamic-block-z').value);

    dynamicBlockDim.x = Math.max(1, Math.min(GRID, x));
    dynamicBlockDim.y = Math.max(1, Math.min(GRID, y));
    dynamicBlockDim.z = Math.max(1, Math.min(GRID, z));

    // Update input fields to reflect clamped values
    document.getElementById('dynamic-block-x').value = dynamicBlockDim.x;
    document.getElementById('dynamic-block-y').value = dynamicBlockDim.y;
    document.getElementById('dynamic-block-z').value = dynamicBlockDim.z;

    useDynamicBlockDim = true; // Activate dynamic mode
    localStorage.setItem('voxelEditorDynamicBlockDimX', dynamicBlockDim.x);
    localStorage.setItem('voxelEditorDynamicBlockDimY', dynamicBlockDim.y);
    localStorage.setItem('voxelEditorDynamicBlockDimZ', dynamicBlockDim.z);
    localStorage.setItem('voxelEditorUseDynamicBlockDim', useDynamicBlockDim);

    updateBlockSizeButtonsActiveState(); // Update active state for buttons

    // Trigger a mouse move to update preview voxel
    const rect = cvs.getBoundingClientRect();
    const mouseX = lastX - rect.left;
    const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: lastX,
            clientY: lastY,
            buttons: pointerIsDown ? 1 : 0
        });
        onPointerMove(mouseEvent);
    } else {
        updatePreviewVoxel(0,0,0,false);
    }
}

function getVoxelsOnLine(start, end, mode, color, dimX, dimY, dimZ) {
    if (!Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        console.error("getVoxelsOnLine: Invalid (non-finite) start or end coordinates.", start, end);
        return [];
    }

    const voxelsOnLineSet = new Set(); // Use a Set to ensure uniqueness of voxel keys

    let x1 = start.gx;
    let y1 = start.gy;
    let z1 = start.gz;
    let x2 = end.gx;
    let y2 = end.gy;
    let z2 = end.gz;

    let dx = Math.abs(x2 - x1);
    let dy = Math.abs(y2 - y1);
    let dz = Math.abs(z2 - z1);

    let sx = (x1 < x2) ? 1 : -1;
    let sy = (y1 < y2) ? 1 : -1;
    let sz = (z1 < z2) ? 1 : -1;

    let dm = Math.max(dx, dy, dz);

    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm;
    let p2 = 2 * dz - dm;

    for (let i = 0; i <= dm; i++) {
        // Add current 1x1x1 voxel and expand it to block dimensions
        for (let xOffset = 0; xOffset < dimX; xOffset++) {
            for (let yOffset = 0; yOffset < dimY; yOffset++) {
                for (let zOffset = 0; zOffset < dimZ; zOffset++) {
                    const currentVoxelX = x + xOffset;
                    const currentVoxelY = y + yOffset;
                    const currentVoxelZ = z + zOffset;

                    // Clamp to grid boundaries
                    const clampedX = Math.max(0, Math.min(GRID - 1, currentVoxelX));
                    const clampedY = Math.max(0, Math.min(GRID - 1, currentVoxelY));
                    const clampedZ = Math.max(0, Math.min(GRID - 1, currentVoxelZ));

                    voxelsOnLineSet.add(key(clampedX, clampedY, clampedZ));
                }
            }
        }

        if (dm === dx) {
            y += sy * (p1 > 0 ? 1 : 0);
            p1 += 2 * dy;
            z += sz * (p2 > 0 ? 1 : 0);
            p2 += 2 * dz;
        } else if (dm === dy) {
            x += sx * (p1 > 0 ? 1 : 0);
            p1 += 2 * dx;
            z += sz * (p2 > 0 ? 1 : 0);
            p2 += 2 * dz;
        } else { // dm === dz
            x += sx * (p1 > 0 ? 1 : 0);
            p1 += 2 * dy;
            y += sy * (p2 > 0 ? 1 : 0);
            p2 += 2 * dx;
        }

        if (dm === dx) {
            x += sx;
        } else if (dm === dy) {
            y += sy;
        } else { // dm === dz
            z += sz;
        }
    }

    // Convert Set of keys back to array of objects
    return Array.from(voxelsOnLineSet).map(k => {
        const [gx, gy, gz] = parseKey(k);
        return { gx, gy, gz, color: color };
    });
}


// NEW: Update the InstancedMesh for the preview line in measurement mode
function updatePreviewLineMesh() {
    previewLineInstancedMesh.count = 0; // Reset count
    const tempMatrix = new THREE.Matrix4();

    for (let i = 0; i < previewLineVoxels.length && i < maxPreviewInstances; i++) {
        const voxel = previewLineVoxels[i];
        dummy.position.set(voxel.gx * VS + HALF, voxel.gy * VS + HALF, voxel.gz * VS + HALF);
        dummy.updateMatrix();
        previewLineInstancedMesh.setMatrixAt(i, dummy.matrix);
        // Set a distinct color for the preview line
        previewLineInstancedMesh.instanceColor.setXYZ(i, 0, 1, 0); // Green
        previewLineInstancedMesh.count++;
    }
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineInstancedMesh.instanceColor.needsUpdate = true;
}


/* ---------- Keyboard Input ---------- */
const keyboard = {};
function onKeyDown(e) {
    keyboard[e.key] = true;

    if (e.key === 'Shift') {
        isShiftDragging = true;
    }
    if (e.key === 'Control' || e.metaKey) {
        isControlDragging = true;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
    }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) {
        e.preventDefault();
        redo();
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
        // Prevent default behavior to avoid bookmarking on Ctrl+D
    }

    // Tab handling moved to cycleMode and input event listeners
    if (e.key === 'Tab') {
        // Prevent default behavior only if not inside a dynamic block input
        const activeElement = document.activeElement;
        if (!(activeElement && activeElement.classList.contains('dynamic-block-input'))) {
            e.preventDefault();
            cycleMode();
        }
    }

    switch (e.key) {
        case '1': setActivePreset(0); break;
        case '2': setActivePreset(1); break;
        case '3': setActivePreset(2); break;
    }
}

function onKeyUp(e) {
    keyboard[e.key] = false;

    if (e.key === 'Shift') {
        isShiftDragging = false;
    }
    if (e.key === 'Control' || e.metaKey) {
        isControlDragging = false;
    }
}

function updateBlockSizeButtonsActiveState() {
    // Remove active class from all fixed size buttons
    document.querySelectorAll('.block-size-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // Remove active class from dynamic block size button
    document.getElementById('setDynamicBlockSizeBtn').classList.remove('active');

    if (useDynamicBlockDim) {
        document.getElementById('setDynamicBlockSizeBtn').classList.add('active');
    } else {
        // Add active class to the currently selected fixed size button
        const activeBtn = document.getElementById(`block-size-${currentBlockSize}x${currentBlockSize}`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        } else {
            // If currentBlockSize doesn't match a fixed button, default to 1x1x1
            document.getElementById('block-size-1x1').classList.add('active');
            currentBlockSize = 1;
            localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
        }
    }
}

</script>
</body>
</html>
