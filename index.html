<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelShaper - Community 3D Modelle</title>
    <!-- DaisyUI & Tailwind CSS -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome für Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- KEIN BENUTZERDEFINIERTES CSS HIER -->
</head>
<body class="bg-base-100 min-h-screen text-base-content">
    <!-- Navigation -->
    <div class="navbar bg-base-200 border-b border-base-content/20 px-4 py-3">
        <div class="flex-1">
            <!-- VoxelShaper Logo mit Tailwind-Klassen -->
            <a href="#" class="text-2xl font-black text-blue-400 tracking-tight">
                <i class="fas fa-cube mr-2"></i>VoxelShaper
            </a>
            <div class="hidden md:flex ml-10">
                <a href="#" class="btn btn-ghost btn-sm">Entdecken</a>
                <a href="#" class="btn btn-ghost btn-sm">Beliebt</a>
                <a href="#" class="btn btn-ghost btn-sm">Neu</a>
                <a href="#" class="btn btn-ghost btn-sm">Kategorien</a>
            </div>
        </div>
        <div class="flex-none gap-4">
            <!-- Theme Toggle Button mit offiziellen DaisyUI SVGs (Größe angepasst) -->
            <label class="swap swap-rotate btn btn-ghost btn-circle">
                <!-- this hidden checkbox controls the state -->
                <input type="checkbox" id="theme-toggle" />

                <!-- sun icon -->
                <svg
                    class="swap-on h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" />
                </svg>

                <!-- moon icon -->
                <svg
                    class="swap-off h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" />
                </svg>
            </label>
            
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" class="btn btn-ghost btn-circle">
                    <i class="fas fa-bell text-xl"></i>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-64 mt-4">
                    <li class="text-center py-4 text-base-content/60">Keine Benachrichtigungen</li>
                </ul>
            </div>
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" id="user-menu-button" class="btn btn-ghost btn-circle avatar placeholder">
                    <!-- Geändert zu Font Awesome Benutzer-Icon für bessere Darstellung -->
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <span><i class="fas fa-user text-lg"></i></span>
                    </div>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-52 mt-4">
                    <li id="login-button"><a><i class="fas fa-sign-in-alt mr-2"></i>Anmelden</a></li>
                    <li id="profile-button" class="hidden"><a><i class="fas fa-user mr-2"></i>Profil</a></li>
                    <li id="logout-button" class="hidden"><a><i class="fas fa-sign-out-alt mr-2"></i>Abmelden</a></li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Hauptinhalt -->
    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold">Community-Modelle</h1>
            <button id="upload-model-button" class="btn btn-primary">
                <i class="fas fa-upload mr-2"></i>Modell hochladen
            </button>
        </div>

        <!-- Filter & Sortierung -->
        <div class="bg-base-200 rounded-lg p-4 mb-6">
            <div class="flex flex-wrap items-center gap-4">
                <div>
                    <span class="text-base-content/60 mr-2">Filter:</span>
                    <select class="select select-bordered select-sm bg-base-300 border-base-content/20">
                        <option>Alle Kategorien</option>
                        <option>Spielzeug</option>
                        <option>Dekoration</option>
                        <option>Funktional</option>
                        <option>Kunst</option>
                    </select>
                </div>
                <div>
                    <span class="text-base-content/60 mr-2">Sortieren:</span>
                    <select class="select select-bordered select-sm bg-base-300 border-base-content/20">
                        <option>Beliebteste</option>
                        <option>Neueste</option>
                        <option>Am besten bewertet</option>
                    </select>
                </div>
                <div class="flex items-center">
                    <span class="text-base-content/60 mr-2">Lizenz:</span>
                    <div class="flex gap-2">
                        <button class="btn btn-xs">Alle</button>
                        <button class="btn btn-xs">CC BY</button>
                        <button class="btn btn-xs">CC BY-SA</button>
                        <button class="btn btn-xs">CC0</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modelle Grid -->
        <div id="models-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            <!-- Modelle werden hier dynamisch geladen -->
        </div>

        <!-- Ladeindikator und "Mehr laden"-Button -->
        <div id="load-more-container" class="flex flex-col items-center justify-center mt-10">
            <span id="loading-spinner" class="loading loading-spinner loading-lg text-primary hidden"></span>
            <button id="load-more-button" class="btn btn-primary mt-4 hidden">
                Mehr Modelle laden
            </button>
            <p id="no-more-models" class="text-base-content/60 mt-4 hidden">Keine weiteren Modelle verfügbar.</p>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer p-10 bg-base-300 text-base-content mt-16">
        <div class="container mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                <div>
                    <h3 class="footer-title text-base-content">VoxelShaper</h3>
                    <p class="mt-4">Die Community für 3D-Voxelmodelle. Teile, entdecke und drucke einzigartige Kreationen.</p>
                    <div class="flex gap-4 mt-4">
                        <a href="#"><i class="fab fa-discord text-xl"></i></a>
                        <a href="#"><i class="fab fa-twitter text-xl"></i></a>
                        <a href="#"><i class="fab fa-instagram text-xl"></i></a>
                        <a href="#"><i class="fab fa-github text-xl"></i></a>
                    </div>
                </div>
                <div>
                    <h3 class="footer-title">Ressourcen</h3>
                    <a class="link link-hover mt-4">Blog</a>
                    <a class="link link-hover">Tutorials</a>
                    <a class="link link-hover">Dokumentation</a>
                    <a class="link link-hover">API</a>
                </div>
                <div>
                    <h3 class="footer-title">Community</h3>
                    <a class="link link-hover mt-4">Forum</a>
                    <a class="link link-hover">Events</a>
                    <a class="link link-hover">Mitwirkende</a>
                    <a class="link link-hover">Partner</a>
                </div>
                <div>
                    <h3 class="footer-title">Rechtliches</h3>
                    <a class="link link-hover mt-4">AGB</a>
                    <a class="link link-hover">Datenschutz</a>
                    <a class="link link-hover">Lizenzierung</a>
                    <a class="link link-hover">Cookie-Richtlinie</a>
                </div>
            </div>
            <div class="border-t border-base-content/20 mt-12 pt-6 text-center">
                <p>© 2023 VoxelShaper. Alle Rechte vorbehalten.</p>
            </div>
        </div>
    </footer>

    <!-- Firebase Login Modal -->
    <dialog id="auth-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg text-center">Anmeldung bei VoxelShaper</h3>
            <p class="py-4 text-center">Melde dich an, um Modelle zu bewerten, herunterzuladen und eigene Kreationen zu teilen.</p>
            <div class="modal-action flex flex-col items-center w-full">
                <form method="dialog" class="w-full">
                    <div class="flex flex-col gap-3 w-full">
                        <input id="email-input" type="email" placeholder="E-Mail" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="email" />
                        <input id="password-input" type="password" placeholder="Passwort" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="current-password" />
                        <button id="firebase-login" class="btn btn-primary w-full">
                            <i class="fas fa-sign-in-alt mr-2"></i> Anmelden
                        </button>
                        <button id="firebase-signup" class="btn btn-secondary w-full">
                            <i class="fas fa-user-plus mr-2"></i> Registrieren
                        </button>
                        <div class="divider text-base-content/60">ODER</div>
                        <!-- Removed text-white from Google Login button to rely on DaisyUI theme -->
                        <button id="google-login" class="btn btn-info w-full">
                            <i class="fab fa-google mr-2"></i> Mit Google anmelden
                        </button>
                        <!-- Changed GitHub Login button classes to use DaisyUI neutral colors -->
                        <button id="github-login" class="btn w-full bg-neutral hover:bg-neutral-focus text-neutral-content border-none">
                            <i class="fab fa-github mr-2"></i> Mit GitHub anmelden
                        </button>
                        <button class="btn btn-outline w-full" onclick="document.getElementById('auth-modal').close()">Abbrechen</button>
                    </div>
                    <p id="auth-error-message" class="text-error text-sm mt-4 text-center hidden"></p>
                </form>
            </div>
        </div>
    </dialog>

    <!-- Upload Model Modal -->
    <dialog id="upload-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Modell hochladen</h3>
            <p class="py-4">Lade dein 3D-Voxelmodell hoch und teile es mit der Community.</p>
            <div class="modal-action">
                <form method="dialog" class="w-full">
                    <!-- Step 1: Project JSON Upload -->
                    <div id="json-upload-step" class="flex flex-col gap-3">
                        <label for="project-json-input" class="label">
                            <span class="label-text text-base-content/60">1. Projektdatei (.json) hochladen (Pflichtfeld)</span>
                        </label>
                        <input id="project-json-input" type="file" class="file-input file-input-bordered w-full bg-base-300 border-base-content/20" accept=".json" required />
                        <p id="json-error-message" class="text-error text-sm mt-2 hidden"></p>
                        <button type="button" id="load-json-button" class="btn btn-primary w-full mt-4">
                            <i class="fas fa-file-upload mr-2"></i> Projektdatei laden
                        </button>
                    </div>

                    <!-- Step 2: Model Details (initially hidden) -->
                    <div id="model-details-step" class="flex flex-col gap-3 mt-6 hidden">
                        <div class="divider text-base-content/60">2. Modell Details</div>
                        <input id="model-title-input" type="text" placeholder="Modell Titel" class="input input-bordered w-full bg-base-300 border-base-content/20" required />
                        <textarea id="model-description-input" placeholder="Modell Beschreibung" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24"></textarea>
                        
                        <!-- Removed 3D Model File Input -->
                        
                        <input id="remix-of-input" type="text" placeholder="Remix von (optional)" class="input input-bordered w-full bg-base-300 border-base-content/20" />
                        <!-- sourceJsonUrlInput is no longer needed as a URL input if JSON is embedded -->
                        <!-- <input id="source-json-url-input" type="url" placeholder="Source JSON URL (optional)" class="input input-bordered w-full bg-base-300 border-base-content/20" readonly /> -->
                        <input id="tags-input" type="text" placeholder="Tags (Komma-getrennt, z.B. Tier, Auto)" class="input input-bordered w-full bg-base-300 border-base-content/20" />
                        
                        <select id="visibility-select" class="select select-bordered w-full bg-base-300 border-base-content/20">
                            <option value="public">Öffentlich</option>
                            <option value="private">Privat</option>
                        </select>

                        <button id="upload-submit-button" class="btn btn-primary w-full mt-4" disabled>
                            <i class="fas fa-upload mr-2"></i> Modell hochladen
                        </button>
                    </div>
                    <button class="btn btn-outline w-full mt-4" onclick="document.getElementById('upload-modal').close()">Abbrechen</button>
                    <p id="upload-error-message" class="text-error text-sm mt-2 hidden"></p>
                    <p id="upload-success-message" class="text-success text-sm mt-2 hidden"></p>
                    <p class="text-warning text-sm mt-2">Hinweis: Große JSON-Dateien (über 1 MB) können beim Hochladen fehlschlagen, da sie direkt im Firestore-Dokument gespeichert werden.</p>
                </form>
            </div>
        </div>
    </dialog>

    <!-- Debugging Div for Three.js Background Color (now hidden by default) -->
    <div id="debug-threejs-bg" class="fixed top-20 left-4 p-2 rounded-md shadow-lg text-xs z-50 border border-base-content/20 hidden" style="width: 100px; height: 50px; background-color: black; display: none !important;">
        <span class="text-base-content">Three.js BG</span>
    </div>

    <!-- Three.js Libraries (non-module imports) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <!-- OrbitControls non-module version -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { 
            getAuth, 
            setPersistence,
            browserLocalPersistence, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword, 
            onAuthStateChanged,
            signOut,
            GoogleAuthProvider, 
            GithubAuthProvider,
            signInWithPopup, 
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            serverTimestamp,
            query, 
            limit, 
            getDocs, 
            startAfter,
            where,
            doc, 
            getDoc,
            updateDoc,
            // orderBy // Removed orderBy import as it's no longer used in the query to avoid index issues
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";


        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA",
            authDomain: "voxelshaper.firebaseapp.com", 
            projectId: "voxelshaper",
            storageBucket: "voxelshaper.firebasestorage.app", 
            messagingSenderId: "1053689247573",
            appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
            measurementId: "G-QJ5CNKZ5DR"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        let currentUser = null;
        let currentUserId = null;
        let userStatusDisplay = null;
        // Variables for infinite scrolling
        const MODELS_PER_LOAD = 8;
        let lastVisible = null;
        let isLoadingModels = false; 

        // UI Elemente
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const profileButton = document.getElementById('profile-button');
        const userMenuButton = document.getElementById('user-menu-button');
        const authModal = document.getElementById('auth-modal');
        const firebaseLoginButton = document.getElementById('firebase-login');
        const firebaseSignupButton = document.getElementById('firebase-signup');
        const googleLoginButton = document.getElementById('google-login'); 
        const githubLoginButton = document.getElementById('github-login'); 
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const authErrorMessage = document.getElementById('auth-error-message');
        const htmlElement = document.documentElement; // Get the html element
        const themeToggle = document.getElementById('theme-toggle'); // Theme Toggle Element

        // Upload Modal Elemente
        const uploadModelButton = document.getElementById('upload-model-button');
        const uploadModal = document.getElementById('upload-modal');
        const jsonUploadStep = document.getElementById('json-upload-step'); 
        const modelDetailsStep = document.getElementById('model-details-step'); 
        const loadJsonButton = document.getElementById('load-json-button'); 
        const jsonErrorMessage = document.getElementById('json-error-message'); 

        const modelTitleInput = document.getElementById('model-title-input');
        const modelDescriptionInput = document.getElementById('model-description-input');
        const projectJsonInput = document.getElementById('project-json-input'); 
        const remixOfInput = document.getElementById('remix-of-input'); 
        const tagsInput = document.getElementById('tags-input'); 
        const visibilitySelect = document.getElementById('visibility-select'); 
        const uploadSubmitButton = document.getElementById('upload-submit-button');
        const uploadErrorMessage = document.getElementById('upload-error-message');
        const uploadSuccessMessage = document.getElementById('upload-success-message');

        // Modellelemente für die endlose Liste
        const modelsGrid = document.getElementById('models-grid');
        const loadMoreButton = document.getElementById('load-more-button');
        const loadingSpinner = document.getElementById('loading-spinner');
        const noMoreModelsMessage = document.getElementById('no-more-models');

        // Auth Providers
        const googleProvider = new GoogleAuthProvider();
        const githubProvider = new GithubAuthProvider(); 

        // Variable to store parsed project JSON data
        let currentProjectJsonData = null;
        let currentProjectJsonFile = null; 

        // Funktion zum Anzeigen von Nachrichten (Fehler/Erfolg)
        function showMessage(element, message, isError = true) {
            element.textContent = message;
            element.classList.remove('hidden');
            if (isError) {
                element.classList.remove('text-success'); // Use DaisyUI text-success class
                element.classList.add('text-error'); // Use DaisyUI text-error class
            } else {
                element.classList.remove('text-error');
                element.classList.add('text-success');
            }
        }

        // Funktion zum Verbergen von Nachrichten
        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
        }

        // UI basierend auf Login-Status aktualisieren
        function updateUI(user) {
            if (user) {
                loginButton.classList.add('hidden');
                logoutButton.classList.remove('hidden');
                profileButton.classList.remove('hidden');
                
                // Display user's profile picture or initial
                let avatarContent;
                if (user.photoURL) {
                    avatarContent = `<img src="${user.photoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
                } else if (user.email) {
                    avatarContent = `<span class="text-white">${user.email.charAt(0).toUpperCase()}</span>`;
                } else {
                    // Geändert zu Font Awesome Benutzer-Icon für unbekannte Benutzer
                    avatarContent = `<span class="text-white flex items-center justify-center w-full h-full"><i class="fas fa-user text-lg"></i></span>`;
                }

                userMenuButton.innerHTML = `
                    <div class="avatar">
                        <div class="w-10 rounded-full bg-primary flex items-center justify-center">
                            ${avatarContent}
                        </div>
                    </div>
                `;
            } else {
                loginButton.classList.remove('hidden');
                logoutButton.classList.add('hidden');
                profileButton.classList.add('hidden');
                
                userMenuButton.innerHTML = `
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <span><i class="fas fa-user text-lg"></i></span> <!-- Geändert zu Font Awesome Benutzer-Icon -->
                    </div>
                `;
            }
        }

        // Helper function to get computed color from DaisyUI CSS variable for Three.js background
        function getDaisyUICSSColorForThreeJS(selectedTheme) {
            const originalTheme = htmlElement.getAttribute('data-theme');
            htmlElement.setAttribute('data-theme', selectedTheme); // Apply the new theme

            // Force a reflow/recalculation to ensure styles are applied
            // Accessing offsetHeight of the body element forces the browser to re-calculate styles
            void document.body.offsetHeight; 

            // Now get the computed background color of the body, which should reflect the new theme
            const computedColor = getComputedStyle(document.body).backgroundColor;
            
            // Restore the original theme
            htmlElement.setAttribute('data-theme', originalTheme); 

            let hexColor = '#000000'; // Default fallback

            // Use a temporary canvas to get reliable RGB values from any CSS color string
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = computedColor;
            ctx.fillRect(0, 0, 1, 1);
            const pixelData = ctx.getImageData(0, 0, 1, 1).data;
            
            // Convert RGBA to Hex
            const toHex = (c) => c.toString(16).padStart(2, '0');
            hexColor = `#${toHex(pixelData[0])}${toHex(pixelData[1])}${toHex(pixelData[2])}`;

            return hexColor;
        }

        // Three.js Voxel Renderer für Vorschaukarten
        class VoxelPreviewRenderer {
            constructor(canvasElement, voxelsData, gridSize = 10, backgroundColor) { 
                this.canvas = canvasElement;
                this.voxelsData = voxelsData; 
                this.gridSize = gridSize;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null; 
                this.animationFrameId = null;
                this.pivotGroup = null; 
                this.instancedMesh = null; 
                this.isAnimating = false; 
                this.autoRotateEnabled = false; // New property for conditional auto-rotation
                this.backgroundColor = backgroundColor; // Store dynamic background color

                // New properties for custom interaction
                this.isDragging = false;
                this.lastMouseX = 0;
                this.isTouching = false;
                this.lastTouchX = 0;
                this.lastTouchY = 0; // Added for calculating vertical touch movement

                this.init();
            }

            init() {
                this.scene = new THREE.Scene();
                // Use the passed background color for the scene
                this.scene.background = new THREE.Color(this.backgroundColor); 

                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true }); 

                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000); 

                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0x606060); 
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
                directionalLight.position.set(1, 1, 1).normalize();
                this.scene.add(directionalLight);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true; 
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 500;
                this.controls.enabled = false; // Disable OrbitControls for direct interaction
                this.controls.enableZoom = false; // Disable mouse wheel zoom
                this.controls.update(); 

                this.loadVoxels(); 

                // Add new event listeners directly to the canvas for custom drag/swipe
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('mouseout', this.onMouseUp.bind(this)); // Stop dragging if mouse leaves canvas

                // Use passive: true for touch events to not block page scrolling
                this.canvas.addEventListener('touchstart', this.onTouchStart.bind(this), { passive: true }); 
                this.canvas.addEventListener('touchmove', this.onTouchMove.bind(this), { passive: true }); 
                this.canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
                this.canvas.addEventListener('touchcancel', this.onTouchEnd.bind(this));
            }

            loadVoxels() {
                console.log("VoxelPreviewRenderer loadVoxels - actual voxelsData:", this.voxelsData);
                const voxelKeys = Object.keys(this.voxelsData || {}); 
                
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.traverse((object) => {
                        if (object.isMesh) {
                            object.geometry.dispose();
                            object.material.dispose();
                        }
                    });
                    this.pivotGroup.clear();
                    this.pivotGroup = null;
                }
                this.instancedMesh = null; 

                if (!this.voxelsData || voxelKeys.length === 0) {
                    console.warn("Keine Voxeldaten zum Laden für die Vorschau. Szene wird geleert.");
                    this.canvas.style.display = 'none'; 
                    const parentDiv = this.canvas.parentElement;
                    let messageDiv = parentDiv.querySelector('.preview-message');
                    if (!messageDiv) {
                        messageDiv = document.createElement('div');
                        messageDiv.className = 'preview-message absolute inset-0 flex items-center justify-center text-base-content/60 text-sm';
                        parentDiv.appendChild(messageDiv);
                    }
                    messageDiv.textContent = 'Keine Vorschau verfügbar (keine Voxeldaten)';
                    return; 
                } else {
                    this.canvas.style.display = 'block'; 
                    const parentDiv = this.canvas.parentElement;
                    const messageDiv = parentDiv.querySelector('.preview-message');
                    if (messageDiv) {
                        messageDiv.remove(); 
                    }
                }

                const voxelGeometry = new THREE.BoxGeometry(1, 1, 1);
                const dummy = new THREE.Object3D();
                const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });

                const maxInstances = voxelKeys.length;
                const instancedMesh = new THREE.InstancedMesh(voxelGeometry, meshMaterial, maxInstances);
                instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstances * 3), 3);
                instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                
                let instanceId = 0;
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (const key of voxelKeys) { 
                    const parts = key.split(',').map(Number);
                    if (parts.length === 3) {
                        const [x, y, z] = parts;
                        const colorHex = this.voxelsData[key];
                        const color = new THREE.Color(colorHex);

                        dummy.position.set(x + 0.5, y + 0.5, z + 0.5); 
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(instanceId, dummy.matrix);
                        instancedMesh.instanceColor.setXYZ(instanceId, color.r, color.g, color.b);
                        instanceId++;

                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        maxZ = Math.max(maxZ, z);
                    }
                }
                instancedMesh.count = instanceId;
                instancedMesh.instanceMatrix.needsUpdate = true;
                instancedMesh.instanceColor.needsUpdate = true;
                
                this.pivotGroup = new THREE.Group();
                this.scene.add(this.pivotGroup); 

                const modelBoundingBox = new THREE.Box3(
                    new THREE.Vector3(minX, minY, minZ),
                    new THREE.Vector3(maxX + 1, maxY + 1, maxZ + 1) 
                );
                const modelCenter = new THREE.Vector3();
                modelBoundingBox.getCenter(modelCenter);

                instancedMesh.position.sub(modelCenter);
                this.pivotGroup.add(instancedMesh); 
                this.instancedMesh = instancedMesh; 

                const centeredModelTarget = new THREE.Vector3(0, 0, 0);

                const boundingSphere = new THREE.Sphere();
                modelBoundingBox.getBoundingSphere(boundingSphere);
                const radius = boundingSphere.radius;

                const fov = this.camera.fov * (Math.PI / 180); 
                let distance = radius / Math.tan(fov / 2);

                distance *= 1.2; 

                const cameraOffset = new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance);
                this.camera.position.copy(centeredModelTarget).add(cameraOffset); 
                this.camera.lookAt(centeredModelTarget); 
                this.camera.updateProjectionMatrix();

                this.controls.target.copy(centeredModelTarget);
                this.controls.update();
                this.renderer.render(this.scene, this.camera); 
            }

            startAnimation() {
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animationFrameId = requestAnimationFrame(this.animate.bind(this)); 
                }
            }

            stopAnimation() {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.isAnimating = false;
                }
            }

            // New methods to control automatic rotation
            startAutoRotation() {
                this.autoRotateEnabled = true;
            }

            stopAutoRotation() {
                this.autoRotateEnabled = false;
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
                
                if (this.controls) {
                    this.controls.update();
                }

                this.renderer.render(this.scene, this.camera);

                // Apply auto-rotation only if enabled AND not currently dragging/touching
                if (this.autoRotateEnabled && this.pivotGroup && !this.isDragging && !this.isTouching) { 
                    const rotationSpeed = 0.005;
                    this.pivotGroup.rotation.y += rotationSpeed;
                }
            }

            dispose() {
                this.stopAnimation(); 
                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        object.geometry.dispose();
                        object.material.dispose();
                        // Dispose of instancedMesh's geometry and material
                        if (this.instancedMesh) {
                            this.instancedMesh.geometry.dispose();
                            this.instancedMesh.material.dispose();
                        }
                    } 
                });
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.clear(); 
                }
                this.renderer.dispose();
                if (this.controls) {
                    this.controls.dispose();
                }

                // Remove event listeners to prevent memory leaks
                this.canvas.removeEventListener('mousedown', this.onMouseDown);
                this.canvas.removeEventListener('mousemove', this.onMouseMove);
                this.canvas.removeEventListener('mouseup', this.onMouseUp);
                this.canvas.removeEventListener('mouseout', this.onMouseUp);

                this.canvas.removeEventListener('touchstart', this.onTouchStart);
                this.canvas.removeEventListener('touchmove', this.onTouchMove);
                this.canvas.removeEventListener('touchend', this.onTouchEnd);
                this.canvas.removeEventListener('touchcancel', this.onTouchEnd);
            }

            // Custom mouse event handlers for rotation
            onMouseDown(event) {
                this.isDragging = true;
                this.lastMouseX = event.clientX;
                this.stopAutoRotation(); // Stop auto-rotation when user starts manual interaction
                // No preventDefault here, allow browser to handle initial click
            }

            onMouseMove(event) {
                if (this.isDragging) {
                    const deltaX = event.clientX - this.lastMouseX;
                    this.pivotGroup.rotation.y += deltaX * 0.01; // Adjust sensitivity
                    this.lastMouseX = event.clientX;
                    event.preventDefault(); // Prevent text selection on canvas during drag
                }
            }

            onMouseUp(event) {
                this.isDragging = false;
                // Auto-rotation will resume if conditions (hover/visibility) are met
                // Re-evaluate auto-rotation state after manual interaction
                const modelCard = this.canvas.closest('.model-card');
                if (modelCard) {
                    if (!isMobileDevice) {
                        // For desktop, check if mouse is still over the card
                        const rect = modelCard.getBoundingClientRect();
                        if (event.clientX >= rect.left && event.clientX <= rect.right &&
                            event.clientY >= rect.top && event.clientY <= rect.bottom) {
                            this.startAutoRotation();
                        } else {
                            this.stopAutoRotation();
                        }
                    } else {
                        // For mobile, re-check intersection ratio
                        if (intersectionObserver) {
                            // Take records to get the most up-to-date intersection status
                            const entry = intersectionObserver.takeRecords().find(e => e.target === modelCard);
                            if (entry && entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                this.startAutoRotation();
                            } else {
                                this.stopAutoRotation();
                            }
                        }
                    }
                }
            }

            // Custom touch event handlers for rotation
            onTouchStart(event) {
                if (event.touches.length === 1) { // Only handle single touch for rotation
                    this.isTouching = true;
                    this.lastTouchX = event.touches[0].clientX;
                    this.lastTouchY = event.touches[0].clientY; // Initialize lastTouchY
                    this.stopAutoRotation(); // Stop auto-rotation when user starts manual interaction
                    // passive: true in addEventListener means we cannot call preventDefault here.
                    // This is desired to allow vertical page scrolling without interruption.
                }
            }

            onTouchMove(event) {
                if (this.isTouching && event.touches.length === 1) {
                    const deltaX = event.touches[0].clientX - this.lastTouchX;
                    const deltaY = event.touches[0].clientY - this.lastTouchY; // Calculate vertical movement
                    
                    // Only rotate if horizontal movement is more dominant than vertical, or if vertical movement is minimal
                    if (Math.abs(deltaX) > Math.abs(deltaY) || Math.abs(deltaY) < 5) { // Small threshold for vertical
                        this.pivotGroup.rotation.y += deltaX * 0.01; // Adjust sensitivity
                        // DO NOT call event.preventDefault() here to allow vertical page scrolling.
                        // Horizontal swipe will rotate, but vertical swipe will scroll the page.
                    }
                    this.lastTouchX = event.touches[0].clientX;
                    this.lastTouchY = event.touches[0].clientY; // Update lastTouchY
                }
            }

            onTouchEnd(event) {
                this.isTouching = false;
                this.lastTouchY = undefined; // Clear lastTouchY
                // Auto-rotation will resume if conditions (hover/visibility) are met
                const modelCard = this.canvas.closest('.model-card');
                if (modelCard) {
                    if (intersectionObserver) {
                        // Take records to get the most up-to-date intersection status
                        const entry = intersectionObserver.takeRecords().find(e => e.target === modelCard);
                        if (entry && entry.isIntersecting && entry.intersectionRatio > 0.75) {
                            this.startAutoRotation();
                        } else {
                            this.stopAutoRotation();
                        }
                    }
                }
            }
        }

        // Global map to store renderer instances
        const rendererInstances = new Map();
        // Determine if it's a mobile device (or small screen)
        const isMobileDevice = window.innerWidth <= 768; // Define mobile breakpoint

        // Intersection Observer for mobile auto-rotation
        let intersectionObserver;
        if (isMobileDevice) {
            // Initialize observer ONCE globally
            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const modelId = entry.target.dataset.modelId;
                    const renderer = rendererInstances.get(modelId);

                    if (renderer) {
                        // If more than 75% visible, start auto-rotation
                        if (entry.isIntersecting && entry.intersectionRatio > 0.75) { 
                            // Only start auto-rotation if not currently being manually dragged/swiped
                            if (!renderer.isDragging && !renderer.isTouching) {
                                renderer.startAutoRotation();
                                console.log(`Mobile: Modell ${modelId} ist >75% sichtbar. Starte automatische Rotation (wenn nicht gezogen wird).`);
                            }
                        } else {
                            renderer.stopAutoRotation();
                            console.log(`Mobile: Modell ${modelId} ist nicht >75% sichtbar. Stoppe automatische Rotation.`);
                        }
                    }
                });
            }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] }); // Observe various visibility levels
        }


        // Funktion zum Erstellen einer Modellkarte
        function createModelCard(model) {
            const card = document.createElement('div');
            // Angepasste Tailwind-Klassen für Modellkarte
            card.className = 'card bg-base-200 rounded-xl overflow-hidden border border-base-content/10 transition-transform duration-300 hover:translate-y-[-5px] hover:shadow-xl';
            
            const rating = model.ratingCount > 0 ? (model.rating / model.ratingCount).toFixed(1) : '0.0';
            const fullStars = Math.floor(rating);
            const halfStar = rating % 1 >= 0.5;
            const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);

            let starsHtml = '';
            // Using Font Awesome for stars as it's a common practice and not "custom CSS" in the same vein as inline styles
            for (let i = 0; i < fullStars; i++) starsHtml += '<i class="fas fa-star text-warning"></i>';
            if (halfStar) starsHtml += '<i class="fas fa-star-half-alt text-warning"></i>';
            for (let i = 0; i < emptyStars; i++) starsHtml += '<i class="far fa-star text-warning"></i>';

            const uploadDate = model.timestamp ? new Date(model.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';

            // Determine uploader avatar content
            let uploaderAvatarHtml;
            if (model.uploaderPhotoURL) {
                uploaderAvatarHtml = `<img src="${model.uploaderPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
            } else if (model.email) { // Use model.email if uploaderEmail is not directly available
                uploaderAvatarHtml = `<i class="fas fa-user text-lg"></i>`;
            } else {
                // Geändert zu Font Awesome Benutzer-Icon für unbekannte Benutzer, mit flexbox für Zentrierung
                uploaderAvatarHtml = `<i class="fas fa-user text-lg"></i>`;
            }


            card.innerHTML = `
                <div class="h-52 flex items-center justify-center overflow-hidden relative text-base-content/60 text-sm text-center">
                    <canvas class="voxel-preview-canvas w-full h-full block"></canvas>
                </div>
                <div class="card-body p-4">
                    <div class="flex justify-between">
                        <h2 class="card-title text-lg">${model.title}</h2>
                        <div class="badge badge-outline badge-primary">${model.category || 'Allgemein'}</div>
                    </div>
                    <p class="text-base-content/60 text-sm mt-2">${model.description}</p>
                    <div class="mt-4 flex flex-col sm:flex-row sm:justify-between items-start sm:items-center gap-4">
                        <div>
                            <div class="flex items-center whitespace-nowrap">
                                ${starsHtml}
                                <span class="text-base-content/60 ml-2">${rating}</span>
                            </div>
                            <div class="text-base-content/60 text-sm mt-1">${model.downloads || 0} Downloads</div>
                        </div>
                        <div class="flex flex-wrap gap-2 justify-start sm:justify-end"> <!-- Buttons container -->
                            <button class="btn btn-primary btn-md download-button" data-model-id="${model.id}" data-model-title="${model.title}">
                                <i class="fas fa-download"></i>
                            </button>
                            <button class="btn btn-secondary btn-md open-voxelshaper-button" data-model-id="${model.id}">
                                <i class="fas fa-external-link-alt"></i>
                            </button>
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm text-base-content/60">
                        <div class="avatar">
                            <div class="w-8 h-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center">
                                ${uploaderAvatarHtml}
                            </div>
                        </div>
                        <span class="ml-2">${model.uploaderEmail ? model.uploaderEmail.split('@')[0] : 'Unbekannt'}</span>
                        <span class="ml-auto">${uploadDate}</span>
                    </div>
                </div>
            `;
            // Add event listener for the download button on the newly created card
            card.querySelector('.download-button').addEventListener('click', function() {
                handleDownload(this.dataset.modelId, this.dataset.modelTitle);
            });

            // Add event listener for the new "Open in VoxelShaper" button
            card.querySelector('.open-voxelshaper-button').addEventListener('click', function() {
                handleOpenOnVoxelShaper(this.dataset.modelId);
            });

            // Assign model ID to the card element for easy lookup in Intersection Observer
            card.dataset.modelId = model.id; // Set data-model-id on the card itself

            return card;
        }

        // Function to initialize the preview renderer for a given card
        function initPreviewRendererForCard(card, model) {
            const previewCanvas = card.querySelector('.voxel-preview-canvas');
            const modelId = card.dataset.modelId;
            const voxelsData = model.projectData ? model.projectData.voxels : {};
            const gridSize = (model.projectData && model.projectData.settings && model.projectData.settings.gridSize) ? model.projectData.settings.gridSize : 10;
            
            let previewRendererInstance = null; 
            let retryCount = 0;
            const MAX_RETRIES = 60; 

            // Dynamische Three.js Hintergrundfarbe basierend auf dem aktuellen Theme
            const currentTheme = htmlElement.getAttribute('data-theme');
            const threeJsBgColor = getDaisyUICSSColorForThreeJS(currentTheme);

            function initializePreviewRendererWithRetry() {
                console.log(`Versuch ${retryCount + 1} für Modell ${modelId}: Canvas clientWidth=${previewCanvas.clientWidth}, clientHeight=${previewCanvas.clientHeight}, offsetWidth=${previewCanvas.offsetWidth}, offsetHeight=${previewCanvas.offsetHeight}`);

                if (previewCanvas.clientWidth === 0 || previewCanvas.clientHeight === 0 || previewCanvas.offsetWidth === 0 || previewCanvas.offsetHeight === 0) {
                    console.log(`Canvas-Dimensionen sind 0 für Modell ${modelId}. Wiederhole... (Versuch ${retryCount + 1}/${MAX_RETRIES})`);
                    if (retryCount < MAX_RETRIES) {
                        retryCount++;
                        requestAnimationFrame(initializePreviewRendererWithRetry); // Use requestAnimationFrame for retries
                    } else {
                        console.warn(`VoxelPreviewRenderer: Canvas hat nach maximalen Wiederholungen für Modell ${modelId} keine Größe.`);
                        console.error(`FEHLER beim Initialisieren des Renderers für Modell ${modelId} nach ${MAX_RETRIES} Versuchen aufgrund von Null-Canvas-Größe.`);
                        previewCanvas.style.display = 'none';
                        const parentDiv = previewCanvas.parentElement;
                        let messageDiv = parentDiv.querySelector('.preview-message');
                        if (!messageDiv) {
                            messageDiv = document.createElement('div');
                            messageDiv.className = 'absolute inset-0 flex items-center justify-center text-base-content/60 text-sm';
                            parentDiv.appendChild(messageDiv);
                        }
                        messageDiv.textContent = 'Keine Vorschau verfügbar (Canvas-Größe 0).';
                        previewRendererInstance = null; // Ensure rendererInstance is null on failure
                    }
                } else {
                    try {
                        console.log(`Canvas-Dimensionen sind ${previewCanvas.clientWidth}x${previewCanvas.clientHeight} für Modell ${modelId}. Initialisiere Renderer.`);
                        // Pass the dynamically retrieved background color to the renderer
                        previewRendererInstance = new VoxelPreviewRenderer(previewCanvas, voxelsData, gridSize, threeJsBgColor); 
                        previewRendererInstance.renderer.render(previewRendererInstance.scene, previewRendererInstance.camera);

                        // Store the instance globally
                        rendererInstances.set(model.id, previewRendererInstance);

                        // Handle desktop hover or mobile intersection
                        if (!isMobileDevice) {
                            // Desktop: Start rotation on hover, stop on mouse leave
                            card.addEventListener('mouseenter', () => {
                                console.log(`Desktop: Maus betrat Karte für Modell ${model.id}. Starte automatische Rotation.`);
                                if (previewRendererInstance) {
                                    previewRendererInstance.startAutoRotation();
                                }
                            });
                            card.addEventListener('mouseleave', () => {
                                console.log(`Desktop: Maus verließ Karte für Modell ${model.id}. Stoppe automatische Rotation.`);
                                if (previewRendererInstance) {
                                    previewRendererInstance.stopAutoRotation();
                                }
                            });
                            // Initially stop auto-rotation for desktop models
                            previewRendererInstance.stopAutoRotation();
                        } else {
                            // Mobile: Observe with IntersectionObserver
                            if (intersectionObserver) {
                                console.log(`Mobile: Beobachte Karte für Modell ${model.id} mit IntersectionObserver.`);
                                intersectionObserver.observe(card); // Observe the new card
                            }
                            // Initially stop auto-rotation for mobile models, observer will start it if visible
                            previewRendererInstance.stopAutoRotation();
                        }

                        // Start the animation loop (rendering loop) always, but rotation is conditional
                        previewRendererInstance.startAnimation();

                    } catch (error) {
                        console.error("Fehler beim Initialisieren des VoxelPreviewRenderers für Modell", model.id, ":", error);
                        previewCanvas.style.display = 'none';
                        const parentDiv = previewCanvas.parentElement;
                        let messageDiv = parentDiv.querySelector('.preview-message');
                        if (!messageDiv) {
                            messageDiv = document.createElement('div');
                            messageDiv.className = 'absolute inset-0 flex items-center justify-center text-error text-sm';
                            parentDiv.appendChild(messageDiv);
                        }
                        messageDiv.textContent = 'Fehler beim Laden der Vorschau.';
                        previewRendererInstance = null; // Ensure rendererInstance is null on failure
                    }
                }
            }

            // Initial call using requestAnimationFrame
            requestAnimationFrame(initializePreviewRendererWithRetry); 
        }


        // Funktion zum Laden von Modellen aus Firestore
        async function fetchModels() {
            if (isLoadingModels) return;
            isLoadingModels = true;
            loadingSpinner.classList.remove('hidden');
            loadMoreButton.classList.add('hidden');
            noMoreModelsMessage.classList.add('hidden');

            try {
                let modelsQuery = query(
                    collection(db, "models"), 
                    where("visibility", "==", "public"), 
                    limit(MODELS_PER_LOAD)
                );

                if (lastVisible) {
                    modelsQuery = query(
                        collection(db, "models"), 
                        where("visibility", "==", "public"), 
                        startAfter(lastVisible),
                        limit(MODELS_PER_LOAD)
                    );
                }

                const documentSnapshots = await getDocs(modelsQuery);
                let newModels = []; 
                documentSnapshots.forEach((doc) => {
                    newModels.push({ id: doc.id, ...doc.data() });
                });

                // Client-side sorting to ensure "newest" first, as server-side orderBy is removed
                newModels.sort((a, b) => {
                    const timestampA = a.timestamp ? a.timestamp.toMillis() : 0;
                    const timestampB = b.timestamp ? b.timestamp.toMillis() : 0;
                    return timestampB - timestampA; 
                });


                if (newModels.length > 0) {
                    newModels.forEach(model => {
                        const newCard = createModelCard(model); // Create card
                        modelsGrid.appendChild(newCard); // Append new card to the grid
                        initPreviewRendererForCard(newCard, model); // Initialize renderer AFTER appending
                    });
                    lastVisible = documentSnapshots.docs[documentSnapshots.docs.length - 1];
                    loadMoreButton.classList.remove('hidden'); 
                } else {
                    noMoreModelsMessage.classList.remove('hidden'); 
                }

                if (documentSnapshots.docs.length < MODELS_PER_LOAD) {
                    loadMoreButton.classList.add('hidden');
                    noMoreModelsMessage.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Fehler beim Abrufen von Modellen:", error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'alert alert-error mt-4';
                errorDiv.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <span>Fehler beim Laden der Modelle: ${error.message}. Bitte überprüfen Sie Ihre Firebase Firestore Sicherheitsregeln. Stellen Sie sicher, dass Lesezugriff für die 'models'-Sammlung erlaubt ist, z.B. 'allow read: if resource.data.visibility == "public";'.</span>
                `;
                modelsGrid.appendChild(errorDiv);
                loadMoreButton.classList.add('hidden'); 
            } finally {
                isLoadingModels = false;
                loadingSpinner.classList.add('hidden');
            }
        }

        setPersistence(auth, browserLocalPersistence)
            .then(() => {
                onAuthStateChanged(auth, (user) => {
                    currentUser = user;
                    currentUserId = user?.uid || null;

                    updateUI(user); 

                    // Initial load of models only if the grid is empty
                    if (modelsGrid.children.length === 0 && !isLoadingModels) {
                        fetchModels();
                    }
                });
            })
            .catch((error) => {
                console.error("Fehler bei setPersistence:", error);
                const errorMessage = document.createElement('div');
                errorMessage.className = 'alert alert-error fixed bottom-4 right-4 z-50 w-80';
                errorMessage.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <span>Fehler bei der Anmeldungspersistenz: ${error.message}. Die Funktionalität könnte eingeschränkt sein.</span>
                `;
                document.body.appendChild(errorMessage);
                setTimeout(() => errorMessage.remove(), 5000);
            });


        // Login-Handler
        loginButton.addEventListener('click', () => {
            hideMessage(authErrorMessage);
            authModal.showModal();
        });

        // Firebase Login
        firebaseLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value;

            try {
                await signInWithEmailAndPassword(auth, email, password);
                authModal.close(); 
            } catch (error) {
                console.error("Firebase Login Error:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    errorMessage = "Ungültige E-Mail oder Passwort.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showMessage(authErrorMessage, errorMessage);
            }
        });

        // Firebase Registrierung
        firebaseSignupButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value; 

            try {
                await createUserWithEmailAndPassword(auth, email, password);
                authModal.close(); 
            } catch (error) {
                console.error("Firebase Signup Error:", error.code, error.message);
                let errorMessage = "Registrierung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Diese E-Mail-Adresse wird bereits verwendet.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Das Passwort sollte mindestens 6 Zeichen lang sein.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showMessage(authErrorMessage, errorMessage);
            }
        });

        // Firebase Google Login (now uses popup)
        googleLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, googleProvider);
                console.log("Google sign-in successful:", result.user);
                authModal.close(); 
            } catch (error) {
                console.error("Firebase Google Login Error:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console hinzu (Authentifizierung -> Einstellungen).`;
                } else {
                    errorMessage = `Anmeldung fehlgeschlagen: ${error.message}.`;
                }
                showMessage(authErrorMessage, errorMessage);
            }
        });

        // Firebase GitHub Login (now uses popup)
        githubLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, githubProvider);
                console.log("GitHub sign-in successful:", result.user);
                authModal.close(); 
            } catch (error) {
                console.error("Firebase GitHub Login Error:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console hinzu (Authentifizierung -> Einstellungen).`;
                } else {
                    errorMessage = `Anmeldung fehlgeschlagen: ${error.message}.`;
                }
                showMessage(authErrorMessage, errorMessage);
            }
        });


        // Firebase Logout
        logoutButton.addEventListener('click', async (e) => {
            e.preventDefault();
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Firebase Logout Error:", error.message);
            }
        });

        // Upload Model Button Handler
        uploadModelButton.addEventListener('click', () => {
            if (!auth.currentUser) {
                authModal.showModal();
                showMessage(authErrorMessage, 'Bitte melden Sie sich an, um Modelle hochzuladen.', true);
            } else {
                hideMessage(uploadErrorMessage);
                hideMessage(uploadSuccessMessage);
                modelTitleInput.value = ''; 
                modelDescriptionInput.value = ''; 
                projectJsonInput.value = ''; 
                remixOfInput.value = ''; 
                tagsInput.value = ''; 
                visibilitySelect.value = 'public'; 
                
                jsonUploadStep.classList.remove('hidden');
                modelDetailsStep.classList.add('hidden');
                hideMessage(jsonErrorMessage); 
                uploadSubmitButton.disabled = true; // Disable until JSON is loaded and valid
                
                uploadModal.showModal();
            }
        });

        // Event Listener for "Projektdatei laden" button
        loadJsonButton.addEventListener('click', () => {
            const file = projectJsonInput.files[0];
            if (!file) {
                showMessage(jsonErrorMessage, 'Bitte wählen Sie eine Projektdatei aus.', true);
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    currentProjectJsonData = JSON.parse(event.target.result);
                    currentProjectJsonFile = file; 

                    modelTitleInput.value = currentProjectJsonData.title || '';
                    modelDescriptionInput.value = currentProjectJsonData.description || '';
                    remixOfInput.value = currentProjectJsonData.remixOf || '';
                    if (currentProjectJsonData.tags && Array.isArray(currentProjectJsonData.tags)) {
                        tagsInput.value = currentProjectJsonData.tags.join(', ');
                    } else {
                        tagsInput.value = '';
                    }
                    if (currentProjectJsonData.visibility) {
                        const optionExists = Array.from(visibilitySelect.options).some(option => option.value === currentProjectJsonData.visibility);
                        if (optionExists) {
                            visibilitySelect.value = currentProjectJsonData.visibility;
                        } else {
                            visibilitySelect.value = 'public'; 
                        }
                    } else {
                        visibilitySelect.value = 'public'; 
                    }

                    hideMessage(jsonErrorMessage);
                    jsonUploadStep.classList.add('hidden'); 
                    modelDetailsStep.classList.remove('hidden'); 
                    uploadSubmitButton.disabled = false; // Still disabled until all required fields are filled
                    
                    // Check if title is present to enable upload button
                    if (modelTitleInput.value.trim() !== '') {
                        uploadSubmitButton.disabled = false;
                    }

                } catch (error) {
                    console.error("Fehler beim Parsen des Projekt-JSON:", error);
                    showMessage(jsonErrorMessage, 'Fehler beim Lesen der Projektdatei. Bitte stellen Sie sicher, dass es sich um eine gültige JSON-Datei handelt.', true);
                    modelTitleInput.value = '';
                    modelDescriptionInput.value = '';
                    remixOfInput.value = '';
                    tagsInput.value = '';
                    visibilitySelect.value = 'public';
                    uploadSubmitButton.disabled = true;
                    currentProjectJsonData = null;
                    currentProjectJsonFile = null;
                }
            };
            reader.onerror = () => {
                showMessage(jsonErrorMessage, 'Fehler beim Lesen der Datei.', true);
                uploadSubmitButton.disabled = true;
                currentProjectJsonData = null;
                currentProjectJsonFile = null;
            };
            reader.readAsText(file);
        });

        // Enable/disable upload button based on title input
        modelTitleInput.addEventListener('input', () => {
            if (modelTitleInput.value.trim() !== '' && currentProjectJsonData) {
                uploadSubmitButton.disabled = false;
            } else {
                uploadSubmitButton.disabled = true;
            }
        });

        // Handle Model Upload
        uploadSubmitButton.addEventListener('click', async (e) => {
            e.preventDefault();
            hideMessage(uploadErrorMessage);
            hideMessage(uploadSuccessMessage);

            const title = modelTitleInput.value.trim();
            const description = modelDescriptionInput.value.trim();
            
            const remixOf = remixOfInput.value.trim(); 
            const tags = tagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag !== ''); 
            const visibility = visibilitySelect.value; 

            if (!currentProjectJsonData || !currentProjectJsonFile) {
                showMessage(uploadErrorMessage, 'Bitte laden Sie zuerst die Projektdatei.', true);
                return;
            }

            if (!auth.currentUser) {
                showMessage(uploadErrorMessage, 'Sie müssen angemeldet sein, um ein Modell hochzuladen.', true);
                return;
            }

            try {
                await addDoc(collection(db, "models"), { 
                    title: title, 
                    description: description, 
                    remixOf: remixOf, 
                    tags: tags, 
                    visibility: visibility, 
                    fileName: currentProjectJsonFile.name, 
                    projectData: currentProjectJsonData, 
                    uploaderUid: auth.currentUser.uid,
                    uploaderEmail: auth.currentUser.email,
                    uploaderPhotoURL: auth.currentUser.photoURL || null, 
                    timestamp: serverTimestamp(),
                    downloads: 0, 
                    rating: 0,
                    ratingCount: 0,
                    verified: false,
                });

                showMessage(uploadSuccessMessage, 'Modell erfolgreich hochgeladen!', false);
                uploadModal.close(); 
                // When an upload happens, clear the grid and reload all models from scratch
                modelsGrid.innerHTML = '';
                lastVisible = null;
                // Dispose and clear all existing renderers when the grid is completely reset
                rendererInstances.forEach(renderer => {
                    if (renderer) renderer.dispose();
                });
                rendererInstances.clear();
                if (intersectionObserver && isMobileDevice) { // Only disconnect if it was initialized for mobile
                    intersectionObserver.disconnect();
                    // Re-initialize observer for new elements (will happen in createModelCard for first batch)
                    intersectionObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            const modelId = entry.target.dataset.modelId;
                            const renderer = rendererInstances.get(modelId);
                            if (renderer) {
                                if (entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                    if (!renderer.isDragging && !renderer.isTouching) {
                                        renderer.startAutoRotation();
                                    }
                                } else {
                                    renderer.stopAutoRotation();
                                }
                            }
                        });
                    }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] });
                }

                fetchModels(); 
            } catch (error) {
                console.error("Modell-Upload-Fehler:", error);
                if (error.code === 'resource-exhausted') {
                    showMessage(uploadErrorMessage, `Fehler beim Hochladen des Modells: Die Projektdatei ist zu groß. Firestore-Dokumente dürfen maximal 1 MB groß sein.`, true);
                } else {
                    showMessage(uploadErrorMessage, `Fehler beim Hochladen des Modells: ${error.message}`, true);
                }
                uploadModal.close(); 
            }
        });

        // Download-Handler
        async function handleDownload(modelId, modelTitle) {
            if (!auth.currentUser) { 
                authModal.showModal();
                showMessage(authErrorMessage, 'Bitte melden Sie sich an, um Modelle herunterzuladen.', true);
                return;
            }

            const downloadMessage = document.createElement('div');
            downloadMessage.className = 'alert alert-info fixed bottom-4 right-4 z-50 w-80';
            downloadMessage.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                <span>Download von "${modelTitle}" gestartet!</span>
            `;
            document.body.appendChild(downloadMessage);
            setTimeout(() => downloadMessage.remove(), 3000); 

            try {
                const docRef = doc(db, "models", modelId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const modelData = docSnap.data();
                    const projectJsonForDownload = modelData.projectData; 

                    if (projectJsonForDownload) {
                        const jsonString = JSON.stringify(projectJsonForDownload, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${modelTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`; 
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        try {
                            await updateDoc(docRef, {
                                downloads: (modelData.downloads || 0) + 1
                            });
                        } catch (updateError) {
                            console.error("Fehler beim Aktualisieren der Download-Zählung:", updateError);
                            const errorMessage = document.createElement('div');
                            errorMessage.className = 'alert alert-warning fixed bottom-4 right-4 z-50 w-80';
                            errorMessage.innerHTML = `
                                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                <span>Download erfolgreich, aber Fehler beim Aktualisieren des Zählers: ${updateError.message}. Überprüfen Sie Ihre Firestore-Sicherheitsregeln für 'update'.</span>
                            `;
                            document.body.appendChild(errorMessage);
                            setTimeout(() => errorMessage.remove(), 5000);
                        }

                    } else {
                         console.error("Projektdaten nicht im Dokument für den Download gefunden.");
                         const errorMessage = document.createElement('div');
                         errorMessage.className = 'alert alert-error fixed bottom-4 right-4 z-50 w-80';
                         errorMessage.innerHTML = `
                             <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                             <span>Fehler beim Download: Projektdaten nicht gefunden.</span>
                         `;
                         document.body.appendChild(errorMessage);
                         setTimeout(() => errorMessage.remove(), 3000);
                    }

                } else {
                    console.error("Dokument nicht gefunden!");
                    const errorMessage = document.createElement('div');
                    errorMessage.className = 'alert alert-error fixed bottom-4 right-4 z-50 w-80';
                    errorMessage.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <span>Fehler beim Download: Modell nicht gefunden.</span>
                    `;
                    document.body.appendChild(errorMessage);
                    setTimeout(() => errorMessage.remove(), 3000);
                }
            } catch (error) {
                console.error("Fehler beim Herunterladen des Modell-JSON:", error);
                const errorMessage = document.createElement('div');
                errorMessage.className = 'alert alert-error fixed bottom-4 right-4 z-50 w-80';
                errorMessage.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <span>Fehler beim Download der Projektdatei: ${error.message}</span>
                `;
                document.body.appendChild(errorMessage);
                setTimeout(() => errorMessage.remove(), 3000);
            }
        }

        // Funktion zum Öffnen in VoxelShaper
        async function handleOpenOnVoxelShaper(modelId) {
            // KEIN ANMELDEZWANG HIER FÜR ÖFFENTLICHE MODELLE
            // if (!auth.currentUser) { 
            //     authModal.showModal();
            //     showMessage(authErrorMessage, 'Bitte melden Sie sich an, um Modelle in VoxelShaper zu öffnen.', true);
            //     return;
            // }

            try {
                const docRef = doc(db, "models", modelId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    // **KORRIGIERTE URL HIER**
                    const editorUrl = `https://voxelshaper.com/?modelId=${modelId}`;
                    window.open(editorUrl, '_blank');

                    const infoMessage = document.createElement('div');
                    infoMessage.className = 'alert alert-info fixed bottom-4 right-4 z-50 w-80';
                    infoMessage.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        <span>Modell ${modelId} wird in VoxelShaper geöffnet!</span>
                    `;
                    document.body.appendChild(infoMessage);
                    setTimeout(() => infoMessage.remove(), 3000);

                } else {
                    console.error("Dokument nicht gefunden!");
                    const errorMessage = document.createElement('div');
                    errorMessage.className = 'alert alert-error fixed bottom-4 right-4 z-50 w-80';
                    errorMessage.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                        <span>Fehler beim Öffnen: Modell nicht gefunden.</span>
                    `;
                    document.body.appendChild(errorMessage);
                    setTimeout(() => errorMessage.remove(), 3000);
                }
            } catch (error) {
                console.error("Fehler beim Öffnen des Modells in VoxelShaper:", error);
                const errorMessage = document.createElement('div');
                errorMessage.className = 'alert alert-error fixed bottom-4 right-4 z-50 w-80';
                errorMessage.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    <span>Fehler beim Öffnen des Modells: ${error.message}</span>
                `;
                document.body.appendChild(errorMessage);
                setTimeout(() => errorMessage.remove(), 3000);
            }
        }

        // Event Listener für den "Mehr laden"-Button
        loadMoreButton.addEventListener('click', fetchModels);


        // Initiales Laden der Modelle, wenn die Seite geladen wird (falls onAuthStateChanged nicht sofort feuert)
        document.addEventListener('DOMContentLoaded', () => {
            // Überprüfe die gespeicherte Theme-Präferenz oder die Systempräferenz
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            let initialTheme = 'dark'; // Standardmäßig dunkles Theme
            if (savedTheme) {
                initialTheme = savedTheme;
            } else if (!systemPrefersDark) { // Wenn kein Theme gespeichert ist und das System hell bevorzugt, verwende hell
                initialTheme = 'light';
            }

            htmlElement.setAttribute('data-theme', initialTheme);
            themeToggle.checked = (initialTheme === 'dark'); // Setze den Toggle-Status basierend auf dem initialen Theme

            // Initiales Laden der Modelle
            if (modelsGrid.children.length === 0 && !isLoadingModels) {
                fetchModels();
            }
        });

        // Theme Toggle Event Listener
        themeToggle.addEventListener('change', () => {
            const isChecked = themeToggle.checked;
            const newTheme = isChecked ? 'dark' : 'light';
            htmlElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);

            // Dispose and re-initialize all existing renderers with the new theme background
            // This is the most reliable way to ensure Three.js background updates.
            modelsGrid.innerHTML = ''; // Clear the grid
            lastVisible = null; // Reset pagination
            rendererInstances.forEach(renderer => {
                if (renderer) renderer.dispose();
            });
            rendererInstances.clear();
            if (intersectionObserver && isMobileDevice) {
                intersectionObserver.disconnect();
                // Re-initialize observer for new elements (will happen in createModelCard for first batch)
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const modelId = entry.target.dataset.modelId;
                        const renderer = rendererInstances.get(modelId);
                        if (renderer) {
                            if (entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!renderer.isDragging && !renderer.isTouching) {
                                    renderer.startAutoRotation();
                                }
                            } else {
                                renderer.stopAutoRotation();
                            }
                        }
                    });
                }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] });
            }
            fetchModels(); // Reload models to apply new background to Three.js previews
        });

    </script>
</body>
</html>
