<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>

<!-- DaisyUI and Tailwind CSS CDN -->
<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    box-sizing: border-box;
    /* Allow browser default scrolling for the body if content overflows, but not for touch interactions within the canvas */
    touch-action: auto;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}
#container, #voxelCanvas {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none; /* Crucial: Prevents default browser gestures (scrolling, zooming) on the canvas */
}
.touch-indicator { animation: pulse 0.5s; }
@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}
input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
input[type="color"]::-moz-color-swatch-wrapper { padding: 0; }
input[type="color"]::-moz-color-swatch { border: none; border-radius: 50%; }
.color-preset-box::-webkit-color-swatch-wrapper { padding: 0; }
.color-preset-box::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
.color-preset-box::-moz-color-swatch-wrapper { padding: 0; }
.color-preset-box::-moz-color-swatch { border: none; border-radius: 0.375rem; }

/* Custom styles for toast messages */
#toast-container {
    position: fixed;
    z-index: 50;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    pointer-events: none; /* Allows clicks to pass through when no toast is active */
}

/* Desktop positioning (bottom-end) */
#toast-container.toast-end {
    bottom: 1rem;
    right: 1rem;
    align-items: flex-end;
}

/* Mobile positioning (top-center) */
@media (max-width: 768px) {
    #toast-container {
        top: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: calc(100% - 2rem); /* Full width minus padding */
        max-width: 300px; /* Max width for better readability */
        align-items: center;
    }
    #toast-container.toast-end { /* Override desktop position on mobile */
        bottom: auto;
        right: auto;
    }
}

.toast .alert {
    pointer-events: auto; /* Re-enable clicks for the toast itself */
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform: translateY(20px); /* Start slightly off-screen for animation */
}

.toast .alert.show {
    opacity: 1;
    transform: translateY(0);
}

/* Smaller padding for mobile toasts */
@media (max-width: 768px) {
    .toast .alert {
        padding: 0.5rem 0.75rem; /* Smaller padding */
        font-size: 0.875rem; /* Slightly smaller font */
    }
    .toast .alert svg {
        width: 1.25rem; /* Smaller icons */
        height: 1.25rem;
    }
    .toast .alert strong {
        font-size: 0.9rem;
    }
    .toast .alert span {
        font-size: 0.8rem;
    }
    .toast .alert .close-btn {
        font-size: 1rem;
        padding: 0.25rem;
    }
}
</style>
</head>
<body class="bg-base-100 min-h-screen text-base-content flex flex-col">
<button id="menuToggle" aria-label="Men√º umschalten" class="fixed top-4 right-4 z-[1500] w-10 h-10 text-xl leading-10 text-center bg-base-300 text-base-content border-none rounded-lg cursor-pointer shadow-md hover:bg-base-content/20 lg:hidden">‚ò∞</button>

<div id="controls" class="flex flex-wrap items-center justify-center gap-3 p-4 bg-base-200 border-b border-base-content/20 hidden md:flex">
    <label for="grid-size-slider" class="text-base-content">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="180" value="10" aria-label="Gittergr√∂√üe anpassen" class="range range-xs w-36">
    <span id="grid-size-display" class="font-bold text-primary">10√ó10√ó10</span>
    
    <label for="color-picker" class="text-base-content">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe w√§hlen" class="input input-bordered w-10 h-10 p-0 rounded-full cursor-pointer border-base-content/20">
    <input type="color" id="color-preset-1" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#E4002B" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer transition-all duration-200 hover:scale-110" value="#00A040" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box w-10 h-10 rounded-md border-2 border-base-content/20 cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" value="#0057B8" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln" class="btn btn-sm btn-neutral">Modus wechseln</button><span id="current-mode" class="font-bold text-success min-w-40 text-center">Modus: Hinzuf√ºgen</span>
    <button id="clearBtn" aria-label="Alles l√∂schen" class="btn btn-sm btn-neutral">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen" class="btn btn-sm btn-neutral">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description" class="btn btn-sm btn-neutral">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden" class="btn btn-sm btn-neutral">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export" class="btn btn-sm btn-neutral">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export" class="btn btn-sm btn-neutral">OBJ Export</button>
    <button id="exportGlbBtn" aria-label="GLB Export" class="btn btn-sm btn-neutral">GLB Export</button> <!-- New GLB Export Button -->

    <label for="fly-speed-slider" class="text-base-content">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen" class="range range-xs w-36">
    <span id="fly-speed-display" class="font-bold text-primary">0.10</span>

    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen" class="btn btn-sm btn-neutral">Zur Szene zur√ºckkehen</button>
    <button id="generateVoxelIdeaBtn" aria-label="Voxel-Idee generieren" class="btn btn-sm btn-primary">‚ú® Voxel-Idee generieren ‚ú®</button>

    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden" class="btn btn-sm btn-neutral">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" class="btn btn-sm btn-neutral hidden" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" class="hidden">

    <button id="loginLogoutBtn" aria-label="Anmelden oder Abmelden" class="btn btn-sm btn-info">Anmelden</button>
    <span id="userIdDisplay" class="font-bold text-info ml-2 mr-2 whitespace-nowrap overflow-hidden text-ellipsis max-w-xs flex items-center gap-1"></span>
    <button id="uploadToHubBtn" aria-label="Auf Hub hochladen" class="btn btn-sm btn-warning hidden">Auf Hub hochladen</button>
    <button id="goToHubBtn" aria-label="Zum VoxelShaper Hub wechseln" class="btn btn-sm btn-secondary">Zum Hub</button>
</div>

<div id="container" class="flex-1 relative border-2 border-transparent box-border overflow-hidden touch-none">
    <canvas id="voxelCanvas" class="w-full h-full block box-border"></canvas>
    <div id="touch-indicator" class="touch-indicator absolute w-10 h-10 rounded-full bg-blue-500/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none hidden z-[2000]"></div>
    <input type="file" id="fileInput" accept=".json" class="hidden">
</div>

<dialog id="clearConfirmationModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 text-center shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">Projekt l√∂schen</h3>
        <p class="py-4">M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="saveAndClearBtn" class="confirm-save btn btn-success flex-1">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save btn btn-error flex-1">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="uploadProjectModal" class="modal">
    <div class="upload-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-xl w-11/12 text-left">
        <h3 class="font-bold text-lg text-primary text-center mb-6">Projekt auf Hub hochladen</h3>
        <label for="uploadTitle" class="label block mb-2 font-bold">Titel:</label>
        <input type="text" id="uploadTitle" placeholder="Ein aussagekr√§ftiger Titel f√ºr Ihr Projekt" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label for="uploadDescription" class="label block mb-2 font-bold">Beschreibung:</label>
        <textarea id="uploadDescription" placeholder="Beschreiben Sie Ihr Projekt kurz" maxlength="500" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>

        <label for="uploadCategory" class="label block mb-2 font-bold">Kategorie:</label>
        <select id="uploadCategory" class="select select-bordered w-full bg-base-300 border-base-content/20 mb-4" required>
            <option value="" disabled selected>Kategorie ausw√§hlen</option>
        </select>

        <label for="uploadTags" class="label block mb-2 font-bold">Tags (Komma-getrennt):</label>
        <input type="text" id="uploadTags" placeholder="z.B. Haus, Baum, Auto, Geb√§ude" maxlength="100" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-4">

        <label class="label block mb-2 font-bold">Sichtbarkeit:</label>
        <div class="radio-group flex gap-4 mb-4">
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="public" checked class="radio radio-primary mr-2"> √ñffentlich
            </label>
            <label class="flex items-center font-normal">
                <input type="radio" name="uploadVisibility" value="private" class="radio radio-primary mr-2"> Privat
            </label>
        </div>

        <div class="upload-modal-buttons flex justify-around gap-4 mt-6">
            <button id="uploadConfirmBtn" class="upload-confirm btn btn-success flex-1">Hochladen</button>
            <button id="uploadCancelBtn" class="upload-cancel btn btn-ghost flex-1">Abbrechen</button>
        </div>
    </div>
</dialog>

<dialog id="authModal" class="modal">
    <div class="auth-modal-content modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-lg w-11/12 text-center">
        <h3 class="font-bold text-lg text-primary mb-6">Anmelden bei VoxelShaper Hub</h3>
        <div class="provider-buttons flex flex-col gap-3">
            <button id="signInGoogleBtn" class="google btn btn-error text-white">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google Icon" class="w-5 h-5">
                Mit Google anmelden
            </button>
            <button id="signInGithubBtn" class="github btn bg-neutral text-neutral-content hover:bg-neutral-focus">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/github.svg" alt="GitHub Icon" class="w-5 h-5">
                Mit GitHub anmelden
            </button>
            <button id="showEmailLoginFormBtn" class="email btn btn-info">
                Mit E-Mail anmelden
            </button>
        </div>

        <div id="emailLoginForm" class="email-login-form mt-6 pt-6 border-t border-base-content/20 hidden">
            <form id="emailAuthForm">
                <input type="email" id="emailInput" placeholder="E-Mail" autocomplete="email" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <input type="password" id="passwordInput" placeholder="Passwort" autocomplete="current-password" class="input input-bordered w-full bg-base-300 border-base-content/20 mb-3">
                <button type="submit" id="emailSignInBtn" class="btn btn-primary w-full">Anmelden</button>
                <button type="button" id="emailSignUpBtn" class="btn btn-secondary w-full mt-2">Registrieren</button>
            </form>
        </div>

        <div class="close-button-container mt-6">
            <button id="authModalCloseBtn" class="btn btn-ghost">Schlie√üen</button>
        </div>
    </div>
</dialog>

<!-- New Modal for LLM Idea Generation -->
<dialog id="ideaGeneratorModal" class="modal">
    <div class="modal-box bg-base-200 text-base-content p-8 shadow-xl max-w-md">
        <h3 class="font-bold text-lg text-primary mb-4">‚ú® Voxel-Idee generieren ‚ú®</h3>
        <p class="py-2">Geben Sie ein Thema oder Konzept ein, um eine Voxel-Modell-Idee zu generieren:</p>
        <textarea id="ideaPromptInput" placeholder="Z.B. 'Ein gem√ºtliches Baumhaus', 'Ein futuristisches Raumschiff'" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24 mb-4 resize-y"></textarea>
        <div id="ideaResultDisplay" class="bg-base-300 p-4 rounded-md mb-4 hidden overflow-auto max-h-40"></div>
        <div id="ideaLoadingIndicator" class="text-center py-4 hidden">
            <span class="loading loading-spinner loading-lg text-primary"></span>
            <p>Generiere Idee...</p>
        </div>
        <div class="modal-buttons flex justify-around gap-4 mt-6">
            <button id="generateIdeaConfirmBtn" class="btn btn-primary flex-1">Generieren</button>
            <button id="ideaGeneratorCloseBtn" class="btn btn-ghost flex-1">Schlie√üen</button>
        </div>
    </div>
</dialog>

<div id="toast-container" class="toast toast-end z-50"></div>

<div id="mobile-controls" class="hidden md:hidden flex-col gap-3 fixed bottom-4 right-4 z-[1000]">
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-camera" aria-label="Kamera wechseln">üì∑</button>

    <!-- Updated Mode Toggle Button with dynamic icon -->
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-mode-toggle" aria-label="Modus wechseln">
        <span id="mobile-mode-icon" class="fas fa-plus"></span>
    </button>

    <!-- Mobile Color Picker Button and hidden input -->
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-color-picker-btn" aria-label="Farbe ausw√§hlen">üé®</button>
    <input type="color" id="mobile-color-input" value="#ffffff" class="hidden w-0 h-0 opacity-0 absolute pointer-events-none">

    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-generate-idea" aria-label="Voxel-Idee generieren">‚ú®</button>
    <button class="mobile-btn w-16 h-16 text-3xl rounded-full bg-base-300 text-base-content border-2 border-base-content cursor-pointer flex items-center justify-center shadow-lg hover:bg-base-content/20" id="mobile-login-logout" aria-label="Anmelden oder Abmelden">üîë</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script> <!-- GLTF Exporter for GLB -->

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import {
        getAuth,
        setPersistence,
        browserLocalPersistence,
        signInWithCustomToken,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
        initializeApp,
        getAuth,
        signInWithCustomToken,
        onAuthStateChanged,
        setPersistence,
        browserLocalPersistence,
        signOut,
        GoogleAuthProvider,
        GithubAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        getFirestore,
        doc,
        getDoc,
        collection,
        addDoc,
        serverTimestamp
    };

    // Firebase API Key (hardcoded as per user request)
    const FIREBASE_API_KEY = "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA"; 

    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
        apiKey: FIREBASE_API_KEY, // Using hardcoded Firebase API Key
        authDomain: "voxelshaper.firebaseapp.com",
        projectId: "voxelshaper",
        storageBucket: "voxelshaper.firebasestorage.app", 
        messagingSenderId: "1053689247573",
        appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
        measurementId: "G-QJCNKZ5DR"
    };
    window.firebaseConfig = firebaseConfig;
</script>

<script>
// Debugging-Nachricht
console.log('Script started parsing');
const VS = 1, HALF = VS * 0.5; // Voxel-Gr√∂√üe und halbe Voxel-Gr√∂√üe
const CHUNK_SIZE = 16; // Gr√∂√üe eines Chunks (f√ºr Voxel-Gruppierung)
const VOX_BITS = 10; // Anzahl der Bits pro Voxel-Koordinate in einem Key
const VOX_MASK = (1 << VOX_BITS) - 1; // Maske zum Extrahieren einer Koordinate
const SHIFT_X  = VOX_BITS * 2; // Shift-Wert f√ºr X-Koordinate
const SHIFT_Y  = VOX_BITS; // Shift-Wert f√ºr Y-Koordinate

// AI API Key (hardcoded as per user request)
const AI_API_KEY = "AIzaSyD3uQ6BnGsliYAtR9r0jdBUq03KEfFO0"; 

// Erzeugt einen eindeutigen Key f√ºr Voxel-Koordinaten
function key(x, y, z) { return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0; }
// Parst einen Key zur√ºck in Voxel-Koordinaten
function parseKey(k) { return [(k >>> SHIFT_X) & VOX_MASK, (k >>> SHIFT_Y) & VOX_MASK, k & VOX_MASK]; }

const VOXEL_DRAG_THRESHOLD = 1; // Schwellenwert f√ºr Voxel-Drag-Erkennung (nicht mehr direkt verwendet, ersetzt durch MOVE_PX)
const PINCH_ZOOM_MULT = 40; // Multiplikator f√ºr Pinch-Zoom
const TAP_DIST_TH = 10; // Schwellenwert f√ºr Tap-Distanz
const MOVE_PX = 10; // Schwellenwert f√ºr Mausbewegung (Drag-Erkennung)
const DT_MS = 250; // Zeitfenster f√ºr Doppeltipp

// Mobile-spezifische Geschwindigkeiten
const ROTATE_SPEED_TOUCH_MOBILE = 0.008; // Erh√∂ht f√ºr schnellere Rotation
const PAN_SPEED_TOUCH_MOBILE = 0.2;     // Erh√∂ht f√ºr schnelleres Schwenken
const PINCH_ZOOM_MULT_MOBILE = 80;      // Erh√∂ht f√ºr schnelleren Zoom

// Desktop-spezifische Geschwindigkeiten (k√∂nnen auch angepasst werden, falls n√∂tig)
const ROTATE_SPEED_TOUCH_DESKTOP = 0.004;
const PAN_SPEED_TOUCH_DESKTOP = 0.1;
const PINCH_ZOOM_MULT_DESKTOP = 40;


let activePointers = new Map(); // Speichert aktive Pointer (f√ºr Multi-Touch)
let gestureState = { type: 'none', startDist: 0, startMid: { x: 0, y: 0 }, lastMid: { x: 0, y: 0 }, lastDist: 0, startTime: 0, initialPointerCount: 0 };
let tapCandidate = null; // Kandidat f√ºr Doppeltipp
let doubleTapDragActive = false; // Flag f√ºr aktiven Doppeltipp-Drag
let touchIndicator; // Visueller Indikator f√ºr Touch-Interaktion

let scene, cam, ren, gridHelper, boxHelper; // Three.js-Objekte
let rotSpeed = 0.004; // Rotationsgeschwindigkeit der Kamera
let euler; // Euler-Winkel f√ºr Kamera-Rotation
const voxels = new Map(); // Speichert alle Voxel im Modell (Key -> {color})
const chunks = new Map(); // Speichert Voxel-Chunks f√ºr effizientes Rendering

let cvs, containerDiv; // Canvas- und Container-Elemente
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Aktuelle Zeichenebene
let currentDrawingAxis = 'y'; // Aktuelle Zeichenachse (Standard f√ºr Mobile)

let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff'; // Aktuelle Voxel-Farbe
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed') || '0.1'); // Fluggeschwindigkeit der Kamera
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize') || '10'); // Gr√∂√üe des Voxel-Gitters

// L√§dt gespeicherte Zeichenebenen-Einstellungen und stellt sicher, dass sie g√ºltige Zahlen sind
activeDrawingLevel.x = Number(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0; // Explicitly handle NaN/null/undefined
activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));

activeDrawingLevel.y = Number(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));

activeDrawingLevel.z = Number(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;
activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';

const presetColors = [ // Voreingestellte Farben
    localStorage.getItem('voxelPresetColor1') || '#E4002B', // Mario Red
    localStorage.getItem('voxelPresetColor2') || '#00A040', // Luigi Green
    localStorage.getItem('voxelPresetColor3') || '#0057B8'  // Nintendo Blue
];
let activePresetIndex = -1; // Index der aktiven voreingestellten Farbe
let presetBoxes = []; // HTML-Elemente f√ºr voreingestellte Farben

let mainDirectionalLight, fillDirectionalLight, hemisphereLight; // Lichter in der Szene
let isShiftDragging = false; // Flag, ob Shift-Taste gedr√ºckt ist
let isControlDragging = false; // Flag, ob Control-Taste gedr√ºckt ist
let isPointerLocked = false; // Flag, ob Pointer-Lock aktiv ist
let lastActionVoxelCoords = null; // Speichert die Koordinaten des zuletzt bearbeiteten Voxels w√§hrend eines Drags
let initialClickPos = null; // Speichert die anf√§ngliche Pointer-Position f√ºr Klick/Drag-Unterscheidung
let initialTargetVoxelCoords = null; // Das Voxel, das beim initialen Klick getroffen wurde (oder hinzugef√ºgt werden w√ºrde)
let isDragging = false; // Flag, ob eine Drag-Operation aktiv ist (√ºber den MOVE_PX-Schwellenwert hinaus)
let firstMoveAfterLock = true; // Flag f√ºr die erste Bewegung nach Pointer-Lock
let mouseMovementX = 0; // Mausbewegung in X-Richtung
let mouseMovementY = 0; // Mausbewegung in Y-Richtung

const dummy = new THREE.Object3D(); // Dummy-Objekt f√ºr InstancedMesh-Transformationen
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS); // Geometrie f√ºr das Vorschau-Voxel
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // Material f√ºr das Vorschau-Voxel
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Mesh f√ºr das Vorschau-Voxel

// Definition der verschiedenen Modi und ihrer Icons
const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
};

const ModeIcons = {
    ADD: 'fas fa-plus',
    DELETE: 'fas fa-eraser', // Changed from trash to eraser for less destructive feel
    DRAW: 'fas fa-paint-brush'
};

const AxisIcons = { // Still defined for desktop, but not used for mobile UI
    x: 'fas fa-arrows-alt-h',
    y: 'fas fa-arrows-alt-v',
    z: 'fas fa-arrows-alt'
};

let currentMode = Modes.ADD; // Aktueller Modus

let history = []; // Verlauf der Aktionen f√ºr Undo/Redo
let historyPointer = -1; // Zeiger im Verlauf
const MAX_HISTORY_SIZE = 100; // Maximale Gr√∂√üe des Verlaufs

// currentStrokeVoxels speichert alle √Ñnderungen f√ºr die aktuelle Drag-Operation, die in einem Batch auf pointerUp angewendet werden
// Map: gKey -> { originalColor: 'hex', finalColor: 'hex' }
let currentStrokeVoxels = new Map();
let voxelsAtDragStart = null; // Schnappschuss der Haupt-Voxel-Map zu Beginn eines Drags

let previewLineInstancedMesh; // Instanziiertes Mesh f√ºr die Linienvorschau
const maxPreviewInstances = 180 * 3; // Maximale m√∂gliche Voxel f√ºr eine Linienvorschau (GRID * 3 Achsen)
let previewLineVoxels = []; // Wird verwendet, um tempor√§re Voxel f√ºr die Linienvorschau zu speichern

let templateImageMesh = null; // Mesh f√ºr die Bildvorlage
let templateImageData = null; // Daten der Bildvorlage

let isMobile = window.matchMedia('(max-width: 768px)').matches; // Pr√ºft, ob es sich um ein mobiles Ger√§t handelt

let initialDragVoxelWorldPos = null; // Weltposition des initialen Drag-Voxels
let dragAxisLock = null; // Gesperrte Achse w√§hrend des Drags

let projectTitle = ''; // Titel des Projekts
let projectDescription = ''; // Beschreibung des Projekts
let projectCategory = 'Allgemein'; // Kategorie des Projekts
let projectTags = []; // Tags des Projekts
let projectRemixOf = ''; // ID des Projekts, von dem dieses ein Remix ist
let projectSourceJsonUrl = ''; // URL der urspr√ºnglichen JSON-Datei
let projectVisibility = 'public'; // Sichtbarkeit des Projekts (√∂ffentlich/privat)

const predefinedCategories = ["Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein", "Charaktere", "Fahrzeuge", "Natur", "Architektur", "Abstrakt"]; // Vordefinierte Kategorien

let auth, db, currentUserId, currentUser; // Firebase-Authentifizierungs- und Firestore-Objekte
let toastContainer; // Global deklariert, um von handleMediaQueryChange zug√§nglich zu sein

// VoxelShaperIO f√ºr OBJ-Export
const VoxelShaperIO = {
    voxToOBJ: function(voxModel, voxelSize) {
        let obj = '# VoxelShaper OBJ Export\n';
        let mtls = '# VoxelShaper MTL Export\n';
        let vertexCount = 0;
        const materials = new Map(); // Map: Farb-Hex -> Materialname

        // Sammelt eindeutige Farben und weist Materialnamen zu
        voxModel.voxels.forEach(v => {
            if (!materials.has(v.color)) {
                const matName = `material_${materials.size + 1}`;
                materials.set(v.color, matName);
                const c = new THREE.Color(v.color);
                mtls += `newmtl ${matName}\n`;
                mtls += `Kd ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`; // Diffuse Farbe
                mtls += `Ka ${c.r.toFixed(4)} ${c.g.toFixed(4)} ${c.b.toFixed(4)}\n`; // Ambient Farbe
                mtls += `Ks 0.0 0.0 0.0\n`; // Spekulare Farbe (kein Glanz)
                mtls += `Ns 0.0\n`; // Glanz
                mtls += `d 1.0\n`; // Aufl√∂sung (Alpha)
                mtls += `illum 1\n\n`; // Beleuchtungsmodell
            }
        });

        obj += `mtllib voxel_model.mtl\n`; // Verweis auf die MTL-Datei im OBJ

        // Define normals once at the beginning of the OBJ file
        obj += '# Vertex Normals\n';
        const normals = [
            new THREE.Vector3(0, 0, 1),  // 1: +Z (Front)
            new THREE.Vector3(0, 0, -1), // 2: -Z (Back)
            new THREE.Vector3(1, 0, 0),  // 3: +X (Right)
            new THREE.Vector3(-1, 0, 0), // 4: -X (Left)
            new THREE.Vector3(0, 1, 0),  // 5: +Y (Top)
            new THREE.Vector3(0, -1, 0)   // 6: -Y (Bottom)
        ];
        normals.forEach(n => {
            obj += `vn ${n.x.toFixed(4)} ${n.y.toFixed(4)} ${n.z.toFixed(4)}\n`;
        });
        obj += '\n';


        voxModel.voxels.forEach(v => {
            const x = v.x * voxelSize;
            const y = v.y * voxelSize;
            const z = v.z * voxelSize;

            // Vertices f√ºr einen Einheitsw√ºrfel (relativ zum Ursprung des aktuellen Voxels f√ºr einfachere Indizierung)
            const verts = [
                [x, y, z],           // 0: --- (0,0,0)
                [x + voxelSize, y, z],       // 1: +-- (1,0,0)
                [x, y + voxelSize, z],       // 2: -+- (0,1,0)
                [x + voxelSize, y + voxelSize, z],   // 3: ++- (1,1,0)
                [x, y, z + voxelSize],       // 4: --+ (0,0,1)
                [x + voxelSize, y, z + voxelSize],   // 5: +-+ (1,0,1)
                [x, y + voxelSize, z + voxelSize],   // 6: -++ (0,1,1)
                [x + voxelSize, y + voxelSize, z + voxelSize]    // 7: +++ (1,1,1)
            ];

            verts.forEach(vert => {
                obj += `v ${vert[0].toFixed(4)} ${vert[1].toFixed(4)} ${vert[2].toFixed(4)}\n`;
            });

            const matName = materials.get(v.color);
            obj += `usemtl ${matName}\n`;

            // Definieren der Fl√§chen mit Vertex-Indizes (1-basiert relativ zum ersten Vertex dieses Blocks)
            // Removed face culling here to ensure manifold correctness. All 6 faces are exported.
            const baseIdx = vertexCount; // Aktueller Startindex f√ºr die Vertices dieses Voxels

            // Front Face (+Z) - Normal Index 1
            obj += `f ${baseIdx + 5}//1 ${baseIdx + 6}//1 ${baseIdx + 8}//1 ${baseIdx + 7}//1\n`;
            // Back Face (-Z) - Normal Index 2
            obj += `f ${baseIdx + 1}//2 ${baseIdx + 3}//2 ${baseIdx + 4}//2 ${baseIdx + 2}//2\n`;
            // Right Face (+X) - Normal Index 3
            obj += `f ${baseIdx + 2}//3 ${baseIdx + 6}//3 ${baseIdx + 8}//3 ${baseIdx + 4}//3\n`;
            // Left Face (-X) - Normal Index 4
            obj += `f ${baseIdx + 1}//4 ${baseIdx + 3}//4 ${baseIdx + 7}//4 ${baseIdx + 5}//4\n`;
            // Top Face (+Y) - Normal Index 5
            obj += `f ${baseIdx + 3}//5 ${baseIdx + 4}//5 ${baseIdx + 8}//5 ${baseIdx + 7}//5\n`;
            // Bottom Face (-Y) - Normal Index 6
            obj += `f ${baseIdx + 1}//6 ${baseIdx + 5}//6 ${baseIdx + 6}//6 ${baseIdx + 2}//6\n`;

            vertexCount += 8;
        });

        return { obj: obj, mtl: mtls };
    },
    saveBlob: function(data, filename) {
        const objBlob = new Blob([data.obj], { type: 'text/plain' });
        const mtlBlob = new Blob([data.mtl], { type: 'text/plain' });

        const objUrl = URL.createObjectURL(objBlob);
        const mtlUrl = URL.createObjectURL(mtlBlob);

        const aObj = document.createElement('a');
        aObj.href = objUrl;
        aObj.download = filename;
        document.body.appendChild(aObj);
        aObj.click();
        document.body.removeChild(aObj);
        URL.revokeObjectURL(objUrl);

        const aMtl = document.createElement('a');
        aMtl.href = mtlUrl;
        aMtl.download = filename.replace('.obj', '.mtl'); // Stellt sicher, dass die MTL-Datei den richtigen Namen hat
        document.body.appendChild(aMtl);
        aMtl.click();
        document.body.removeChild(aMtl);
        URL.revokeObjectURL(mtlUrl);
    },
    VoxModel: function(width, height, depth, voxels) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.voxels = voxels; // Array von {x, y, z, color}
    }
};


// Gibt die Chunk-Koordinaten f√ºr eine globale Voxel-Koordinate zur√ºck
function getChunkCoords(gx, gy, gz) { return { cx: Math.floor(gx / CHUNK_SIZE), cy: Math.floor(gy / CHUNK_SIZE), cz: Math.floor(gz / CHUNK_SIZE) }; }
// Erzeugt einen Key f√ºr Chunk-Koordinaten
function getChunkKey(cx, cy, cz) { return `${cx},${cy},${cz}`; }

// Klasse f√ºr Voxel-Chunks zur effizienten Verwaltung von Voxeln
class VoxelChunk {
    constructor(chunkX, chunkY, chunkZ, chunkSize, scene) {
        this.chunkX = chunkX; this.chunkY = chunkY; this.chunkZ = chunkZ; this.scene = scene; this.chunkSize = chunkSize;
        this.offsetX = chunkX * chunkSize * VS; this.offsetY = chunkY * chunkSize * VS; this.offsetZ = chunkZ * chunkSize * VS;
        this.voxels = new Map(); this.globalToLocalInstanceIdMap = new Map();
        const maxInstancesInChunk = chunkSize * chunkSize * chunkSize;
        const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
        const meshMaterial = new THREE.MeshLambertMaterial();
        this.instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxInstancesInChunk);
        this.instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstancesInChunk * 3), 3);
        this.instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
        this.instancedMesh.castShadow = true; this.instancedMesh.receiveShadow = true; this.instancedMesh.count = 0;
        this.instancedMesh.position.set(this.offsetX, this.offsetY, this.offsetZ);
        this.scene.add(this.instancedMesh);
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3(this.offsetX, this.offsetY, this.offsetZ),
            new THREE.Vector3(this.offsetX + chunkSize * VS, this.offsetY + chunkSize * VS, this.offsetZ + chunkSize * VS)
        );
    }
    // Gibt den lokalen Key innerhalb des Chunks zur√ºck
    getLocalKey(gx, gy, gz) { return key(gx % this.chunkSize, gy % this.chunkSize, gz % this.chunkSize); }
    // F√ºgt ein Voxel hinzu oder aktualisiert es
    addVoxel(gx, gy, gz, colorHex) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (this.voxels.has(lKey)) {
            const instanceId = this.voxels.get(lKey).instanceId;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.updateInstanceColor(instanceId, colorHex);
        } else {
            const instanceId = this.instancedMesh.count++;
            this.voxels.set(lKey, { color: colorHex, instanceId }); this.globalToLocalInstanceIdMap.set(gKey, instanceId);
            dummy.position.set((gx % this.chunkSize) * VS + HALF, (gy % this.chunkSize) * VS + HALF, (gz % this.chunkSize) * VS + HALF);
            dummy.updateMatrix(); this.instancedMesh.setMatrixAt(instanceId, dummy.matrix);
            this.updateInstanceColor(instanceId, colorHex);
            this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
        }
    }
    // Entfernt ein Voxel
    removeVoxel(gx, gy, gz) {
        const lKey = this.getLocalKey(gx, gy, gz); const gKey = key(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId: removedId } = this.voxels.get(lKey);
        this.voxels.delete(lKey); this.globalToLocalInstanceIdMap.delete(gKey);
        const lastId = this.instancedMesh.count - 1;
        if (removedId !== lastId) {
            let lastVoxelLKey = null;
            for (const [lk, data] of this.voxels.entries()) { if (data.instanceId === lastId) { lastVoxelLKey = lk; break; } }
            if (lastVoxelLKey !== null) {
                const tempMatrix = new THREE.Matrix4(); this.instancedMesh.getMatrixAt(lastId, tempMatrix);
                this.instancedMesh.setMatrixAt(removedId, tempMatrix);
                this.updateInstanceColor(removedId, this.voxels.get(lastVoxelLKey).color);
                this.voxels.get(lastVoxelLKey).instanceId = removedId;
                const [lx, ly, lz] = parseKey(lastVoxelLKey);
                this.globalToLocalInstanceIdMap.set(key(this.chunkX * this.chunkSize + lx, this.chunkY * this.chunkSize + ly, this.chunkZ * this.chunkSize + lz), removedId);
            }
        }
        this.instancedMesh.count--;
        this.instancedMesh.instanceMatrix.needsUpdate = true; this.instancedMesh.instanceColor.needsUpdate = true;
    }
    // F√§rbt ein Voxel neu
    recolorVoxel(gx, gy, gz, newColorHex) {
        const lKey = this.getLocalKey(gx, gy, gz);
        if (!this.voxels.has(lKey)) return;
        const { instanceId } = this.voxels.get(lKey);
        this.voxels.set(lKey, { color: newColorHex, instanceId: instanceId }); // Sicherstellen, dass instanceId erhalten bleibt
        this.updateInstanceColor(instanceId, newColorHex);
    }
    // Aktualisiert die Farbe einer Instanz im InstancedMesh
    updateInstanceColor(instanceId, hex) {
        const c = new THREE.Color(hex); this.instancedMesh.instanceColor.setXYZ(instanceId, c.r, c.g, c.b);
        this.instancedMesh.instanceColor.needsUpdate = true;
    }
    // Gibt den Chunk frei (entfernt ihn aus der Szene und gibt Ressourcen frei)
    dispose() {
        this.scene.remove(this.instancedMesh);
        this.instancedMesh.geometry.dispose(); this.instancedMesh.material.dispose();
        this.instancedMesh = null; this.voxels.clear(); this.globalToLocalInstanceIdMap.clear();
    }
}

// Passt die Gr√∂√üe des Renderers und der Kamera an die Fenstergr√∂√üe an
function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight; cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
}

// Behandelt Touch-Gesten f√ºr Kamera-Steuerung
function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    if (pointers.length === 1) {
        // One-finger drag for camera rotation
        const p = pointers[0];
        const rotateSpeed = isMobile ? ROTATE_SPEED_TOUCH_MOBILE : ROTATE_SPEED_TOUCH_DESKTOP;
        
        // Shapr3D-like rotation: Drag right -> rotate right (increase Y euler), Drag up -> rotate up (decrease X euler)
        euler.y += (p.x - gestureState.lastMid.x) * rotateSpeed;
        euler.x -= (p.y - gestureState.lastMid.y) * rotateSpeed; // Invert Y for intuitive up/down rotation
        
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const PINCH_REL_TH = 0.05; // Define PINCH_REL_TH here or globally if not already defined
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;
            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > MOVE_PX) { // Use MOVE_PX for pan threshold
                gestureState.type = 'pan';
            }
            return;
        } else if (gestureState.type === 'pinch') {
            const pinchZoomMult = isMobile ? PINCH_ZOOM_MULT_MOBILE : PINCH_ZOOM_MULT_DESKTOP;
            const zoomDelta = (dist / gestureState.lastDist - 1) * pinchZoomMult * moveSpeed;
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), zoomDelta);
            gestureState.lastDist = dist;
        } else if (gestureState.type === 'pan') {
            const panSpeed = isMobile ? PAN_SPEED_TOUCH_MOBILE : PAN_SPEED_TOUCH_DESKTOP;
            const dx = (midX - gestureState.lastMid.x) * panSpeed;
            const dy = (midY - gestureState.lastMid.y) * panSpeed;
            
            const right = new THREE.Vector3().crossVectors(cam.getWorldDirection(new THREE.Vector3()), cam.up).normalize();
            // Shapr3D-like pan: Drag right -> pan right, Drag up -> pan up
            cam.position.addScaledVector(right, dx); // Corrected direction
            cam.position.addScaledVector(new THREE.Vector3(0, 1, 0), dy); // Corrected direction (Y-axis for vertical pan)
            
            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}

// Setzt Pointer-Status zur√ºck
function releasePointer(id, eventType) {
    activePointers.delete(id);
    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) { const last = [...activePointers.values()][0]; gestureState.lastMid = { x: last.x, y: last.y }; }
    }
    if (activePointers.size === 0) {
        doubleTapDragActive = false; lastActionVoxelCoords = null; touchIndicator.style.display = 'none';
        initialDragVoxelWorldPos = null; dragAxisLock = null;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    }
}

// Baut Gitter- und Begrenzungshelfer neu auf
function rebuildHelpers() {
    if (gridHelper) scene.remove(gridHelper); if (boxHelper) scene.remove(boxHelper);
    const size = GRID * VS;
    // On mobile, default to Y-axis for simplicity. Desktop can still change.
    if (isMobile) {
        currentDrawingAxis = 'y'; // Force Y-axis for mobile
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else {
        if (currentDrawingAxis === 'y') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 ); gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
        } else if (currentDrawingAxis === 'x') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.z = Math.PI / 2; gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
        } else if (currentDrawingAxis === 'z') {
            gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444); gridHelper.rotation.x = Math.PI / 2; gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
        }
    }
    scene.add(gridHelper);
    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2); scene.add(boxHelper);
}

// Aktualisiert die Position des Gitter-Helfers und speichert sie
function updateGridHelperPosition() {
    console.log("Updating grid helper position. activeDrawingLevel:", activeDrawingLevel.x, activeDrawingLevel.y, activeDrawingLevel.z, "currentDrawingAxis:", currentDrawingAxis);
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

// Wechselt den Modus (Hinzuf√ºgen, L√∂schen, Zeichnen)
function cycleMode() {
    const activeElement = document.activeElement;
    if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
        cvs.focus(); return;
    }
    switch (currentMode) {
        case Modes.ADD: currentMode = Modes.DELETE; break;
        case Modes.DELETE: currentMode = Modes.DRAW; break;
        case Modes.DRAW: currentMode = Modes.ADD; break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    // Update mobile icon for mode toggle
    const mobileModeIcon = document.getElementById('mobile-mode-icon');
    if (mobileModeIcon) {
        mobileModeIcon.className = ModeIcons[currentMode];
        console.log(`Setting mobile mode icon to: ${ModeIcons[currentMode]}`); // Debugging
    } else {
        console.warn("mobileModeIcon element not found!"); // Debugging
    }
    lastActionVoxelCoords = null; updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
}

// Setzt eine voreingestellte Farbe als aktuelle Farbe
function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        // Sync mobile color input if it exists
        const mobileColorInput = document.getElementById('mobile-color-input');
        if (mobileColorInput) mobileColorInput.value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach((box, i) => {
            if (i === index) { box.classList.add('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
            else { box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); }
        });
        activePresetIndex = index;
        // Sofortiges Update des Vorschau-Voxels, wenn sichtbar
        if (previewVoxelMesh.visible) {
            previewVoxelMaterial.color.set(currentColor);
        }
    }
}

// Speichert eine Farbe in den Voreinstellungen
function savePresetColor(index, colorValue) {
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue;
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue);
        if (activePresetIndex === index) {
            currentColor = colorValue;
            document.getElementById('color-picker').value = currentColor;
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            localStorage.setItem('voxelEditorColor', currentColor);
        }
    }
}

// Wendet einen Voxel-Zustand an (f√ºr Undo/Redo)
function applyVoxelState(state) {
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear();
    state.forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
}

// F√ºgt einen Befehl zum Verlauf hinzu
function addCommand(type, oldState = null, newState = null, commandData = null) {
    if (historyPointer < history.length - 1) history.splice(historyPointer + 1);
    history.push({ type, oldState, newState, commandData }); historyPointer++;
    if (history.length > MAX_HISTORY_SIZE) { history.shift(); historyPointer--; }
}

// F√ºhrt einen Befehl aus (f√ºr Undo/Redo)
function executeCommand(command, reverse = false) {
    const { type, oldState, newState, commandData } = command;
    switch (type) {
        case 'batch': applyVoxelState(reverse ? oldState : newState); break;
        case 'clearAll': clearAllInternal(true); if (reverse) applyVoxelState(oldState); break;
        case 'fillLevel': applyVoxelState(reverse ? oldState : newState); break;
        case 'resizeGrid':
            GRID = reverse ? commandData.oldGrid : commandData.newGrid;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            applyVoxelState(reverse ? oldState : newState); break;
    }
    rebuildHelpers();
}

// Macht die letzte Aktion r√ºckg√§ngig
function undo() { if (historyPointer >= 0) { executeCommand(history[historyPointer], true); historyPointer--; } }
// Wiederholt die letzte r√ºckg√§ngig gemachte Aktion
function redo() { if (historyPointer < history.length - 1) { historyPointer++; executeCommand(history[historyPointer], false); } }

// F√ºgt ein einzelnes Voxel hinzu
function _addSingleVoxel(gx, gy, gz, colorHex) {
    const gKey = key(gx, gy, gz); voxels.set(gKey, { color: colorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    let chunk = chunks.get(cKey);
    if (!chunk) { chunk = new VoxelChunk(cx, cy, cz, CHUNK_SIZE, scene); chunks.set(cKey, chunk); }
    chunk.addVoxel(gx, gy, gz, colorHex);
}

// Entfernt ein einzelnes Voxel
function _removeSingleVoxel(gx, gy, gz) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.delete(gKey);
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) {
        const chunk = chunks.get(cKey); chunk.removeVoxel(gx, gy, gz);
        if (chunk.instancedMesh.count === 0) { chunk.dispose(); chunks.delete(cKey); }
    }
}

// F√§rbt ein einzelnes Voxel neu
function _recolorSingleVoxel(gx, gy, gz, newColorHex) {
    const gKey = key(gx, gy, gz); if (!voxels.has(gKey)) return;
    voxels.set(gKey, { color: newColorHex });
    const { cx, cy, cz } = getChunkCoords(gx, gy, gz); const cKey = getChunkKey(cx, cy, cz);
    if (chunks.has(cKey)) chunks.get(cKey).recolorVoxel(gx, gy, gz, newColorHex);
}

// F√ºhrt eine Voxel-Modifikation basierend auf dem Modus aus
function performVoxelModification(gx, gy, gz, mode, newColor) { // newColor kann null f√ºr L√∂schen sein
    const gKey = key(gx, gy, gz);
    const hasVoxel = voxels.has(gKey);

    // Koordinaten auf Gittergrenzen klemmen
    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    switch (mode) {
        case Modes.ADD:
            if (!hasVoxel) {
                _addSingleVoxel(gx, gy, gz, newColor);
            }
            break;
        case Modes.DELETE:
            if (hasVoxel) {
                _removeSingleVoxel(gx, gy, gz);
            }
            break;
        case Modes.DRAW:
            if (hasVoxel) {
                if (voxels.get(gKey).color !== newColor) {
                    _recolorSingleVoxel(gx, gy, gz, newColor);
                }
            }
            break;
    }
}

// Aktualisiert das Vorschau-Voxel
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            // Immer 1x1x1 f√ºr die Vorschau
            if (previewVoxelMesh.geometry.parameters.width !== VS ||
                previewVoxelMesh.geometry.parameters.height !== VS ||
                previewVoxelMesh.geometry.parameters.depth !== VS) {
                previewVoxelMesh.geometry.dispose();
                previewVoxelMesh.geometry = new THREE.BoxGeometry(VS, VS, VS);
            }
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor);
            previewVoxelMaterial.opacity = (currentMode === Modes.DELETE) ? 0.2 : 0.5;
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}

// Berechnet die Voxel-Koordinaten, auf die der Ray trifft
function calculateRayTargetVoxelCoords(clientX, clientY) {
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = Array.from(chunks.values()).map(chunk => chunk.instancedMesh);
    // Bildvorlage vom Raycasting ignorieren
    if (templateImageMesh) {
        templateImageMesh.raycast = function() {}; // Deaktiviert Raycasting f√ºr das Bild
    }

    const intersects = raycaster.intersectObjects(objectsToIntersect);

    if (intersects.length > 0) {
        const hit = intersects[0];
        const hitNormal = hit.face.normal.clone();
        const intersectionPoint = hit.point;

        // Sicherstellen, dass Koordinaten endlich sind, bevor sie gerundet werden
        if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
            console.warn("Intersection point has non-finite coordinates. Skipping hit.");
            return null;
        }

        // Den Schnittpunkt leicht nach innen entlang der inversen Normalen verschieben
        // Dies stellt sicher, dass wir die Koordinaten des tats√§chlich getroffenen Voxels erhalten.
        const epsilon = 0.001; // Kleiner Offset
        const adjustedPoint = intersectionPoint.clone().addScaledVector(hitNormal, -epsilon);

        const hitVoxelX = Math.floor(adjustedPoint.x / VS);
        const hitVoxelY = Math.floor(adjustedPoint.y / VS);
        const hitVoxelZ = Math.floor(adjustedPoint.z / VS);
        
        // F√ºge hitExistingVoxel: true hinzu, da ein Voxel getroffen wurde
        const result = { gx: Number(hitVoxelX), gy: Number(hitVoxelY), gz: Number(hitVoxelZ), faceNormal: hitNormal, hitExistingVoxel: true };
        if (!Number.isFinite(result.gx) || !Number.isFinite(result.gy) || !Number.isFinite(result.gz)) {
            console.error("calculateRayTargetVoxelCoords: Final result from object intersection has non-finite coordinates:", result);
            return null;
        }
        return result;
    } else {
        // Keine Schnittmenge mit vorhandenen Voxeln, versuchen, mit der aktiven Zeichenebene zu schneiden
        let planeNormal = new THREE.Vector3();
        let planeConstant = 0;

        if (currentDrawingAxis === 'y') {
            planeNormal.set(0, 1, 0);
            planeConstant = -(activeDrawingLevel.y * VS);
        } else if (currentDrawingAxis === 'x') {
            planeNormal.set(1, 0, 0);
            planeConstant = -(activeDrawingLevel.x * VS);
        } else if (currentDrawingAxis === 'z') {
            planeNormal.set(0, 0, 1);
            planeConstant = -(activeDrawingLevel.z * VS);
        }

        const drawingPlane = new THREE.Plane(planeNormal, planeConstant);
        const intersectionPoint = new THREE.Vector3();

        if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
            // Sicherstellen, dass Koordinaten endlich sind, bevor sie gerundet werden
            if (!Number.isFinite(intersectionPoint.x) || !Number.isFinite(intersectionPoint.y) || !Number.isFinite(intersectionPoint.z)) {
                console.warn("Plane intersection point has non-finite coordinates. Skipping hit.");
                return null;
            }

            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // An die aktive Zeichenebene f√ºr die jeweilige Achse anpassen
            if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
            else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
            else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

            // Ensure all are numbers and finite before creating the result object
            gx = Number(gx);
            gy = Number(gy);
            gz = Number(gz);

            if (!Number.isFinite(gx) || !Number.isFinite(gy) || !Number.isFinite(gz)) {
                console.error("calculateRayTargetVoxelCoords: Final calculated voxel coordinates from plane intersection are non-finite:", { gx, gy, gz });
                return null;
            }

            // F√ºge hitExistingVoxel: false hinzu, da nur die Ebene getroffen wurde
            const result = { gx, gy, gz, faceNormal: null, hitExistingVoxel: false };
            return result;
        }
    }
    return null;
}

// L√∂scht alle Voxel (intern)
function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
        addCommand('clearAll', oldState, []);
    }
    for (const chunk of chunks.values()) chunk.dispose();
    chunks.clear(); voxels.clear(); rebuildHelpers();
}
// L√∂scht alle Voxel
function clearAll() { clearAllInternal(false); }

// F√ºllt die aktive Zeichenebene mit Voxeln
function fillActiveLevel() {
    const oldState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        const k = key(gx, gy, gz); if (voxels.has(k)) voxelsToRemove.push(k);
    }}
    voxelsToRemove.forEach(k => { const [gx, gy, gz] = parseKey(k); _removeSingleVoxel(gx, gy, gz); });
    const newState = [];
    for (let x = 0; x < GRID; x++) { for (let z = 0; z < GRID; z++) {
        let gx, gy, gz;
        if (currentDrawingAxis === 'y') { gx = x; gy = activeDrawingLevel.y; gz = z; }
        else if (currentDrawingAxis === 'x') { gx = activeDrawingLevel.x; gy = x; gz = z; }
        else if (currentDrawingAxis === 'z') { gx = x; gy = z; gz = activeDrawingLevel.z; }
        _addSingleVoxel(gx, gy, gz, currentColor); newState.push({ gx, gy, gz, color: currentColor, dimX: 1, dimY: 1, dimZ: 1 });
    }}
    addCommand('fillLevel', oldState, newState);
}

// Speichert das aktuelle Projekt als JSON-Datei
function saveJSON() {
    const data = {}; // Enth√§lt die Voxel-Daten im Format "x,y,z": "color"
    voxels.forEach((value, k) => {
        const [gx, gy, gz] = parseKey(k);
        data[`${gx},${gy},${gz}`] = value.color;
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed,
        templateImageData: templateImageData // Bildvorlagen-Daten beibehalten
    };

    // Das Hauptobjekt, das in der JSON-Datei gespeichert wird
    const fileContent = {
        // Top-Level-Metadaten f√ºr das Projekt (n√ºtzlich, wenn diese Datei direkt geteilt wird)
        title: projectTitle,
        description: projectDescription,
        category: projectCategory,
        tags: projectTags,
        remixOf: projectRemixOf,
        sourceJsonUrl: projectSourceJsonUrl,
        visibility: projectVisibility, // Nicht strikt f√ºr lokale Datei verwendet, aber gut f√ºr Konsistenz
        fileName: `${projectTitle.replace(/\s+/g, "_") || "voxel_project"}.json`,
        timestamp: new Date().toISOString(), // ISO-String f√ºr konsistentes Datumsformat

        // Die eigentlichen Projektdaten (Einstellungen und Voxel)
        projectData: {
            settings: settings,
            voxels: data
        }
    };

    const blob = new Blob([JSON.stringify(fileContent, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileContent.fileName; // Dynamisch generierten Dateinamen verwenden
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('Speichern erfolgreich', 'Projekt als JSON-Datei gespeichert.', 'success');
}

// Setzt das Projekt auf den Standardzustand zur√ºck
function resetToDefaultProject() {
    clearAllInternal(true); GRID = 10;
    document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
    currentColor = '#ffffff'; document.getElementById('color-picker').value = currentColor; localStorage.setItem('voxelEditorColor', currentColor);
    // Sync mobile color input if it exists
    const mobileColorInput = document.getElementById('mobile-color-input');
    if (mobileColorInput) mobileColorInput.value = currentColor;

    activeDrawingLevel = { x: 0, y: 0, z: 0 }; currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
    moveSpeed = 0.1; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    presetColors[0] = '#E4002B'; presetColors[1] = '#00A040'; presetColors[2] = '#0057B8';
    localStorage.setItem('voxelPresetColor1', presetColors[0]); localStorage.setItem('voxelPresetColor2', presetColors[1]); localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => { box.value = presetColors[i]; box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'); });
    activePresetIndex = -1; removeImageTemplate(true); history.length = 0; historyPointer = -1;
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    projectTitle = ''; projectDescription = ''; projectCategory = 'Allgemein'; projectTags = []; projectRemixOf = ''; projectSourceJsonUrl = ''; projectVisibility = 'public';
    rebuildHelpers(); resetCameraPosition(); showToast('Projekt zur√ºckgesetzt', 'Das Projekt wurde auf den Standardzustand zur√ºckgesetzt.', 'info');
}

// L√§dt Projektdaten aus einem Objekt
function loadProjectData(projectData) {
    try {
        const loadedVoxels = projectData.projectData ? projectData.projectData.voxels : projectData.voxels;
        const loadedSettings = projectData.projectData ? projectData.projectData.settings : projectData.settings;
        clearAllInternal(true); removeImageTemplate(true);
        projectTitle = projectData.title || ''; projectDescription = projectData.description || '';
        projectCategory = projectData.category || 'Allgemein';
        projectTags = Array.isArray(projectData.tags) ? projectData.tags : (typeof projectData.tags === 'string' ? projectData.tags.split(',').map(tag => tag.trim()).filter(tag => tag !== '') : []);
        projectRemixOf = projectData.remixOf || ''; projectSourceJsonUrl = projectData.sourceJsonUrl || ''; projectVisibility = projectData.visibility || 'public';

        if (loadedSettings) {
            GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
            document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
        }
        for (const k in loadedVoxels) {
            const colorValue = loadedVoxels[k]; const parts = k.split(',').map(Number);
            if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                const gx = parts[0]; const gy = parts[1]; const gz = parts[2];
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) _addSingleVoxel(gx, gy, gz, colorValue);
            }
        }
        if (loadedSettings) {
            if (loadedSettings.cameraPosition) cam.position.fromArray(loadedSettings.cameraPosition);
            if (loadedSettings.cameraQuaternion) { cam.quaternion.fromArray(loadedSettings.cameraQuaternion); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
            if (loadedSettings.activeDrawingLevel) {
                activeDrawingLevel = {
                    x: Number(loadedSettings.activeDrawingLevel.x || 0),
                    y: Number(loadedSettings.activeDrawingLevel.y || 0),
                    z: Number(loadedSettings.activeDrawingLevel.z || 0)
                };
                if (!Number.isFinite(activeDrawingLevel.x)) activeDrawingLevel.x = 0;
                if (!Number.isFinite(activeDrawingLevel.y)) activeDrawingLevel.y = 0;
                if (!Number.isFinite(activeDrawingLevel.z)) activeDrawingLevel.z = 0;

                activeDrawingLevel.x = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x)));
                activeDrawingLevel.y = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y)));
                activeDrawingLevel.z = Math.floor(Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z)));

                localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
            }
            if (loadedSettings.currentDrawingAxis) { currentDrawingAxis = loadedSettings.currentDrawingAxis; localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis); }
            updateGridHelperPosition();
            currentColor = loadedSettings.currentColor || '#ffffff'; document.getElementById('color-picker').value = currentColor;
            // Sync mobile color input if it exists
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;

            if (loadedSettings.presetColors) {
                for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                    presetColors[i] = loadedSettings.presetColors[i]; document.getElementById(`color-preset-${i + 1}`).value = presetColors[i]; localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                }
            }
            setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);
            if (loadedSettings.moveSpeed !== undefined) {
                moveSpeed = loadedSettings.moveSpeed; document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            }
            // currentBlockSize, dynamicBlockDim, useDynamicBlockDim Logik wurde entfernt, daher hier nicht wiederhergestellt
            if (loadedSettings.templateImageData) {
                templateImageData = loadedSettings.templateImageData;
                new THREE.TextureLoader().load(templateImageData.src, (texture) => {
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                    const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                    if (templateImageMesh) { scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose(); }
                    templateImageMesh = new THREE.Mesh(geometry, material);
                    templateImageMesh.position.fromArray(templateImageData.position); templateImageMesh.rotation.fromArray(templateImageData.rotation); templateImageMesh.scale.fromArray(templateImageData.scale);
                    templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
                    document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
                }, undefined, (err) => { console.error('Error loading template image texture:', err); templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden'); });
            }
        }
        history.length = 0; historyPointer = -1;
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        resetCameraPosition();
    } catch (error) {
        console.error('Error loading JSON file:', error);
        showToast('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error');
        resetToDefaultProject();
    }
}

// L√§dt ein Projekt anhand seiner Modell-ID vom Hub
async function loadProjectFromModelId(modelId) {
    showToast('Lade Projekt', `Lade Projekt mit ID: ${modelId}...`, 'info');
    try {
        const docSnap = await window.firebase.getDoc(window.firebase.doc(db, "models", modelId));
        if (docSnap.exists()) {
            const pData = docSnap.data();
            const isPublic = pData.visibility === 'public';
            const isOwner = auth.currentUser && auth.currentUser.uid === pData.uploaderUid;
            if (isPublic || isOwner) {
                if (pData && pData.projectData) {
                    projectRemixOf = modelId; projectSourceJsonUrl = window.location.href;
                    loadProjectData(pData);
                    showToast('Projekt geladen', `Projekt "${docSnap.data().title}" erfolgreich geladen.`, 'success');
                } else { showToast('Fehler', 'Projektdaten im Dokument nicht gefunden.', 'error'); resetToDefaultProject(); }
            } else { showToast('Zugriff verweigert', 'Sie haben keine Berechtigung, dieses private Projekt zu laden.', 'error'); resetToDefaultProject(); }
        } else { showToast('Projekt nicht gefunden', `Kein Projekt mit ID "${modelId}" gefunden.`, 'warning'); resetToDefaultProject(); }
    } catch (error) {
        console.error("Error loading project from model ID:", error);
        if (error.code === 'permission-denied') showToast('Zugriff verweigert', `Berechtigungsfehler beim Laden des Projekts. Stellen Sie sicher, dass das Modell √∂ffentlich ist oder Sie der Eigent√ºmer sind.`, 'error');
        else showToast('Fehler', `Fehler beim Laden des Projekts: ${error.message}`, 'error');
        resetToDefaultProject();
    }
}

// L√§dt ein Projekt aus einer JSON-Datei
function loadJSON(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            projectRemixOf = ''; projectSourceJsonUrl = ''; loadProjectData(projectData);
        } catch (error) {
            console.error('Error parsing file JSON:', error);
            showToast('Fehler', 'Fehler beim Parsen der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige JSON-Datei handelt. Fehler: ' + error.message, 'error');
            resetToDefaultProject();
        }
    };
    reader.readAsText(file);
}

// Exportiert das Modell als STL-Datei
function exportSTL() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning'); return; }
    const geometriesToMerge = []; const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF); dummy.updateMatrix();
        const instanceGeometry = tempBoxGeometry.clone(); instanceGeometry.applyMatrix4(dummy.matrix);
        const c = new THREE.Color(data.color);
        const vtxColorArr = []; for (let j = 0; j < instanceGeometry.attributes.position.count; j++) vtxColorArr.push(c.r, c.g, c.b);
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vtxColorArr, 3));
        geometriesToMerge.push(instanceGeometry);
    });
    const mergedGeometry = geometriesToMerge.length > 0 ? THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true) : new THREE.BufferGeometry();
    const tempMesh = new THREE.Mesh(mergedGeometry);
    if (typeof THREE.STLExporter === 'undefined') { showToast('Export fehlgeschlagen', 'STLExporter-Bibliothek nicht geladen.', 'error'); return; }
    const exporter = new THREE.STLExporter(); const result = exporter.parse(tempMesh);
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'voxel_model.stl';
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    tempBoxGeometry.dispose(); if (mergedGeometry) mergedGeometry.dispose();
    showToast('Export erfolgreich', 'STL-Modell erfolgreich exportiert!', 'success');
}

// Exportiert das Modell als OBJ-Datei mit MTL
function exportOBJ() {
    if (voxels.size === 0) { showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning'); return; }
    const voxelsToExport = []; let maxX = 0, maxY = 0, maxZ = 0;
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k); voxelsToExport.push({ x, y, z, color: data.color }); // Farbe f√ºr OBJ-Export √ºbergeben
        maxX = Math.max(maxX, x); maxY = Math.max(maxY, y); maxZ = Math.max(maxZ, z);
    });
    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    VoxelShaperIO.saveBlob(VoxelShaperIO.voxToOBJ(voxModel, VS), 'voxel_model.obj');
    showToast('Export erfolgreich', 'OBJ-Modell erfolgreich mit Farben exportiert!', 'success');
}

// Exportiert das Modell als GLB-Datei
function exportGLB() {
    if (voxels.size === 0) {
        showToast('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!', 'warning');
        return;
    }

    // Stelle sicher, dass der GLTFExporter geladen ist
    if (typeof THREE.GLTFExporter === 'undefined') {
        showToast('Export fehlgeschlagen', 'GLTFExporter-Bibliothek nicht geladen. Bitte versuchen Sie es erneut.', 'error');
        return;
    }

    const exporter = new THREE.GLTFExporter();
    const tempGroup = new THREE.Group();
    const tempGeometry = new THREE.BoxGeometry(VS, VS, VS); // Wiederverwendbare Geometrie

    // Cache f√ºr Materialien, um Duplikate zu vermeiden
    const materialCache = new Map();

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        const colorHex = data.color;

        let material = materialCache.get(colorHex);
        if (!material) {
            // Verwende MeshStandardMaterial f√ºr bessere Kompatibilit√§t mit PBR-Renderern wie Roblox
            material = new THREE.MeshStandardMaterial({ color: new THREE.Color(colorHex) });
            materialCache.set(colorHex, material);
        }

        const mesh = new THREE.Mesh(tempGeometry, material);
        mesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        tempGroup.add(mesh);
    });

    exporter.parse(
        tempGroup,
        function (result) {
            const blob = new Blob([result], { type: 'model/gltf-binary' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'voxel_model.glb';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('Export erfolgreich', 'GLB-Modell erfolgreich exportiert!', 'success');
        },
        function (error) {
            console.error('Error exporting GLB:', error);
            showToast('Export fehlgeschlagen', `Fehler beim Exportieren des GLB-Modells: ${error.message}`, 'error');
        },
        { binary: true } // Dies stellt die GLB-Ausgabe sicher
    );

    // Tempor√§re Ressourcen freigeben
    tempGeometry.dispose();
    materialCache.forEach(mat => mat.dispose()); // Alle gecachten Materialien freigeben
    // Meshes innerhalb der tempGroup werden von GLTFExporter automatisch freigegeben,
    // wenn sie nicht wiederverwendet werden. F√ºr explizite Bereinigung k√∂nnte man
    // die Meshes aus der Gruppe entfernen und einzeln freigeben, aber der Exporter
    // handhabt dies in der Regel.
    // Hier ist eine explizite Bereinigung, um sicherzustellen, dass keine Objekte im Speicher verbleiben:
    while(tempGroup.children.length > 0){
        const object = tempGroup.children[0];
        tempGroup.remove(object);
        // Da tempGeometry f√ºr alle Meshes verwendet wird, muss sie nur einmal entsorgt werden.
        // Das Material wird √ºber den materialCache entsorgt.
        // object.geometry.dispose(); // Nicht n√∂tig, da geteilt
        // object.material.dispose(); // Nicht n√∂tig, da gecacht und sp√§ter entsorgt
    }
}


// Zeigt eine Toast-Benachrichtigung an
function showToast(title, message, type = 'info', duration = 3000) {
    // const toastContainer = document.getElementById('toast-container'); // This line is now redundant
    const toast = document.createElement('div');
    toast.className = `alert shadow-lg ${type === 'info' ? 'alert-info' : type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : type === 'warning' ? 'alert-warning' : ''}`;
    toast.innerHTML = `
        ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
        ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        ${type === 'warning' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
        <div><strong>${title}</strong><br><span>${message}</span></div><button class="close-btn btn btn-ghost btn-sm">&times;</button>`;
    toastContainer.appendChild(toast);
    void toast.offsetWidth; toast.classList.add('show');
    toast.querySelector('.close-btn').addEventListener('click', () => { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); });
    setTimeout(() => { if (toast.parentNode) { toast.classList.remove('show'); toast.addEventListener('transitionend', () => toast.remove(), { once: true }); } }, duration);
}

// Setzt die Kamera-Position zur√ºck
function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5); cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) euler.setFromQuaternion(cam.quaternion, 'YXZ');
}

// L√§dt eine Bildvorlage
function loadImageTemplate() {
    console.log("loadImageTemplate aufgerufen, l√∂st Dateieingabe-Klick aus.");
    document.getElementById('imageFileInput').click();
}

// Behandelt die Auswahl einer Bilddatei f√ºr die Vorlage
function handleImageFileSelect(event) {
    console.log("handleImageFileSelect aufgerufen.");
    const file = event.target.files[0];
    if (!file) {
        console.log("Keine Datei ausgew√§hlt.");
        return;
    }
    console.log("Datei ausgew√§hlt:", file.name);
    const reader = new FileReader();
    reader.onload = (e) => {
        console.log("FileReader onload abgeschlossen.");
        const base64Image = e.target.result;
        const img = new Image();
        img.onload = () => {
            console.log("Image onload abgeschlossen. Bildabmessungen:", img.width, img.height);
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                console.log("Entferne vorhandenes Vorlagenbild-Mesh.");
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            templateImageMesh = new THREE.Mesh(geometry, material);

            // Aktualisierte Position f√ºr das Vorlagenbild: am hinteren Rand (z=0)
            // Zentriert auf X und Y, leicht hinter der z=0-Ebene, um Z-Fighting mit Voxeln bei z=0 zu vermeiden
            templateImageMesh.position.set((GRID * VS) / 2, (GRID * VS) / 2, -0.001);
            templateImageMesh.rotation.set(0, 0, 0); // Keine Rotation erforderlich, standardm√§√üig nach positivem Z ausgerichtet

            templateImageMesh.renderOrder = -1; scene.add(templateImageMesh);
            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1],
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            document.getElementById('removeImageTemplateBtn').classList.remove('hidden');
            showToast('Bildvorlage geladen', 'Bild als Vorlage erfolgreich geladen.', 'success');
        };
        img.onerror = (err) => {
            console.error("Fehler beim Laden des Bildes f√ºr die Vorlage:", err);
            showToast('Fehler', 'Bild konnte nicht geladen werden. Ung√ºltiges Bildformat?', 'error');
            templateImageMesh = null;
            templateImageData = null;
            document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        };
        img.src = base64Image;
    };
    reader.onerror = (err) => {
        console.error("FileReader-Fehler:", err);
        showToast('Fehler', 'Fehler beim Lesen der Bilddatei.', 'error');
    };
    reader.readAsDataURL(file);

    // Eingabewert l√∂schen, um die Auswahl derselben Datei nacheinander zu erm√∂glichen
    event.target.value = '';
}
// Entfernt die Bildvorlage
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh); templateImageMesh.geometry.dispose(); templateImageMesh.material.dispose();
        templateImageMesh = null; templateImageData = null; document.getElementById('removeImageTemplateBtn').classList.add('hidden');
        if (!fromLoad) showToast('Bildvorlage entfernt', 'Bildvorlage erfolgreich entfernt.', 'info');
    }
}

// Gibt die aktuellen Blockabmessungen zur√ºck (immer 1x1x1 in dieser Version)
function getCurrentBlockDimensions() {
    return { dimX: 1, dimY: 1, dimZ: 1 };
}

// Meldet den Benutzer an oder ab
async function loginLogout() {
    if (auth.currentUser) { try { await window.firebase.signOut(auth); showToast('Abgemeldet', 'Sie wurden erfolgreich abgemeldet.', 'info'); } catch (e) { console.error("Error signing out:", e); showToast('Fehler beim Abmelden', `Fehler: ${e.message}`, 'error'); } }
    else openAuthModal();
}

// √ñffnet das Upload-Modal
function openUploadModal() {
    if (!currentUserId) { openAuthModal(); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning'); return; }
    document.getElementById('uploadTitle').value = projectTitle; document.getElementById('uploadDescription').value = projectDescription;
    document.getElementById('uploadCategory').value = projectCategory; document.getElementById('uploadTags').value = projectTags.join(', ');
    document.querySelector(`input[name="uploadVisibility"][value="${projectVisibility}"]`).checked = true; // Korrigiert, um den Wert direkt zu verwenden
    const uploadCategorySelect = document.getElementById('uploadCategory');
    uploadCategorySelect.innerHTML = '<option value="" disabled selected>Kategorie ausw√§hlen</option>';
    predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; uploadCategorySelect.appendChild(opt); });
    uploadCategorySelect.value = projectCategory;
    document.getElementById('uploadProjectModal').showModal();
}

// L√§dt das Projekt auf den Hub hoch
async function uploadProjectToHub() {
    if (!currentUserId) { showToast('Fehler', 'Nicht angemeldet. Bitte melden Sie sich an, um hochzuladen.', 'error'); return; }
    if (voxels.size === 0) { showToast('Upload fehlgeschuldert', 'Die Szene ist leer. Bitte erstellen Sie zuerst ein Modell.', 'warning'); return; }
    const title = document.getElementById('uploadTitle').value.trim();
    const description = document.getElementById('uploadDescription').value.trim();
    const category = document.getElementById('uploadCategory').value;
    const tags = document.getElementById('uploadTags').value.split(',').map(tag => tag.trim()).filter(tag => tag !== '');
    const visibility = document.querySelector('input[name="uploadVisibility"]:checked').value;
    if (!title) { showToast('Fehler', 'Bitte geben Sie einen Titel f√ºr Ihr Projekt ein.', 'warning'); return; }
    if (!category) { showToast('Fehler', 'Bitte w√§hlen Sie eine Kategorie f√ºr Ihr Projekt aus.', 'warning'); 'warning'; return; }
    showToast('Lade hoch...', 'Ihr Projekt wird hochgeladen. Bitte warten Sie...', 'info', 5000);
    try {
        const voxelMap = {}; voxels.forEach((v, k) => { const [gx, gy, gz] = parseKey(k); voxelMap[`${gx},${gy},${gz}`] = v.color; });
        const firestoreSafeSettings = {
            gridSize: GRID, cameraPosition: cam.position.toArray(), cameraQuaternion: cam.quaternion.toArray(),
            activeDrawingLevel: activeDrawingLevel, currentDrawingAxis: currentDrawingAxis, currentColor: currentColor,
            presetColors: presetColors, activePresetIndex: activePresetIndex, moveSpeed: moveSpeed,
            templateImageData: null // Bilddaten nicht direkt in Firestore speichern
        };
        const firestoreDocument = {
            title: title, description: description, category: category, tags: tags, visibility: visibility,
            remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
            fileName: `${title.replace(/\s+/g, "_")}.json`, downloads: 0, rating: 0, ratingCount: 0, verified: false,
            userId: currentUserId, uploaderEmail: currentUser?.email || "", uploaderUid: currentUser?.uid || "",
            uploaderPhotoURL: currentUser?.photoURL || "", timestamp: window.firebase.serverTimestamp(),
            projectData: {
                description: description, remixOf: projectRemixOf || "", sourceJsonUrl: projectSourceJsonUrl || "",
                settings: firestoreSafeSettings, activeDrawingLevel: firestoreSafeSettings.activeDrawingLevel, activePresetIndex: firestoreSafeSettings.activePresetIndex,
                cameraPosition: firestoreSafeSettings.cameraPosition, cameraQuaternion: firestoreSafeSettings.cameraQuaternion,
                currentColor: firestoreSafeSettings.currentColor, currentDrawingAxis: firestoreSafeSettings.currentDrawingAxis,
                gridSize: firestoreSafeSettings.gridSize, moveSpeed: firestoreSafeSettings.moveSpeed, presetColors: firestoreSafeSettings.presetColors, templateImageData: null, voxels: voxelMap
            }
        };
        const docRef = await window.firebase.addDoc(window.firebase.collection(db, "models"), firestoreDocument);
        projectTitle = title; projectDescription = description; projectCategory = category; projectTags = tags; projectVisibility = visibility;
        if (!projectSourceJsonUrl) projectSourceJsonUrl = `https://hub.voxelshaper.com?modelId=${docRef.id}`;
        showToast('Erfolgreich hochgeladen', `Ihr Projekt wurde erfolgreich hochgeladen! ID: ${docRef.id}`, 'success');
    } catch (e) { console.error("Error uploading project:", e); showToast('Fehler beim Hochladen', `Fehler: ${e.message}`, 'error'); }
    finally { document.getElementById('uploadProjectModal').close(); }
}

// √ñffnet das Authentifizierungs-Modal
function openAuthModal() { document.getElementById('authModal').showModal(); document.getElementById('emailLoginForm').classList.add('hidden'); }
// Schlie√üt das Authentifizierungs-Modal
function closeAuthModal() { document.getElementById('authModal').close(); cvs.focus(); }

window.signInWithGoogle = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GoogleAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit Google angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing in with Google:", e); showToast('Anmeldefehler', `Google: ${e.message}`, 'error'); } }
window.signInWithGithub = async function() { try { await window.firebase.signInWithPopup(auth, new window.firebase.GithubAuthProvider()); showToast('Anmeldung erfolgreich', 'Mit GitHub angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing in with GitHub:", e); showToast('Anmelmelfehler', `GitHub: ${e.message}`, 'error'); } }
window.signInEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.signInWithEmailAndPassword(auth, email, password); showToast('Anmeldung erfolgreich', 'Mit E-Mail angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing in with Email/Password:", e); showToast('Anmeldefehler', `E-Mail: ${e.message}`, 'error'); } }
window.signUpEmailPassword = async function() { const email = document.getElementById('emailInput').value; const password = document.getElementById('passwordInput').value; try { await window.firebase.createUserWithEmailAndPassword(auth, email, password); showToast('Registrierung erfolgreich', 'Konto erstellt und angemeldet.', 'success'); closeAuthModal(); } catch (e) { console.error("Error signing up with Email/Password:", e); showToast('Registrierungsfehler', `E-Mail: ${e.message}`, 'error'); } }

// Schlie√üt alle Modals
function closeAllModals() {
    const modals = ['clearConfirmationModal', 'uploadProjectModal', 'authModal', 'ideaGeneratorModal']; // ideaGeneratorModal hinzugef√ºgt
    modals.forEach(id => { const modal = document.getElementById(id); if (modal && modal.open) modal.close(); });
}
window.closeAllModals = closeAllModals;

// Event-Handler f√ºr Pointer-Lock-√Ñnderungen
function onPointerLockChange() {
    if (document.pointerLockElement === cvs) { isPointerLocked = true; firstMoveAfterLock = true; mouseMovementX = mouseMovementY = 0; updatePreviewVoxel(0,0,0,false); euler.setFromQuaternion(cam.quaternion, 'YXZ'); }
    else { isPointerLocked = false; }
}

// Event-Handler f√ºr Mausrad-Ereignisse
function onMouseWheel(e) {
    e.preventDefault();
    if (e.altKey) {
        // Alt + Mausrad f√ºr Zeichenebenen-Bewegung (nur Desktop)
        if (!isMobile && (currentMode === Modes.ADD || currentMode === Modes.DRAW)) {
            if (e.shiftKey) { activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY))); currentDrawingAxis = 'z'; }
            else if (e.ctrlKey) { activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY))); currentDrawingAxis = 'x'; }
            else { activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY))); currentDrawingAxis = 'y'; }
            updateGridHelperPosition();
        } else { // Zoomt rein/raus, wenn nicht im Add/Draw-Modus mit Alt-Taste
            cam.position.addScaledVector(cam.getWorldDirection(new THREE.Vector3()), e.deltaY * 0.005 * moveSpeed * 5);
        }
    } else {
        // Normales Mausrad f√ºr Fluggeschwindigkeit
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed - Math.sign(e.deltaY) * 0.01));
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

const keyboard = {}; // Speichert den Zustand der Tastaturtasten
// Event-Handler f√ºr Tastendruck
function onKeyDown(e) {
    const activeModals = ['authModal', 'uploadProjectModal', 'clearConfirmationModal', 'ideaGeneratorModal'].some(id => document.getElementById(id).open); // ideaGeneratorModal hinzugef√ºgt
    if (activeModals) { if (e.key === 'Escape') { closeAllModals(); e.preventDefault(); } return; }
    keyboard[e.key.toLowerCase()] = true;
    if (e.key === 'Shift') isShiftDragging = true;
    if (e.key === 'Control' || e.metaKey) isControlDragging = true;
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { e.preventDefault(); redo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') e.preventDefault();
    if (e.key === 'Tab') { e.preventDefault(); cycleMode(); } // Keine Eingabefelder mehr f√ºr dynamische Blockgr√∂√üe
    switch (e.key) { case '1': setActivePreset(0); break; case '2': setActivePreset(1); break; case '3': setActivePreset(2); break; }
}

// Event-Handler f√ºr Tastenloslassen
function onKeyUp(e) {
    keyboard[e.key.toLowerCase()] = false;
    if (e.key === 'Shift') isShiftDragging = false;
    if (e.key === 'Control' || e.metaKey) isControlDragging = false;
}

// Event-Handler, wenn der Pointer das Canvas verl√§sst
function onPointerLeave(e) {
    // Only reset if a drag was in progress
    if (pointerIsDown && isDragging && currentStrokeVoxels.size > 0) {
        const oldState = [];
        const newState = [];
        for (const [gKey, change] of currentStrokeVoxels.entries()) {
            const [gx, gy, gz] = parseKey(gKey);
            oldState.push({ gx, gy, gz, color: change.originalColor });
            newState.push({ gx, gy, gz, color: change.finalColor });
        }
        if (oldState.length > 0) {
            addCommand('batch', oldState, newState);
        }
    }
    // Reset all states and previews
    pointerIsDown = false;
    isDragging = false; // Reset drag flag
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null; // Reset initial target
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear();
    updatePreviewVoxel(0, 0, 0, false);
    previewLineInstancedMesh.count = 0;
    previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
    previewLineVoxels = [];
    dragAxisLock = null;
}

let pointerIsDown = false; // Flag, ob der Pointer gedr√ºckt ist
let rightMouseButtonDown = false; // Flag, ob die rechte Maustaste gedr√ºckt ist
let lastX, lastY; // Letzte X/Y-Koordinaten des Pointers
let suppressNextTap = false; // Flag, um den n√§chsten Tap zu unterdr√ºcken

// Diese Funktion berechnet jetzt nur den Pfad, keine modusspezifische Logik
function getVoxelsOnLine(start, end) {
    // Zus√§tzliche Pr√ºfung auf endliche Koordinaten
    if (!start || !Number.isFinite(start.gx) || !Number.isFinite(start.gy) || !Number.isFinite(start.gz) ||
        !end || !Number.isFinite(end.gx) || !Number.isFinite(end.gy) || !Number.isFinite(end.gz)) {
        console.error("getVoxelsOnLine: Ung√ºltige (nicht-endliche) Start- oder Endkoordinaten.", start, end);
        return [];
    }
    const voxelsOnLine = [];
    let x1 = start.gx, y1 = start.gy, z1 = start.gz;
    let x2 = end.gx, y2 = end.gy, z2 = end.gz;
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1), dz = Math.abs(z2 - z1);
    let sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1, sz = (z1 < z2) ? 1 : -1;
    let dm = Math.max(dx, dy, dz);
    let x = x1, y = y1, z = z1;
    let p1 = 2 * dy - dm, p2 = 2 * dz - dm;

    for (let i = 0; i <= dm; i++) {
        const clampedX = Math.max(0, Math.min(GRID - 1, x));
        const clampedY = Math.max(0, Math.min(GRID - 1, y));
        const clampedZ = Math.max(0, Math.min(GRID - 1, z));
        voxelsOnLine.push({ gx: clampedX, gy: clampedY, gz: clampedZ }); // Keine Farbe hier
        
        if (dm === dx) { y += sy * (p1 > 0); p1 += 2 * dy; z += sz * (p2 > 0); p2 += 2 * dz; }
        else if (dm === dy) { x += sx * (p1 > 0); p1 += 2 * dx; z += sz * (p2 > 0); p2 += 2 * dz; }
        else { x += sx * (p1 > 0); p1 += 2 * dy; y += sy * (p2 > 0); p2 += 2 * dx; }
        if (dm === dx) x += sx; else if (dm === dy) y += sy; else z += sz;
    }
    return voxelsOnLine;
}

// Event-Handler f√ºr Pointer-Up-Ereignisse
function onPointerUp(e) {
    if (e.button === 2) { // Right-click (context menu)
        rightMouseButtonDown = false;
        document.exitPointerLock(); // Exit pointer lock if active
        // Eyedropper logic handled in onContextMenu
        return;
    }
    
    // Calculate total distance moved from initial click position
    const totalMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;

    // Determine if the action was a drag (moved past threshold or was a double-tap drag)
    const wasDrag = (totalMovedDist > MOVE_PX) || doubleTapDragActive || isDragging;

    if (wasDrag) { // It was a drag operation (mouse or touch)
        if (currentStrokeVoxels.size > 0) {
            const oldState = [];
            const newState = [];
            for (const [gKey, change] of currentStrokeVoxels.entries()) {
                const [gx, gy, gz] = parseKey(gKey);
                oldState.push({ gx, gy, gz, color: change.originalColor });
                newState.push({ gx, gy, gz, color: change.finalColor });
            }
            if (oldState.length > 0) {
                addCommand('batch', oldState, newState);
            }
        }
    } else { // It was a single click/tap (not a drag)
        if (initialTargetVoxelCoords) {
            const finalVoxelCoords = { ...initialTargetVoxelCoords }; // Use the initial target from pointerDown

            // If in ADD mode and we hit a face, adjust coordinates for adding
            // This adjustment is for the single click, if the initial ray hit a face
            const rawTargetAtDown = calculateRayTargetVoxelCoords(initialClickPos.x, initialClickPos.y);
            if (currentMode === Modes.ADD && rawTargetAtDown && rawTargetAtDown.faceNormal) {
                finalVoxelCoords.gx = rawTargetAtDown.gx + rawTargetAtDown.faceNormal.x;
                finalVoxelCoords.gy = rawTargetAtDown.gy + rawTargetAtDown.faceNormal.y;
                finalVoxelCoords.gz = rawTargetAtDown.gz + rawTargetAtDown.faceNormal.z;
                
                // Clamp again after adjustment
                finalVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gx));
                finalVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gy));
                finalVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, finalVoxelCoords.gz));
            }

            const gKey = key(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz);
            const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
            
            performVoxelModification(finalVoxelCoords.gx, finalVoxelCoords.gy, finalVoxelCoords.gz, currentMode, currentColor);
            
            const newColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
            if (initialColor !== newColor || (currentMode === Modes.ADD && initialColor === null && newColor !== null)) {
                addCommand('batch', [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: initialColor }], [{ gx: finalVoxelCoords.gx, gy: finalVoxelCoords.gy, gz: finalVoxelCoords.gz, color: newColor }]);
            }
        }
    }

    // Reset all states and previews after any pointer up
    pointerIsDown = false;
    isDragging = false; // Reset drag flag
    doubleTapDragActive = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    initialTargetVoxelCoords = null; // Reset initial target
    voxelsAtDragStart = null;
    currentStrokeVoxels.clear(); // Clear the stroke after it's committed
    updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel
    previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
    dragAxisLock = null; // Reset axis lock
    
    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e);
    }
}

// Event-Handler f√ºr Pointer-Down-Ereignisse
function onPointerDown(e) {
    if (e.button === 2) { // Right-click (context menu)
        e.preventDefault(); // Prevent default context menu
        rightMouseButtonDown = true;
        cvs.focus(); // Explicitly focus the canvas
        mouseMovementX = 0; // Reset mouse movement on RMB down
        mouseMovementY = 0; // Reset mouse movement on RMB down
        cvs.requestPointerLock(); // Request pointer lock for camera movement
        
        // Eyedropper logic:
        const hitResult = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
        if (hitResult && hitResult.hitExistingVoxel) {
            const gKey = key(hitResult.gx, hitResult.gy, hitResult.gz);
            if (voxels.has(gKey)) {
                const pickedColor = voxels.get(gKey).color;
                currentColor = pickedColor;
                document.getElementById('color-picker').value = pickedColor;
                const mobileColorInput = document.getElementById('mobile-color-input');
                if (mobileColorInput) mobileColorInput.value = pickedColor;
                localStorage.setItem('voxelEditorColor', pickedColor);
                presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
                showToast('Farbe aufgenommen', `Farbe: ${pickedColor}`, 'info', 2000);
            }
        }
        return; // Exit early for right-click
    }
    if (isPointerLocked) return; // If pointer is locked (e.g., from previous right-click), ignore left-click

    // Capture initial state for drag operations
    voxelsAtDragStart = new Map(voxels); // Snapshot of the entire voxel state
    currentStrokeVoxels.clear(); // Clear the stroke for a new drag
    dragAxisLock = null; // Reset axis lock at the start of the drag
    isDragging = false; // Reset drag flag at the start of a new interaction

    // Store initial position for drag detection
    initialClickPos = { x: e.clientX, y: e.clientY };
    pointerIsDown = true;

    // Get the initial target voxel coordinates
    initialTargetVoxelCoords = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    if (initialTargetVoxelCoords && (!Number.isFinite(initialTargetVoxelCoords.gx) || !Number.isFinite(initialTargetVoxelCoords.gy) || !Number.isFinite(initialTargetVoxelCoords.gz))) {
        console.warn("onPointerDown: Invalid initialTargetVoxelCoords. Action aborted.");
        pointerIsDown = false; initialClickPos = null; initialTargetVoxelCoords = null;
        return;
    }

    // Handle touch events
    if (e.pointerType === 'touch') {
        if (suppressNextTap) { suppressNextTap = false; return; }
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.display = 'block'; touchIndicator.style.left = `${e.clientX}px`; touchIndicator.style.top = `${e.clientY}px`;
        const now = performance.now();

        // If multiple pointers are active, this is a camera gesture.
        if (activePointers.size > 1) {
            // Clear any potential drawing state from previous single-finger interactions
            initialTargetVoxelCoords = null; // Clear this as it's a camera gesture
            currentStrokeVoxels.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            doubleTapDragActive = false; // Ensure double-tap drag is off for multi-touch
            isDragging = false; // Ensure drag flag is off for multi-touch
            
            // Initialize gesture state for multi-touch
            const pointersArr = [...activePointers.values()];
            const [p0, p1] = pointersArr;
            const midX = (p0.x + p1.x) * 0.5; const midY = (p0.y + p1.y) * 0.5; const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; gestureState.startMid = gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = gestureState.lastDist = dist;
            gestureState.initialPointerCount = activePointers.size;
            return; // EXIT EARLY: Multi-touch camera gesture, no voxel action
        }

        // If only one pointer is active (single touch)
        const TAP_DIST_TH = 10; // Define TAP_DIST_TH here or globally if not already defined
        const DT_MS = 250; // Define DT_MS here or globally if not already defined
        if (tapCandidate && (now - tapCandidate.time < DT_MS) && (Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH)) {
            // Double tap for continuous drag (freehand drawing)
            doubleTapDragActive = true; tapCandidate = null;
            isDragging = true; // A double-tap immediately starts a drag
            
            // If doubleTapDragActive is true, the initial voxel modification happens here.
            let initialActionVoxel = null;
            if (initialTargetVoxelCoords) {
                if (currentMode === Modes.ADD) {
                    if (initialTargetVoxelCoords.faceNormal) {
                        const proposedVoxel = { gx: initialTargetVoxelCoords.gx + initialTargetVoxelCoords.faceNormal.x, gy: initialTargetVoxelCoords.gy + initialTargetVoxelCoords.faceNormal.y, gz: initialTargetVoxelCoords.gz + initialTargetVoxelCoords.faceNormal.z };
                        proposedVoxel.gx = Math.max(0, Math.min(GRID - 1, proposedVoxel.gx)); proposedVoxel.gy = Math.max(0, Math.min(GRID - 1, proposedVoxel.gy)); proposedVoxel.gz = Math.max(0, Math.min(GRID - 1, proposedVoxel.gz));
                        if (!voxelsAtDragStart.has(key(proposedVoxel.gx, proposedVoxel.gy, proposedVoxel.gz))) { initialActionVoxel = proposedVoxel; } else { doubleTapDragActive = false; isDragging = false; return; }
                    } else {
                        initialTargetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.gx)); initialTargetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.gy)); initialTargetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, initialTargetVoxelCoords.gz));
                        if (!voxelsAtDragStart.has(key(initialTargetVoxelCoords.gx, initialTargetVoxelCoords.gy, initialTargetVoxelCoords.gz))) { initialActionVoxel = { gx: initialTargetVoxelCoords.gx, gy: initialTargetVoxelCoords.gy, gz: initialTargetVoxelCoords.gz }; } else { doubleTapDragActive = false; isDragging = false; return; }
                    }
                } else { // DELETE or DRAW mode
                    if (!initialTargetVoxelCoords.hitExistingVoxel) { // New check: only start drag if an existing voxel is hit
                        doubleTapDragActive = false; isDragging = false;
                        return;
                    }
                    initialActionVoxel = { gx: initialTargetVoxelCoords.gx, gy: initialTargetVoxelCoords.gy, gz: initialTargetVoxelCoords.gz };
                }
            } else { // No initial target voxel found for double tap
                doubleTapDragActive = false; isDragging = false;
                return;
            }

            if (initialActionVoxel) {
                lastActionVoxelCoords = { ...initialActionVoxel };
                const gKey = key(initialActionVoxel.gx, initialActionVoxel.gy, initialActionVoxel.gz);
                const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                
                performVoxelModification(initialActionVoxel.gx, initialActionVoxel.gy, initialActionVoxel.gz, currentMode, currentColor);
                const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });

                updatePreviewVoxel(0, 0, 0, false); // Hide preview voxel during drag
                previewLineInstancedMesh.count = 0;
            }
        } else {
            // Single tap or start of potential single-tap drag
            tapCandidate = { x: e.clientX, y: e.clientY, time: now };
            lastActionVoxelCoords = null; currentStrokeVoxels.clear();
            previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
            updatePreviewVoxel(0, 0, 0, false);
            gestureState.initialPointerCount = activePointers.size;
            if (activePointers.size === 1) { gestureState.type = 'rotate'; gestureState.lastMid = { x: e.clientX, y: e.clientY }; }
        }
        return; // Exit after touch handling
    }

    // Handle mouse events (left click) - only if not a touch event
    if (e.pointerType === 'mouse' && e.button === 0) {
        lastX = e.clientX; lastY = e.clientY;
        updatePreviewVoxel(0, 0, 0, false);
        previewLineInstancedMesh.count = 0; previewLineInstancedMesh.instanceMatrix.needsUpdate = true; previewLineVoxels = [];
        // No immediate voxel modification for mouse clicks, it's handled in onPointerUp or onPointerMove (if drag starts)
    }
}

// Event-Handler f√ºr Pointer-Move-Ereignisse
function onPointerMove(e) {
    e.preventDefault();
    if (isPointerLocked) return;

    // Update pointer position for multi-touch tracking
    if (e.pointerType === 'touch' && activePointers.has(e.pointerId)) {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        // If multiple pointers are active, prioritize camera gestures and skip voxel modification.
        if (activePointers.size > 1) {
            handleGesture(); // Handle camera pan/zoom
            updatePreviewVoxel(0, 0, 0, false); // Hide preview during multi-touch camera control
            previewLineInstancedMesh.count = 0; // Hide line preview during multi-touch camera control
            previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
            previewLineVoxels = [];
            return; // EXIT EARLY: No voxel modification during multi-touch camera gestures
        }
    }

    // If we reach here, it's either a single pointer (mouse or touch) or no pointers active.
    // Proceed with single-pointer logic for hover/drag-drawing.

    lastX = e.clientX;
    lastY = e.clientY;

    const currentMovedDist = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    
    // Determine if a drag operation should be active for voxel modification
    const shouldStartDrag = pointerIsDown && (currentMovedDist > MOVE_PX || doubleTapDragActive);

    let currentRayHit = calculateRayTargetVoxelCoords(e.clientX, e.clientY);
    let currentTargetVoxelCoords = null;

    if (currentRayHit) {
        let gx = currentRayHit.gx;
        let gy = currentRayHit.gy;
        let gz = currentRayHit.gz;

        // If in ADD mode and we hit a face, adjust coordinates for adding
        // Ensure currentRayHit.faceNormal is not null before accessing its properties
        if (currentMode === Modes.ADD && currentRayHit.faceNormal) {
            gx += currentRayHit.faceNormal.x;
            gy += currentRayHit.faceNormal.y;
            gz += currentRayHit.faceNormal.z;
        }

        // Clamp coordinates to grid boundaries
        gx = Math.max(0, Math.min(GRID - 1, gx));
        gy = Math.max(0, Math.min(GRID - 1, gy));
        gz = Math.max(0, Math.min(GRID - 1, gz));

        // Final check for finity after all operations
        if (Number.isFinite(gx) && Number.isFinite(gy) && Number.isFinite(gz)) {
            currentTargetVoxelCoords = { gx: gx, gy: gy, gz: gz };
        } else {
            console.error("Final currentTargetVoxelCoords has non-finite values after processing:", { gx, gy, gz });
            currentTargetVoxelCoords = null;
        }
    }

    // --- NEW LOGIC FOR PLANE LOCKING DURING DRAG CYCLE ---
    // If pointer is down and we have an initial target from pointerdown,
    // enforce the plane constraint on the current target for both drawing and preview.
    if (pointerIsDown && initialTargetVoxelCoords && currentTargetVoxelCoords) {
        // Determine dragAxisLock if not already set and threshold is crossed
        if (dragAxisLock === null && shouldStartDrag) { // Only set lock once drag starts
            const dx = Math.abs(currentTargetVoxelCoords.gx - initialTargetVoxelCoords.gx);
            const dy = Math.abs(currentTargetVoxelCoords.gy - initialTargetVoxelCoords.gy);
            const dz = Math.abs(currentTargetVoxelCoords.gz - initialTargetVoxelCoords.gz);
            const maxDelta = Math.max(dx, dy, dz);

            if (maxDelta > MOVE_PX) { // Only lock axis if a significant drag has occurred
                if (maxDelta === dx) { dragAxisLock = 'x'; }
                else if (maxDelta === dy) { dragAxisLock = 'y'; }
                else if (maxDelta === dz) { dragAxisLock = 'z'; }
            }
        }

        // If an axis is locked, force the current target to that initial plane
        if (dragAxisLock !== null) {
            currentTargetVoxelCoords[dragAxisLock] = initialTargetVoxelCoords[initialTargetVoxelCoords.hitExistingVoxel ? dragAxisLock : currentDrawingAxis];
            // If adding and not hitting an existing voxel, the plane is the current drawing plane.
            // If hitting an existing voxel, the plane is the voxel's coordinate on the locked axis.
            // This ensures the plane is consistent with the initial click's intent.
        }
    }
    // --- END NEW LOGIC ---

    // Logic for actual voxel modification during drag
    if (pointerIsDown && currentTargetVoxelCoords) {
        if (!isDragging && shouldStartDrag) {
            isDragging = true;
            // The first voxel in the drag stroke is the one initially targeted at pointerDown
            if (initialTargetVoxelCoords) { // This should always be true if pointerIsDown and currentTargetVoxelCoords are true here
                lastActionVoxelCoords = { ...initialTargetVoxelCoords }; // Start the line from the initial click point
                
                // Perform the modification for the very first voxel of the drag
                const gKey = key(initialTargetVoxelCoords.gx, initialTargetVoxelCoords.gy, initialTargetVoxelCoords.gz);
                const initialColor = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                performVoxelModification(initialTargetVoxelCoords.gx, initialTargetVoxelCoords.gy, initialTargetVoxelCoords.gz, currentMode, currentColor);
                const finalColor = voxels.has(gKey) ? voxels.get(gKey).color : null;
                currentStrokeVoxels.set(gKey, { originalColor: initialColor, finalColor: finalColor });
            }
        }

        if (isDragging) { // Continue the drag operation
            const startPointForLine = lastActionVoxelCoords;
            const endPointForLine = { ...currentTargetVoxelCoords }; // Use the already constrained currentTargetVoxelCoords

            // ... (pathVoxels calculation and modification remains the same) ...

            let pathVoxels = getVoxelsOnLine(startPointForLine, endPointForLine);

            // Filter pathVoxels based on mode for DELETE/DRAW
            if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                pathVoxels = pathVoxels.filter(voxel => voxelsAtDragStart.has(key(voxel.gx, voxel.gy, voxel.gz)));
            }

            for (let i = 0; i < pathVoxels.length; i++) {
                const voxel = pathVoxels[i];
                const gKey = key(voxel.gx, voxel.gy, voxel.gz);
                const initialColorOfStroke = voxelsAtDragStart.has(gKey) ? voxelsAtDragStart.get(gKey).color : null;
                
                // Perform the modification immediately
                performVoxelModification(voxel.gx, voxel.gy, voxel.gz, currentMode, currentColor);
                
                const finalColorAfterModification = voxels.has(gKey) ? voxels.get(gKey).color : null;

                // Record the change for the stroke history
                if (!currentStrokeVoxels.has(gKey)) { // Only record initial state once for this stroke
                     currentStrokeVoxels.set(gKey, { originalColor: initialColorOfStroke, finalColor: finalColorAfterModification });
                } else { // Update finalColor if already part of stroke
                    currentStrokeVoxels.get(gKey).finalColor = finalColorAfterModification;
                }
            }
            lastActionVoxelCoords = { ...endPointForLine }; // Update lastActionVoxelCoords only if drawing occurred
            updatePreviewVoxel(0, 0, 0, false); // Hide single preview voxel during drag
            previewLineInstancedMesh.count = 0; // Line preview not needed for instant drawing

        } else { // Pointer is down, but not yet dragging (within MOVE_PX threshold)
            // Only show single voxel preview, constrained by the initial plane if a lock is determined
            if (currentTargetVoxelCoords) {
                let showPreview = false;
                const gKeyAtPreview = key(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz);
                const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

                if (currentMode === Modes.ADD) {
                    if (!hasVoxelAtPreview) { showPreview = true; }
                } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                    if (hasVoxelAtPreview) { showPreview = true; }
                }
                updatePreviewVoxel(currentTargetVoxelCoords.gx, currentTargetVoxelCoords.gy, currentTargetVoxelCoords.gz, showPreview);
            } else {
                updatePreviewVoxel(0, 0, 0, false); // Hide preview if no target
            }
            previewLineInstancedMesh.count = 0; // No line preview
        }
    } else { // Not pointer down (just hovering)
        // Clear any existing line preview
        previewLineInstancedMesh.count = 0;
        previewLineInstancedMesh.instanceMatrix.needsUpdate = true;
        previewLineVoxels = [];

        // Show single voxel preview for hovering, without plane constraint
        if (currentRayHit) { // Use raw currentRayHit for hover preview
            let hoverPreviewCoords = { gx: currentRayHit.gx, gy: currentRayHit.gy, gz: currentRayHit.gz };
            if (currentMode === Modes.ADD && currentRayHit.faceNormal) {
                hoverPreviewCoords.gx += currentRayHit.faceNormal.x;
                hoverPreviewCoords.gy += currentRayHit.faceNormal.y;
                hoverPreviewCoords.gz += currentRayHit.faceNormal.z;
            }
            // Clamp hover preview coords
            hoverPreviewCoords.gx = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gx));
            hoverPreviewCoords.gy = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gy));
            hoverPreviewCoords.gz = Math.max(0, Math.min(GRID - 1, hoverPreviewCoords.gz));

            let showPreview = false;
            const gKeyAtPreview = key(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz);
            const hasVoxelAtPreview = voxels.has(gKeyAtPreview);

            if (currentMode === Modes.ADD) {
                if (!hasVoxelAtPreview) { showPreview = true; }
            } else if (currentMode === Modes.DELETE || currentMode === Modes.DRAW) {
                if (hasVoxelAtPreview) { showPreview = true; }
            }
            updatePreviewVoxel(hoverPreviewCoords.gx, hoverPreviewCoords.gy, hoverPreviewCoords.gz, showPreview);
        } else {
            updatePreviewVoxel(0, 0, 0, false); // Hide preview if no target
        }
    }
    
    // Handle camera rotation/pan for touch events (only if it's a single touch and not a drag-drawing action)
    if (e.pointerType === 'touch' && activePointers.size === 1 && !isDragging) {
        handleGesture(); // Handle camera pan/zoom
    }
}

// Funktion zum √ñffnen des LLM-Ideengenerator-Modals
function openIdeaGeneratorModal() {
    document.getElementById('ideaPromptInput').value = ''; // Vorherige Eingabe l√∂schen
    document.getElementById('ideaResultDisplay').innerHTML = ''; // Vorheriges Ergebnis l√∂schen
    document.getElementById('ideaResultDisplay').classList.add('hidden'); // Ergebnisbereich ausblenden
    document.getElementById('ideaLoadingIndicator').classList.add('hidden'); // Ladeanzeige ausblenden
    document.getElementById('ideaGeneratorModal').showModal();
}

// Funktion zum Generieren einer Voxel-Idee mit der Gemini API
async function generateVoxelIdea() {
    const promptText = document.getElementById('ideaPromptInput').value.trim();
    const ideaResultDisplay = document.getElementById('ideaResultDisplay');
    const ideaLoadingIndicator = document.getElementById('ideaLoadingIndicator');

    if (!promptText) {
        showToast('Eingabe erforderlich', 'Bitte geben Sie ein Thema oder Konzept ein.', 'warning');
        return;
    }

    ideaResultDisplay.classList.add('hidden'); // Vorheriges Ergebnis ausblenden
    ideaLoadingIndicator.classList.remove('hidden'); // Ladeanzeige anzeigen
    ideaResultDisplay.innerHTML = ''; // Vorherigen Inhalt l√∂schen

    try {
        // Prompt, um die KI zur Generierung von JSON f√ºr Voxel zu bewegen
        // Der Prompt wurde angepasst, um die Gittergr√∂√üe und die Komplexit√§t besser zu ber√ºcksichtigen.
        const prompt = `Generate a detailed and recognizable voxel model as a JSON object based on the following theme.
        The model should effectively utilize the available 3D grid space, which ranges from (0,0,0) to (${GRID-1},${GRID-1},${GRID-1}).
        The model *must* form a **single, unified, and fully connected object**. It should be **solid, contiguous, and watertight**, without any internal gaps, disconnected parts, or floating voxels. Every voxel should be directly adjacent (face-to-face) to at least one other voxel within the generated set, forming a continuous, cohesive mass. No individual voxels or groups of voxels should be isolated or floating in space. Prioritize filling internal spaces to ensure no gaps within the overall form. When forming lines, surfaces, or volumes, ensure all intermediate voxels are included to prevent holes. Avoid generating sparse or hollow structures unless explicitly requested by the theme.
        Aim for a reasonable number of voxels, typically between 50 and 700, to create a well-defined, robust structure.
        All x, y, z coordinates must be integers within the grid boundaries (0 to ${GRID-1}).
        Colors should be valid hex color codes (e.g., "#FF0000").
        
        Theme: "${promptText}"
        
        The JSON should have the following structure:
        {
          "model_name": "A concise name for the model",
          "description": "A brief description of the model.",
          "voxels": [
            { "x": integer, "y": integer, "z": integer, "color": "hex_color_string" },
            // ... up to 700 voxel objects, utilizing the grid space
          ]
        }
        `;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });

        const payload = {
            contents: chatHistory,
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "model_name": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "voxels": {
                            "type": "ARRAY",
                            "items": {
                                type: "OBJECT",
                                properties: {
                                    "x": { "type": "INTEGER" },
                                    "y": { "type": "INTEGER" },
                                    "z": { "type": "INTEGER" },
                                    "color": { "type": "STRING" }
                                },
                                required: ["x", "y", "z", "color"]
                            }
                        }
                    },
                    required: ["model_name", "description", "voxels"]
                }
            }
        };

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${AI_API_KEY}`; // Using hardcoded AI API Key

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            const jsonResponseText = result.candidates[0].content.parts[0].text;
            try {
                const parsedJson = JSON.parse(jsonResponseText);
                applyAIGeneratedVoxels(parsedJson); // Neue Funktion zum Anwenden der Voxel
            } catch (parseError) {
                console.error("Fehler beim Parsen der AI-Antwort als JSON:", parseError);
                ideaResultDisplay.innerHTML = '<p class="text-error">Fehler: KI-Antwort konnte nicht als Voxel-Modell interpretiert werden. (Ung√ºltiges JSON)</p>';
                ideaResultDisplay.classList.remove('hidden');
            }
        } else {
            ideaResultDisplay.innerHTML = '<p class="text-error">Konnte keine Idee generieren. Bitte versuchen Sie es erneut.</p>';
            ideaResultDisplay.classList.remove('hidden');
            console.error("Gemini API hat eine unerwartete Struktur oder keinen Inhalt zur√ºckgegeben:", result);
        }
    } catch (error) {
        ideaResultDisplay.innerHTML = `<p class="text-error">Fehler beim Generieren der Idee: ${error.message}</p>`;
        ideaResultDisplay.classList.remove('hidden');
        console.error("Fehler beim Aufruf der Gemini API:", error);
    } finally {
        ideaLoadingIndicator.classList.add('hidden'); // Ladeanzeige ausblenden
    }
}

// Neue Funktion: Wendet die von der KI generierten Voxel auf die Szene an
function applyAIGeneratedVoxels(aiData) {
    if (!aiData || !Array.isArray(aiData.voxels)) {
        console.error("Ung√ºltige AI generierte Voxeldaten:", aiData);
        showToast('Fehler', 'Ung√ºltige AI-Voxeldaten erhalten.', 'error');
        return;
    }

    const oldState = [...voxels.entries()].map(([id, data]) => {
        const p = parseKey(id);
        return { gx: p[0], gy: p[1], gz: p[2], color: data.color };
    });

    clearAllInternal(true); // Aktuelle Szene leeren (Teil dieses Batches)

    const newVoxels = [];
    aiData.voxels.forEach(v => {
        // Check for potential out-of-bounds before clamping
        if (v.x < 0 || v.x >= GRID || v.y < 0 || v.y >= GRID || v.z < 0 || v.z >= GRID) {
            console.warn(`AI generated voxel out of bounds (before clamping): x=${v.x}, y=${v.y}, z=${v.z}. Clamping to grid.`);
        }

        // Koordinaten auf Gittergrenzen klemmen und runden
        const gx = Math.max(0, Math.min(GRID - 1, Math.round(v.x)));
        const gy = Math.max(0, Math.min(GRID - 1, Math.round(v.y)));
        const gz = Math.max(0, Math.min(GRID - 1, Math.round(v.z)));
        const color = v.color || currentColor; // Fallback auf aktuelle Farbe, wenn KI keine angibt

        _addSingleVoxel(gx, gy, gz, color);
        newVoxels.push({ gx, gy, gz, color });
    });

    addCommand('batch', oldState, newVoxels); // Als Batch-Befehl zur Historie hinzuf√ºgen

    // Projektmetadaten aus der KI-Ausgabe aktualisieren
    projectTitle = aiData.model_name || 'KI Generiertes Modell';
    projectDescription = aiData.description || 'Ein von der KI generiertes Modell.';

    showToast('AI-Modell erstellt', `"${aiData.model_name || 'Unbenannt'}" wurde generiert.`, 'success', 4000);
    document.getElementById('ideaGeneratorModal').close(); // Modal schlie√üen
}


// Funktion zum Wechseln der Zeichenachse (Nur f√ºr Desktop-UI)
function cycleDrawingAxis() {
    if (isMobile) return; // Disabled for mobile
    const axes = ['x', 'y', 'z'];
    const currentIndex = axes.indexOf(currentDrawingAxis);
    currentDrawingAxis = axes[(currentIndex + 1) % axes.length];
    // document.getElementById('mobile-axis-icon').className = AxisIcons[currentDrawingAxis]; // No mobile axis icon
    updateGridHelperPosition();
    showToast('Zeichenachse', `Achse: ${currentDrawingAxis.toUpperCase()}`, 'info', 1500);
}

// Funktion zum Bewegen der Zeichenebene (Nur f√ºr Desktop-UI)
function moveDrawingLevel(direction) {
    if (isMobile) return; // Disabled for mobile
    if (currentMode !== Modes.ADD && currentMode !== Modes.DRAW) {
        showToast('Hinweis', 'Ebenensteuerung nur im Hinzuf√ºgen- oder Zeichenmodus verf√ºgbar.', 'warning', 2000);
        return;
    }
    let level = activeDrawingLevel[currentDrawingAxis];
    console.log("moveDrawingLevel: current axis", currentDrawingAxis, "old level", level);

    // Ensure 'level' is a finite number before performing arithmetic and clamping
    if (!Number.isFinite(level)) {
        console.warn(`moveDrawingLevel: activeDrawingLevel[${currentDrawingAxis}] is non-finite (${level}). Resetting to 0.`);
        level = 0; // Reset to a safe default
        activeDrawingLevel[currentDrawingAxis] = level; // Update the actual stored value
    }

    level += direction;
    level = Math.max(0, Math.min(GRID - 1, level)); // Clamp to grid boundaries
    activeDrawingLevel[currentDrawingAxis] = level;
    console.log("moveDrawingLevel: new activeDrawingLevel", activeDrawingLevel.x, activeDrawingLevel.y, activeDrawingLevel.z);
    updateGridHelperPosition();
    showToast('Zeichenebene', `Ebene ${currentDrawingAxis.toUpperCase()}: ${level}`, 'info', 1500);
}


// Initialisierungsfunktion, die beim Laden des Fensters ausgef√ºhrt wird
window.onload = async function() {
    closeAllModals();
    try {
        cvs = document.getElementById('voxelCanvas'); containerDiv = document.getElementById('container');
        touchIndicator = document.getElementById('touch-indicator');
        toastContainer = document.getElementById('toast-container'); // Initialisiere toastContainer hier
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34);
        cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
        resetCameraPosition(); euler = new THREE.Euler(0, 0, 0, 'YXZ');
        ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
        ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
        isMobile = window.matchMedia('(max-width: 768px)').matches;
        ren.setPixelRatio(isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio);
        ren.shadowMap.enabled = true; ren.shadowMap.type = THREE.PCFSoftShadowMap;
      
        scene.add(new THREE.AmbientLight(0x606060));
        mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainDirectionalLight.position.set(10, 20, 15); mainDirectionalLight.castShadow = true;
        mainDirectionalLight.shadow.mapSize.width = mainDirectionalLight.shadow.mapSize.height = 2048;
        mainDirectionalLight.shadow.camera.near = 0.5; mainDirectionalLight.shadow.camera.far = 50;
        mainDirectionalLight.shadow.camera.left = -30; mainDirectionalLight.shadow.camera.right = 30;
        mainDirectionalLight.shadow.camera.top = 30; mainDirectionalLight.shadow.camera.bottom = -30;
        mainDirectionalLight.shadow.bias = -0.0005; mainDirectionalLight.shadow.normalBias = 0.02;
        scene.add(mainDirectionalLight);
        const secondDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
        secondDirectionalLight.position.set(-10, 10, -15);
        scene.add(secondDirectionalLight);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
        
        scene.add(previewVoxelMesh); updatePreviewVoxel(0,0,0,false);
        previewLineInstancedMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(VS, VS, VS), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false }));
        previewLineInstancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        previewLineInstancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxPreviewInstances * 3), 3);
        previewLineInstancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage); scene.add(previewLineInstancedMesh);
        rebuildHelpers();

        window.addEventListener('resize', onResize);
        containerDiv.addEventListener('pointerdown', onPointerDown);
        containerDiv.addEventListener('pointermove', onPointerMove);
        containerDiv.addEventListener('pointerup', onPointerUp);
        containerDiv.addEventListener('pointercancel', onPointerUp);
        containerDiv.addEventListener('pointerleave', onPointerLeave);
        containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
        // Removed the touchmove preventDefault on containerDiv, as it's now handled specifically within onPointerMove for multi-touch.
        // It's crucial to still have touch-action: none on the canvas itself.
        document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
        document.addEventListener('pointerlockchange', onPointerLockChange, false);
        // Changed mousemove listener from document to containerDiv
        containerDiv.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                mouseMovementX = e.movementX;
                mouseMovementY = e.movementY;
                e.preventDefault(); // Prevent default browser actions for mousemove when locked
            }
        });
        containerDiv.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent default right-click menu

        document.getElementById('grid-size-slider').addEventListener('input', (e) => {
            const oldGrid = GRID;
            const newGrid = parseInt(e.target.value);

            // Nur pr√ºfen, wenn herunterskaliert wird
            if (newGrid < oldGrid) {
                let voxelsWouldBeLost = false;
                for (const [id, data] of voxels.entries()) {
                    const p = parseKey(id);
                    if (p[0] >= newGrid || p[1] >= newGrid || p[2] >= newGrid) {
                        voxelsWouldBeLost = true;
                        break;
                    }
                }

                if (voxelsWouldBeLost) {
                    showToast('Warnung', 'Gittergr√∂√üe kann nicht reduziert werden, da sonst vorhandene Voxel au√üerhalb des Rasters verloren gehen w√ºrden.', 'warning', 5000);
                    // Slider-Wert zur√ºcksetzen
                    e.target.value = oldGrid;
                    document.getElementById('grid-size-display').textContent = `${oldGrid}√ó${oldGrid}√ó${oldGrid}`;
                    return; // Weitere Ausf√ºhrung der Skalierung verhindern
                }
            }
            
            const oldVoxelState = [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; });
            for (const chunk of chunks.values()) chunk.dispose(); chunks.clear(); voxels.clear();
            oldVoxelState.filter(v => v.gx < newGrid && v.gy < newGrid && v.gz < newGrid).forEach(v => _addSingleVoxel(v.gx, v.gy, v.gz, v.color));
            GRID = newGrid; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`; localStorage.setItem('voxelEditorGridSize', GRID);
            addCommand('resizeGrid', oldVoxelState, [...voxels.entries()].map(([id, data]) => { const p = parseKey(id); return { gx: p[0], gy: p[1], gz: p[2], color: data.color }; }), { oldGrid: oldGrid, newGrid: GRID });
            rebuildHelpers(); resetCameraPosition();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            currentColor = e.target.value; localStorage.setItem('voxelEditorColor', currentColor);
            // Sync mobile color input if it exists
            const mobileColorInput = document.getElementById('mobile-color-input');
            if (mobileColorInput) mobileColorInput.value = currentColor;
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50')); activePresetIndex = -1;
            // Vorschau-Voxel sofort aktualisieren, wenn sichtbar
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });
        // Removed the 'blur' listener for color-picker as 'input' is sufficient and more immediate.

        presetBoxes = [document.getElementById('color-preset-1'), document.getElementById('color-preset-2'), document.getElementById('color-preset-3')];
        presetColors.forEach((color, i) => {
            const box = presetBoxes[i]; box.value = color;
            box.addEventListener('click', (e) => setActivePreset(i));
            box.addEventListener('input', (e) => savePresetColor(i, e.target.value));
        });
        if (activePresetIndex !== -1) setActivePreset(activePresetIndex); else document.getElementById('color-picker').value = currentColor;

        document.getElementById('modeToggle').addEventListener('click', cycleMode);
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

        document.getElementById('clearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').showModal());
        document.getElementById('saveAndClearBtn').addEventListener('click', () => { saveJSON(); clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => { clearAll(); document.getElementById('clearConfirmationModal').close(); });
        document.getElementById('cancelClearBtn').addEventListener('click', () => document.getElementById('clearConfirmationModal').close());
        document.getElementById('clearConfirmationModal').addEventListener('cancel', () => document.getElementById('clearConfirmationModal').close());

        document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
        document.getElementById('saveBtn').addEventListener('click', saveJSON);
        document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
        document.getElementById('fileInput').addEventListener('change', loadJSON);
        document.getElementById('exportStlBtn').addEventListener('click', exportSTL);
        document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);
        document.getElementById('exportGlbBtn').addEventListener('click', exportGLB); // Event listener for GLB export

        document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value); document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2); localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
        });

        document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);
        document.getElementById('generateVoxelIdeaBtn').addEventListener('click', openIdeaGeneratorModal); // Neuer Button-Event-Listener
        document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
        document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
        document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);

        document.getElementById('menuToggle').addEventListener('click', () => {
            const controlsPanel = document.getElementById('controls');
            controlsPanel.classList.toggle('hidden');
            if (!controlsPanel.classList.contains('hidden')) controlsPanel.classList.add('flex');
            else controlsPanel.classList.remove('flex');
        });

        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleMediaQueryChange(e) {
            isMobile = e.matches;
            const controlsPanel = document.getElementById('controls');
            const mobileControls = document.getElementById('mobile-controls');
            if (e.matches) { // Dies bedeutet, es ist ein mobiler Bildschirm (max-width: 768px)
                controlsPanel.classList.add('hidden'); // Desktop-Steuerelemente ausblenden
                mobileControls.classList.remove('hidden'); // Mobile Steuerelemente anzeigen
                mobileControls.classList.add('flex'); // Flex-Anzeige sicherstellen
                toastContainer.classList.remove('toast-end');
                toastContainer.classList.add('toast-top-center'); // Apply new mobile toast position
                currentDrawingAxis = 'y'; // Force Y-axis for mobile
                // Hide axis-specific controls on mobile
                document.getElementById('mobile-axis-toggle')?.classList.add('hidden');
                document.getElementById('mobile-level-up')?.classList.add('hidden');
                document.getElementById('mobile-level-down')?.classList.add('hidden');
            }
            else { // Desktop-Bildschirm
                controlsPanel.classList.remove('hidden'); // Desktop-Steuerelemente anzeigen
                controlsPanel.classList.add('flex'); // Flex-Anzeige sicherstellen
                mobileControls.classList.add('hidden'); // Mobile Steuerelemente ausblenden
                mobileControls.classList.remove('flex'); // Flex-Anzeige entfernen
                toastContainer.classList.remove('toast-top-center');
                toastContainer.classList.add('toast-end'); // Apply desktop toast position
                // Show axis-specific controls on desktop
                document.getElementById('mobile-axis-toggle')?.classList.remove('hidden');
                document.getElementById('mobile-level-up')?.classList.remove('hidden');
                document.getElementById('mobile-level-down')?.classList.remove('hidden');
            }
            onResize();
            rebuildHelpers(); // Rebuild helpers to reflect potential axis change for mobile
            // Ensure mobile mode icon is set correctly on media query change
            const mobileModeIcon = document.getElementById('mobile-mode-icon');
            if (mobileModeIcon) {
                mobileModeIcon.className = ModeIcons[currentMode];
                console.log(`Setting mobile mode icon on media query change: ${ModeIcons[currentMode]}`); // Debugging
            }
        }
        mediaQuery.addListener(handleMediaQueryChange); handleMediaQueryChange(mediaQuery);

        // Event-Handler f√ºr mobile Schaltfl√§chen (e.stopPropagation() hinzugef√ºgt)
        document.getElementById('mobile-undo').addEventListener('click', (e) => { e.stopPropagation(); undo(); });
        document.getElementById('mobile-redo').addEventListener('click', (e) => { e.stopPropagation(); redo(); });
        document.getElementById('mobile-save').addEventListener('click', (e) => { e.stopPropagation(); saveJSON(); });
        document.getElementById('mobile-camera').addEventListener('click', (e) => { e.stopPropagation(); resetCameraPosition(); });
        document.getElementById('mobile-mode-toggle').addEventListener('click', (e) => { e.stopPropagation(); cycleMode(); });
        
        // Mobile Color Picker Fix: Create and wire up a hidden input for mobile
        const mobileColorPickerBtn = document.getElementById('mobile-color-picker-btn');
        const mobileColorInput = document.getElementById('mobile-color-input'); // Get the hidden input from HTML
        
        mobileColorPickerBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log("Mobile color picker button clicked."); // Debugging
            mobileColorInput.click(); // Trigger the native color picker
        });

        mobileColorInput.addEventListener('input', (e) => {
            console.log("Mobile color input 'input' event fired. New color:", e.target.value); // Debugging
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor; // Sync with desktop picker
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });
        // Also listen to 'change' event for broader compatibility, especially on mobile
        mobileColorInput.addEventListener('change', (e) => {
            console.log("Mobile color input 'change' event fired. New color:", e.target.value); // Debugging
            currentColor = e.target.value;
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor; // Sync with desktop picker
            presetBoxes.forEach(box => box.classList.remove('active', 'border-primary', 'shadow-lg', 'shadow-primary/50'));
            activePresetIndex = -1;
            if (previewVoxelMesh.visible) {
                previewVoxelMaterial.color.set(currentColor);
            }
        });

        // Sync initial color for the mobile color input
        mobileColorInput.value = currentColor;

        document.getElementById('mobile-generate-idea').addEventListener('click', (e) => { e.stopPropagation(); openIdeaGeneratorModal(); }); // Neuer mobiler Button-Event-Listener
        document.getElementById('mobile-login-logout').addEventListener('click', (e) => { e.stopPropagation(); loginLogout(); });

        document.getElementById('grid-size-slider').value = GRID; document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        document.getElementById('color-picker').value = currentColor;
        document.getElementById('fly-speed-slider').value = moveSpeed; document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        
        // Initialize mobile mode icon
        document.getElementById('mobile-mode-icon').className = ModeIcons[currentMode];

        const app = window.firebase.initializeApp(window.firebaseConfig);
        auth = window.firebase.getAuth(app); db = window.firebase.getFirestore(app);
        const loginLogoutBtn = document.getElementById('loginLogoutBtn');
        const uploadToHubBtn = document.getElementById('uploadToHubBtn');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const goToHubBtn = document.getElementById('goToHubBtn');
        let projectLoadedFromUrl = false;

        predefinedCategories.forEach(cat => { const opt = document.createElement('option'); opt.value = cat; opt.textContent = cat; document.getElementById('uploadCategory').appendChild(opt); });

        window.firebase.setPersistence(auth, window.firebase.browserLocalPersistence)
            .then(async () => {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await window.firebase.signInWithCustomToken(auth, __initial_auth_token); }
                    catch (e) { console.error("Firebase Auth Token Error:", e); showToast('Anmeldefehler', `Fehler beim Anmelden mit Token: ${e.message}. Bitte versuchen Sie es erneut.`, 'error', 5000); }
                } else {
                    // Benutzer ist nicht automatisch angemeldet. Er muss sich explizit anmelden.
                    console.log("Kein initialer Auth-Token. Benutzer wird nicht automatisch angemeldet.");
                }

                window.firebase.onAuthStateChanged(auth, async (user) => {
                    currentUserId = user ? user.uid : null; currentUser = user;
                    loginLogoutBtn.textContent = user ? 'Abmelden' : 'Anmelden';
                    // userIdDisplay aktualisiert, um nur das Foto anzuzeigen, nicht die UID
                    userIdDisplay.innerHTML = user ? `<img src="${user.photoURL || 'https://placehold.co/24x24/cccccc/000000?text=U'}" alt="User Avatar" class="w-6 h-6 rounded-full align-middle">` : '';
                    uploadToHubBtn.classList.toggle('hidden', !user);
                    document.getElementById('mobile-login-logout').textContent = user ? 'üö™' : 'üîë';
                    if (user) document.getElementById('authModal').close();

                    if (!projectLoadedFromUrl) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const modelId = urlParams.get('modelId'); const encodedJson = urlParams.get('projectJson');
                        if (modelId) { await loadProjectFromModelId(modelId); projectLoadedFromUrl = true; }
                        else if (encodedJson) {
                            try {
                                const decodedJson = decodeURIComponent(encodedJson);
                                loadProjectData(JSON.parse(decodedJson));
                                showToast('Projekt geladen', 'Projekt erfolgreich aus URL-Parameter geladen.', 'success');
                                projectLoadedFromUrl = true;
                            } catch (e) { console.error("Error loading project from URL param:", e); showToast('Fehler', 'Fehler beim Laden des Projekts aus der URL. Ung√ºltige oder besch√§digte Projektdaten. Fehler: ' + e.message, 'error'); resetToDefaultProject(); }
                        } else { projectRemixOf = ''; projectSourceJsonUrl = ''; }
                    }
                });
                animate();
            })
            .catch((e) => { console.error("Firebase setPersistence Error:", e); showToast('Anmeldefehler', `Fehler bei der Anmeldungspersistenz: ${e.message}.`, 'error', 10000); animate(); });

        document.getElementById('goToHubBtn').addEventListener('click', () => window.open('https://hub.voxelshaper.com', '_blank'));
        loginLogoutBtn.addEventListener('click', loginLogout);
        document.getElementById('authModal').addEventListener('click', (e) => { if (e.target === document.getElementById('authModal')) closeAuthModal(); });
        document.getElementById('authModalCloseBtn').addEventListener('click', closeAuthModal);
        document.getElementById('signInGoogleBtn').addEventListener('click', window.signInWithGoogle);
        document.getElementById('signInGithubBtn').addEventListener('click', window.signInGithub);
        document.getElementById('emailSignInBtn').addEventListener('click', window.signInEmailPassword);
        document.getElementById('emailSignUpBtn').addEventListener('click', window.signUpEmailPassword);
        document.getElementById('showEmailLoginFormBtn').addEventListener('click', () => document.getElementById('emailLoginForm').classList.remove('hidden'));
        document.getElementById('uploadToHubBtn').addEventListener('click', openUploadModal);
        document.getElementById('uploadProjectModal').addEventListener('click', (e) => { if (e.target === document.getElementById('uploadProjectModal')) { document.getElementById('uploadProjectModal').close(); cvs.focus(); } });
        document.getElementById('uploadConfirmBtn').addEventListener('click', uploadProjectToHub);
        document.getElementById('uploadCancelBtn').addEventListener('click', () => { document.getElementById('uploadProjectModal').close(); cvs.focus(); });

        // Neue LLM-Ideengenerator-Event-Listener
        document.getElementById('generateIdeaConfirmBtn').addEventListener('click', generateVoxelIdea);
        document.getElementById('ideaGeneratorCloseBtn').addEventListener('click', () => { document.getElementById('ideaGeneratorModal').close(); cvs.focus(); });
        document.getElementById('ideaGeneratorModal').addEventListener('click', (e) => { if (e.target === document.getElementById('ideaGeneratorModal')) { document.getElementById('ideaGeneratorModal').close(); cvs.focus(); } });

    } catch (e) { console.error("VoxelShaper Initialisierungsfehler:", e); showToast('Schwerer Fehler', `Ein unerwarteter Fehler ist aufgetreten: ${e.message}.`, 'error', 10000); }
};

const frustum = new THREE.Frustum(); const tempCameraMatrix = new THREE.Matrix4();
function animate() {
    requestAnimationFrame(animate);
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            mouseMovementX = mouseMovementY = 0;
            return;
        }
        euler.y -= (mouseMovementX || 0) * rotSpeed;
        euler.x -= (mouseMovementY || 0) * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        mouseMovementX = mouseMovementY = 0; // Reset after use
        const camDir = new THREE.Vector3(); cam.getWorldDirection(camDir);
        const rightDir = new THREE.Vector3().crossVectors(camDir, cam.up).normalize();
        const upVec = new THREE.Vector3(0, 1, 0); const currMoveSpeed = moveSpeed * 0.5;
        if (keyboard['w']) cam.position.addScaledVector(camDir, currMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(camDir, -currMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(rightDir, -currMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(rightDir, currMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(upVec, currMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(upVec, -currMoveSpeed);
    }
    cam.updateMatrixWorld(); tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);
    for (const chunk of chunks.values()) chunk.instancedMesh.visible = frustum.intersectsBox(chunk.boundingBox);
    ren.render(scene, cam);
}

</script>
</body>
</html>
