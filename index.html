<!DOCTYPE html>
<html lang="de" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelShaper - Community 3D Modelle</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    </head>
<body class="bg-base-100 min-h-screen text-base-content">
    <div class="navbar bg-base-200 border-b border-base-content/20 px-4 py-3 flex-wrap">
        <div class="flex-1">
            <a href="#" class="text-2xl font-black text-blue-400 tracking-tight">
                <i class="fas fa-cube mr-2"></i>VoxelShaper
            </a>
            <div class="hidden md:flex ml-10">
                <a href="#" id="nav-discover" class="btn btn-ghost btn-sm">Entdecken</a>
                <a href="#" id="nav-popular" class="btn btn-ghost btn-sm">Beliebt</a>
                <a href="#" id="nav-new" class="btn btn-ghost btn-sm">Neu</a>
                <a href="#" id="nav-categories" class="btn btn-ghost btn-sm">Kategorien</a>
            </div>
        </div>
        <div class="flex-none gap-4 mt-2 md:mt-0 w-full md:w-auto justify-end">
            <!-- Search Input in Navbar -->
            <div class="form-control flex-grow md:flex-grow-0 max-w-xs">
                <input type="text" id="search-input" placeholder="Modelle suchen..." class="input input-bordered w-full bg-base-300 border-base-content/20" aria-label="Modelle suchen" />
            </div>

            <label class="swap swap-rotate btn btn-ghost btn-circle" aria-label="Theme wechseln">
                <input type="checkbox" id="theme-toggle" />

                <svg
                    class="swap-on h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z" />
                </svg>

                <svg
                    class="swap-off h-6 w-6 fill-current"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24">
                    <path
                        d="M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z" />
                </svg>
            </label>
            
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" class="btn btn-ghost btn-circle" aria-label="Benachrichtigungen">
                    <i class="fas fa-bell text-xl"></i>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-64 mt-4">
                    <li class="text-center py-4 text-base-content/60">Keine Benachrichtigungen</li>
                </ul>
            </div>
            <div class="dropdown dropdown-end">
                <div tabindex="0" role="button" id="user-menu-button" class="btn btn-ghost btn-circle avatar placeholder" aria-label="Benutzermenü">
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <span><i class="fas fa-user text-lg"></i></span>
                    </div>
                </div>
                <ul tabindex="0" class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-52 mt-4">
                    <li id="login-button"><a><i class="fas fa-sign-in-alt mr-2"></i>Anmelden</a></li>
                    <li id="profile-button" class="hidden"><a><i class="fas fa-user mr-2"></i>Profil</a></li>
                    <li id="logout-button" class="hidden"><a><i class="fas fa-sign-out-alt mr-2"></i>Abmelden</a></li>
                </ul>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold">Community-Modelle</h1>
            <button id="upload-model-button" class="btn btn-primary">
                <i class="fas fa-upload mr-2"></i>Modell hochladen
            </button>
        </div>

        <div class="bg-base-200 rounded-lg p-4 mb-6">
            <div class="flex flex-col md:flex-row md:flex-wrap items-start md:items-center gap-4">
                <!-- Category Filter Buttons -->
                <div class="form-control w-full md:w-auto">
                    <label class="label">
                        <span class="label-text text-base-content/60">Kategorie</span>
                    </label>
                    <div id="category-filter-buttons" class="flex flex-wrap gap-2">
                        <!-- Category buttons dynamically loaded via JS -->
                    </div>
                </div>

                <!-- Sort By -->
                <div class="form-control w-full max-w-xs">
                    <label class="label">
                        <span class="label-text text-base-content/60">Sortieren nach</span>
                    </label>
                    <select id="sort-by" class="select select-bordered w-full bg-base-300 border-base-content/20">
                        <option value="newest-desc">Neueste (absteigend)</option>
                        <option value="newest-asc">Neueste (aufsteigend)</option>
                        <option value="popular-desc">Beliebteste (absteigend)</option>
                        <option value="popular-asc">Beliebteste (aufsteigend)</option>
                        <option value="top-rated-desc">Am besten bewertet (absteigend)</option>
                        <option value="top-rated-asc">Am besten bewertet (aufsteigend)</option>
                    </select>
                </div>

                <!-- Status Filter (Always shown, options vary) -->
                <div class="form-control w-full max-w-xs" id="status-filter-container">
                    <label class="label">
                        <span class="label-text text-base-content/60">Status</span>
                    </label>
                    <select id="status-filter-select" class="select select-bordered w-full bg-base-300 border-base-content/20">
                        <option value="verified">Verifiziert</option>
                        <option value="all">Alle</option>
                        <!-- Unverified option added via JS for admins -->
                    </select>
                </div>

                <!-- Filter Reset Button -->
                <div class="form-control w-full max-w-xs mt-auto">
                    <button id="reset-filters-button" class="btn btn-outline">
                        <i class="fas fa-undo mr-2"></i>Filter zurücksetzen
                    </button>
                </div>

                <!-- License Filter - Keep as is for now -->
                <div class="flex items-center">
                    <span class="text-base-content/60 mr-2">Lizenz:</span>
                    <div class="flex flex-wrap gap-2">
                        <button class="btn btn-xs">Alle</button>
                        <button class="btn btn-xs">CC BY</button>
                        <button class="btn btn-xs">CC BY-SA</button>
                        <button class="btn btn-xs">CC0</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="models-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            </div>

        <div id="loading-sentinel" class="flex flex-col items-center justify-center mt-10">
            <span id="loading-spinner" class="loading loading-spinner loading-lg text-primary hidden"></span>
            <p id="no-more-models" class="text-base-content/60 mt-4 hidden">Keine weiteren Modelle verfügbar.</p>
        </div>
    </div>

    <footer class="footer p-10 bg-base-300 text-base-content mt-16">
        <div class="container mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                <div>
                    <h3 class="footer-title text-base-content">VoxelShaper</h3>
                    <p class="mt-4">Die Community für 3D-Voxelmodelle. Teile, entdecke und drucke einzigartige Kreationen.</p>
                    <div class="flex gap-4 mt-4">
                        <a href="#"><i class="fab fa-discord text-xl"></i></a>
                        <a href="#"><i class="fab fa-twitter text-xl"></i></a>
                        <a href="#"><i class="fab fa-instagram text-xl"></i></a>
                        <a href="#"><i class="fab fa-github text-xl"></i></a>
                    </div>
                </div>
                <div>
                    <h3 class="footer-title">Ressourcen</h3>
                    <a class="link link-hover mt-4">Blog</a>
                    <a class="link link-hover">Tutorials</a>
                    <a class="link link-hover">Dokumentation</a>
                    <a class="link link-hover">API</a>
                </div>
                <div>
                    <h3 class="footer-title">Community</h3>
                    <a class="link link-hover mt-4">Forum</a>
                    <a class="link link-hover">Events</a>
                    <a class="link link-hover">Mitwirkende</a>
                    <a class="link link-hover">Partner</a>
                </div>
                <div>
                    <h3 class="footer-title">Rechtliches</h3>
                    <a class="link link-hover mt-4">AGB</a>
                    <a class="link link-hover">Datenschutz</a>
                    <a class="link link-hover">Lizenzierung</a>
                    <a class="link link-hover">Cookie-Richtlinie</a>
                </div>
            </div>
            <div class="border-t border-base-content/20 mt-12 pt-6 text-center">
                <p>© 2023 VoxelShaper. Alle Rechte vorbehalten.</p>
            </div>
        </div>
    </footer>

    <dialog id="auth-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg text-center">Anmeldung bei VoxelShaper</h3>
            <p class="py-4 text-center">Melde dich an, um Modelle zu bewerten, herunterzuladen und eigene Kreationen zu teilen.</p>
            <div class="modal-action flex flex-col items-center w-full">
                <form method="dialog" class="w-full">
                    <div class="flex flex-col gap-3 w-full">
                        <input id="email-input" type="email" placeholder="E-Mail" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="email" />
                        <input id="password-input" type="password" placeholder="Passwort" class="input input-bordered w-full bg-base-300 border-base-content/20" autocomplete="current-password" />
                        <button id="firebase-login" class="btn btn-primary w-full">
                            <i class="fas fa-sign-in-alt mr-2"></i> Anmelden
                        </button>
                        <button id="firebase-signup" class="btn btn-secondary w-full">
                            <i class="fas fa-user-plus mr-2"></i> Registrieren
                        </button>
                        <div class="divider text-base-content/60">ODER</div>
                        <button id="google-login" class="btn btn-info w-full">
                            <i class="fab fa-google mr-2"></i> Mit Google anmelden
                        </button>
                        <button id="github-login" class="btn w-full bg-neutral hover:bg-neutral-focus text-neutral-content border-none">
                            <i class="fab fa-github mr-2"></i> Mit GitHub anmelden
                        </button>
                        <button class="btn btn-outline w-full" onclick="document.getElementById('auth-modal').close()">Abbrechen</button>
                    </div>
                    <p id="auth-error-message" class="text-error text-sm mt-4 text-center hidden"></p>
                </form>
            </div>
        </div>
    </dialog>

    <dialog id="upload-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Modell hochladen</h3>
            <p class="py-4">Lade dein 3D-Voxelmodell hoch.</p>
            <div class="modal-action">
                <form method="dialog" class="w-full">
                    <div class="flex flex-col gap-3">
                        <label for="project-json-input" class="label">
                            <span class="label-text text-base-content/60">Projektdatei (.json)</span>
                        </label>
                        <input id="project-json-input" type="file" class="file-input file-input-bordered w-full bg-base-300 border-base-content/20" accept=".json" required />
                        <p id="json-error-message" class="text-error text-sm mt-2 hidden"></p>
                        
                        <div class="divider text-base-content/60">Details</div>
                        <input id="model-title-input" type="text" placeholder="Titel" class="input input-bordered w-full bg-base-300 border-base-content/20" required />
                        <textarea id="model-description-input" placeholder="Beschreibung" class="textarea textarea-bordered w-full bg-base-300 border-base-content/20 h-24"></textarea>
                        
                        <select id="model-category-input" class="select select-bordered w-full bg-base-300 border-base-content/20" required>
                            <option value="" disabled selected>Kategorie</option>
                            <!-- Kategorien werden dynamisch aus predefinedCategories geladen -->
                        </select>
                        
                        <select id="visibility-select" class="select select-bordered w-full bg-base-300 border-base-content/20">
                            <option value="public">Öffentlich</option>
                            <option value="private">Privat</option>
                        </select>

                        <button id="upload-submit-button" class="btn btn-primary w-full mt-4" disabled>
                            <i class="fas fa-upload mr-2"></i> Hochladen
                        </button>
                    </div>
                    <button class="btn btn-outline w-full mt-4" onclick="document.getElementById('upload-modal').close()">Abbrechen</button>
                    <p id="upload-error-message" class="text-error text-sm mt-2 hidden"></p>
                    <p id="upload-success-message" class="text-success text-sm mt-2 hidden"></p>
                </form>
            </div>
        </div>
    </dialog>

    <dialog id="delete-confirm-modal" class="modal">
        <div class="modal-box bg-base-200">
            <h3 class="font-bold text-lg">Modell löschen bestätigen</h3>
            <p class="py-4">Möchten Sie das Modell "<span id="model-to-delete-title" class="font-semibold"></span>" wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.</p>
            <div class="modal-action">
                <button id="confirm-delete-button" class="btn btn-error">Löschen</button>
                <button class="btn btn-outline" onclick="document.getElementById('delete-confirm-modal').close()">Abbrechen</button>
            </div>
        </div>
    </dialog>

    <div id="toast-container" class="toast toast-end z-50"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { 
            getAuth, 
            setPersistence,
            browserLocalPersistence, 
            signInWithEmailAndPassword, 
            createUserWithEmailAndPassword, 
            onAuthStateChanged,
            signOut,
            GoogleAuthProvider, 
            GithubAuthProvider,
            signInWithPopup, 
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            addDoc, 
            serverTimestamp,
            query, 
            limit, 
            getDocs, 
            startAfter,
            where,
            doc, 
            getDoc,
            updateDoc,
            deleteDoc, 
            orderBy, 
            runTransaction, // Import runTransaction for atomic updates
            or, // Import 'or' for combining queries
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";


        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB9-mpyAu9W6oiVtB0fYG8E6YFvTAsjtAA",
            authDomain: "voxelshaper.firebaseapp.com", 
            projectId: "voxelshaper",
            storageBucket: "voxelshaper.firebasestorage.app", 
            messagingSenderId: "1053689247573",
            appId: "1:1053689247573:web:f7960c7f8c2e8849e8e1dc",
            measurementId: "G-QJ5CNKZ5DR"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        let currentUser = null;
        let currentUserId = null;
        let _isAdmin = false; // Global variable to store admin status
        let initialAuthCheckCompleted = false; // New flag to track initial auth state resolution
        let manualFilterResetActive = false; // NEW: Flag to indicate a manual filter reset

        // Variables for infinite scrolling
        const MODELS_PER_LOAD = 8;
        let lastVisible = null;
        let isLoadingModels = false; 
        let allModelsData = []; // Store all fetched model data for client-side filtering

        // UI Elemente
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const profileButton = document.getElementById('profile-button');
        const userMenuButton = document.getElementById('user-menu-button');
        const authModal = document.getElementById('auth-modal');
        const firebaseLoginButton = document.getElementById('firebase-login');
        const firebaseSignupButton = document.getElementById('firebase-signup');
        const googleLoginButton = document.getElementById('google-login'); 
        const githubLoginButton = document.getElementById('github-login'); 
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const authErrorMessage = document.getElementById('auth-error-message');
        const htmlElement = document.documentElement; // Get the html element
        const themeToggle = document.getElementById('theme-toggle'); // Theme Toggle Element

        // Upload Modal Elemente
        const uploadModelButton = document.getElementById('upload-model-button');
        const uploadModal = document.getElementById('upload-modal');
        const jsonErrorMessage = document.getElementById('json-error-message'); 

        const modelTitleInput = document.getElementById('model-title-input');
        const modelDescriptionInput = document.getElementById('model-description-input');
        const modelCategoryInput = document.getElementById('model-category-input'); 
        const projectJsonInput = document.getElementById('project-json-input'); 
        const visibilitySelect = document.getElementById('visibility-select'); 
        const uploadSubmitButton = document.getElementById('upload-submit-button');
        const uploadErrorMessage = document.getElementById('upload-error-message');
        const uploadSuccessMessage = document.getElementById('upload-success-message');

        // Modellelemente für die endlose Liste
        const modelsGrid = document.getElementById('models-grid');
        const loadingSpinner = document.getElementById('loading-spinner');
        const noMoreModelsMessage = document.getElementById('no-more-models');
        const loadingSentinel = document.getElementById('loading-sentinel'); 

        // Filter- und Sortier-Elemente
        const sortBy = document.getElementById('sort-by');
        const categoryFilterButtonsContainer = document.getElementById('category-filter-buttons'); // New: Category buttons container
        let activeCategory = 'all'; // New: To track active category button
        const statusFilterSelect = document.getElementById('status-filter-select');
        const statusFilterContainer = document.getElementById('status-filter-container');
        const searchInput = document.getElementById('search-input'); // Moved to navbar
        const resetFiltersButton = document.getElementById('reset-filters-button');

        // Auth Providers
        const googleProvider = new GoogleAuthProvider();
        const githubProvider = new GithubAuthProvider(); 

        // Variable to store parsed project JSON data
        let currentProjectJsonData = null;
        let currentProjectJsonFile = null; 

        // Definierte Kategorien für den Upload
        const predefinedCategories = ["Alle", "Spielzeug", "Dekoration", "Funktional", "Kunst", "Allgemein"]; // "Alle" added for filter buttons

        // UI Elements for Navbar Links
        const navDiscoverButton = document.getElementById('nav-discover');
        const navPopularButton = document.getElementById('nav-popular');
        const navNewButton = document.getElementById('nav-new');
        const navCategoriesButton = document.getElementById('nav-categories');

        // Variable to store the element that triggered a modal, for focus return
        let lastFocusedElement = null;

        // Function to check if the current user is an admin
        function isAdmin() {
            return _isAdmin;
        }

        // Variable to store the ID of the model to be deleted
        let modelIdToDelete = null; 

        // Function to initialize the categories in the filter and upload modal
        function initializeCategoryOptions() {
            // For category filter buttons
            categoryFilterButtonsContainer.innerHTML = ''; // Clear previous buttons
            predefinedCategories.forEach(category => {
                const button = document.createElement('button');
                button.className = `btn btn-sm category-filter-btn ${category === activeCategory ? 'btn-active btn-primary' : 'btn-ghost'}`;
                button.textContent = category;
                button.dataset.category = category === 'Alle' ? 'all' : category; // Use 'all' for the "Alle" button
                button.setAttribute('aria-pressed', category === activeCategory ? 'true' : 'false'); // ARIA attribute
                categoryFilterButtonsContainer.appendChild(button);

                button.addEventListener('click', () => {
                    setActiveCategory(button.dataset.category);
                    resetAndFetch();
                });
            });

            // For upload modal category select (excluding "Alle")
            modelCategoryInput.innerHTML = '<option value="" disabled selected>Kategorie auswählen</option>';
            predefinedCategories.filter(cat => cat !== "Alle").forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                modelCategoryInput.appendChild(option);
            });
        }

        // Function to set the active category button
        function setActiveCategory(category) {
            activeCategory = category;
            document.querySelectorAll('.category-filter-btn').forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('btn-active', 'btn-primary');
                    btn.classList.remove('btn-ghost');
                    btn.setAttribute('aria-pressed', 'true');
                } else {
                    btn.classList.remove('btn-active', 'btn-primary');
                    btn.classList.add('btn-ghost');
                    btn.setAttribute('aria-pressed', 'false');
                }
            });
        }

        // Global variables for toast management
        let lastToastTime = 0;
        const MIN_TOAST_INTERVAL = 1500; // 1.5 seconds minimum between toasts

        // Function to show toast notifications
        function showToast(message, type = 'info', duration = 3000) {
            const now = Date.now();
            if (now - lastToastTime < MIN_TOAST_INTERVAL) {
                console.log("Toast suppressed due to interval:", message);
                return; // Suppress toast if too soon
            }
            lastToastTime = now; // Update last toast time

            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                console.error("Toast container not found!");
                return;
            }

            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.setAttribute('role', 'alert'); // ARIA role
            alertDiv.innerHTML = `
                ${type === 'info' ? '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>' : ''}
                ${type === 'success' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
                ${type === 'error' ? '<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>' : ''}
                <span>${message}</span>
            `;
            toastContainer.appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.remove();
            }, duration);
        }

        // Function to hide messages (kept for compatibility)
        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
        }

        // Update UI based on login status
        async function updateUI(user) {
            console.log(`[updateUI] Start: user=${user ? user.email : 'null'}, _isAdmin=${_isAdmin}, manualFilterResetActive=${manualFilterResetActive}`);

            if (user) {
                loginButton.classList.add('hidden');
                logoutButton.classList.remove('hidden');
                profileButton.classList.remove('hidden');
                
                // Display user's profile picture or initial
                let avatarContent;
                if (user.photoURL) {
                    avatarContent = `<img src="${user.photoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
                } else if (user.email) {
                    avatarContent = `<span class="text-white">${user.email.charAt(0).toUpperCase()}</span>`;
                } else {
                    avatarContent = `<i class="fas fa-user text-lg"></i>`; 
                }

                userMenuButton.innerHTML = `
                    <div class="avatar">
                        <div class="w-10 rounded-full bg-primary flex items-center justify-center">
                            ${avatarContent}
                        </div>
                    </div>
                `;

                // Add 'Unverifiziert' option if admin, remove if not
                if (_isAdmin) {
                    console.log("[updateUI] User is admin. Checking/adding 'Unverifiziert' option.");
                    if (!statusFilterSelect.querySelector('option[value="unverified"]')) {
                        const unverifiedOption = document.createElement('option');
                        unverifiedOption.value = 'unverified';
                        unverifiedOption.textContent = 'Unverifiziert';
                        statusFilterSelect.appendChild(unverifiedOption);
                        console.log("[updateUI] 'Unverifiziert' option added.");
                    }
                    // Only set to 'unverified' if it's not already 'all' or 'verified' from a previous state.
                    // AND if a manual reset is not active.
                    if (!manualFilterResetActive && (statusFilterSelect.value === 'verified' || statusFilterSelect.value === 'all')) {
                        statusFilterSelect.value = 'unverified';
                        console.log(`[updateUI] statusFilterSelect.value set to 'unverified' for admin (not manual reset).`);
                    } else if (manualFilterResetActive) {
                        console.log(`[updateUI] Manual filter reset active, preserving current statusFilterSelect.value (${statusFilterSelect.value}).`);
                    }
                } else {
                    console.log("[updateUI] User is NOT admin. Checking/removing 'Unverifiziert' option.");
                    const unverifiedOption = statusFilterSelect.querySelector('option[value="unverified"]');
                    if (unverifiedOption) { 
                        unverifiedOption.remove(); 
                        console.log("[updateUI] 'Unverifiziert' option removed.");
                    }
                    if (statusFilterSelect.value === 'unverified') { // If it was previously unverified (as admin), reset to verified
                        statusFilterSelect.value = 'verified'; 
                        console.log(`[updateUI] statusFilterSelect.value set to 'verified' for non-admin.`);
                    }
                }
                
                console.log(`[updateUI] End: Calling resetAndFetch. _isAdmin=${_isAdmin}, statusFilterSelect.value=${statusFilterSelect.value}`);
                resetAndFetch(); 

            } else { // User is logged out
                console.log("[updateUI] User is logged out.");
                loginButton.classList.remove('hidden');
                logoutButton.classList.add('hidden');
                profileButton.classList.add('hidden');
                
                userMenuButton.innerHTML = `
                    <div class="bg-neutral text-neutral-content rounded-full w-10 flex items-center justify-center">
                        <i class="fas fa-user text-lg"></i> </div>
                `;
                _isAdmin = false; // Reset admin status on logout
                const unverifiedOption = statusFilterSelect.querySelector('option[value="unverified"]');
                if (unverifiedOption) { unverifiedOption.remove(); }
                statusFilterSelect.value = 'verified'; // Default to 'verified' for logged out users

                console.log(`[updateUI] End: Calling resetAndFetch (logged out). _isAdmin=${_isAdmin}, statusFilterSelect.value=${statusFilterSelect.value}`);
                resetAndFetch(); 
            }
        }

        // Helper function to get computed color from DaisyUI CSS variable for Three.js background
        function getDaisyUICSSColorForThreeJS(selectedTheme) {
            const originalTheme = htmlElement.getAttribute('data-theme');
            htmlElement.setAttribute('data-theme', selectedTheme); // Apply the new theme

            // Force a reflow/recalculation to ensure styles are applied
            void document.body.offsetHeight; 

            // Now get the computed background color of the body, which should reflect the new theme
            const computedColor = getComputedStyle(document.body).backgroundColor;
            
            // Restore the original theme
            htmlElement.setAttribute('data-theme', originalTheme); 

            let hexColor = '#000000'; // Default fallback

            // Use a temporary canvas to get reliable RGB values from any CSS color string
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = computedColor;
            ctx.fillRect(0, 0, 1, 1);
            const pixelData = ctx.getImageData(0, 0, 1, 1).data;
            
            // Convert RGBA to Hex
            const toHex = (c) => c.toString(16).padStart(2, '0');
            hexColor = `#${toHex(pixelData[0])}${toHex(pixelData[1])}${toHex(pixelData[2])}`;

            // Adjust color based on theme for better contrast
            let r = pixelData[0];
            let g = pixelData[1];
            let b = pixelData[2];

            const adjustmentFactor = 0.1; // Adjust by 10%

            if (selectedTheme === 'dark') {
                // Lighten the color slightly for dark mode
                r = Math.min(255, r + Math.round(r * adjustmentFactor));
                g = Math.min(255, g + Math.round(g * adjustmentFactor));
                b = Math.min(255, b + Math.round(b * adjustmentFactor));
            } else { // light mode
                // Darken the color slightly for light mode
                r = Math.max(0, r - Math.round(r * adjustmentFactor));
                g = Math.max(0, g - Math.round(g * adjustmentFactor));
                b = Math.max(0, b - Math.round(b * adjustmentFactor));
            }

            hexColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;

            return hexColor;
        }

        // Three.js Voxel Renderer for preview cards
        class VoxelPreviewRenderer {
            constructor(canvasElement, voxelsData, gridSize = 10, backgroundColor) { 
                this.canvas = canvasElement;
                this.voxelsData = voxelsData; 
                this.gridSize = gridSize;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null; 
                this.animationFrameId = null;
                this.pivotGroup = null; 
                this.instancedMesh = null; 
                this.isAnimating = false; 
                this.autoRotateEnabled = false; 
                this.backgroundColor = backgroundColor; 

                this.isDragging = false;
                this.lastMouseX = 0;
                this.isTouching = false;
                this.lastTouchX = 0;
                this.lastTouchY = 0; 

                this.init();
            }

            init() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(this.backgroundColor); 

                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true }); 

                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000); 

                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);

                const ambientLight = new THREE.AmbientLight(0x606060); 
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
                directionalLight.position.set(1, 1, 1).normalize();
                this.scene.add(directionalLight);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true; 
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 500;
                this.controls.enabled = false; 
                this.controls.enableZoom = false; 
                this.controls.update(); 

                this.loadVoxels(); 
                // Removed event listeners from init to prevent multiple bindings.
                // They are now added only once per card.
            }

            loadVoxels() {
                console.log("VoxelPreviewRenderer loadVoxels - actual voxelsData:", this.voxelsData);
                const voxelKeys = Object.keys(this.voxelsData || {}); 
                
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.traverse((object) => {
                        if (object.isMesh) {
                            object.geometry.dispose();
                            object.material.dispose();
                        }
                    });
                    this.pivotGroup.clear();
                    this.pivotGroup = null;
                }
                this.instancedMesh = null; 

                if (!this.voxelsData || voxelKeys.length === 0) {
                    console.warn("Keine Voxeldaten zum Laden für die Vorschau. Szene wird geleert.");
                    this.canvas.classList.add('opacity-0'); 
                    this.canvas.classList.remove('opacity-100');
                    const parentDiv = this.canvas.parentElement;
                    let messageDiv = parentDiv.querySelector('.preview-message');
                    if (!messageDiv) {
                        messageDiv = document.createElement('div');
                        messageDiv.className = 'preview-message absolute inset-0 flex items-center justify-center text-base-content/60 text-sm';
                        parentDiv.appendChild(messageDiv);
                    }
                    messageDiv.textContent = 'Keine Vorschau verfügbar (keine Voxeldaten)';
                    return; 
                } else {
                    this.canvas.classList.remove('opacity-0'); 
                    this.canvas.classList.add('opacity-100');
                    const parentDiv = this.canvas.parentElement;
                    const messageDiv = parentDiv.querySelector('.preview-message');
                    if (messageDiv) {
                        messageDiv.remove(); 
                    }
                }

                const voxelGeometry = new THREE.BoxGeometry(1, 1, 1);
                const dummy = new THREE.Object3D();
                const meshMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });

                const maxInstances = voxelKeys.length;
                const instancedMesh = new THREE.InstancedMesh(voxelGeometry, meshMaterial, maxInstances);
                instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(maxInstances * 3), 3);
                instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
                
                let instanceId = 0;
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (const key of voxelKeys) { 
                    const parts = key.split(',').map(Number);
                    if (parts.length === 3) {
                        const [x, y, z] = parts;
                        const colorHex = this.voxelsData[key];
                        const color = new THREE.Color(colorHex);

                        dummy.position.set(x + 0.5, y + 0.5, z + 0.5); 
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(instanceId, dummy.matrix);
                        instancedMesh.instanceColor.setXYZ(instanceId, color.r, color.g, color.b);
                        instanceId++;

                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        minZ = Math.min(minZ, z);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        maxZ = Math.max(maxZ, z);
                    }
                }
                instancedMesh.count = instanceId;
                instancedMesh.instanceMatrix.needsUpdate = true;
                instancedMesh.instanceColor.needsUpdate = true;
                
                this.pivotGroup = new THREE.Group();
                this.scene.add(this.pivotGroup); 

                const modelBoundingBox = new THREE.Box3(
                    new THREE.Vector3(minX, minY, minZ),
                    new THREE.Vector3(maxX + 1, maxY + 1, maxZ + 1) 
                );
                const modelCenter = new THREE.Vector3();
                modelBoundingBox.getCenter(modelCenter);

                instancedMesh.position.sub(modelCenter);
                this.pivotGroup.add(instancedMesh); 
                this.instancedMesh = instancedMesh; 

                const centeredModelTarget = new THREE.Vector3(0, 0, 0);

                const boundingSphere = new THREE.Sphere();
                modelBoundingBox.getBoundingSphere(boundingSphere);
                const radius = boundingSphere.radius;

                const fov = this.camera.fov * (Math.PI / 180); 
                let distance = radius / Math.tan(fov / 2);

                distance *= 1.2; 

                const cameraOffset = new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(distance);
                this.camera.position.copy(centeredModelTarget).add(cameraOffset); 
                this.camera.lookAt(centeredModelTarget); 
                this.camera.updateProjectionMatrix();

                this.controls.target.copy(centeredModelTarget);
                this.controls.update();
                this.renderer.render(this.scene, this.camera); 
            }

            startAnimation() {
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animationFrameId = requestAnimationFrame(this.animate.bind(this)); 
                }
            }

            stopAnimation() {
                if (this.isAnimating) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.isAnimating = false;
                }
            }

            startAutoRotation() {
                this.autoRotateEnabled = true;
            }

            stopAutoRotation() {
                this.autoRotateEnabled = false;
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(this.animate.bind(this));
                
                if (this.controls) {
                    this.controls.update();
                }

                this.renderer.render(this.scene, this.camera);

                if (this.autoRotateEnabled && this.pivotGroup && !this.isDragging && !this.isTouching) { 
                    this.pivotGroup.rotation.y += 0.005; 
                }
            }

            dispose() {
                this.stopAnimation(); 
                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        object.geometry.dispose();
                        object.material.dispose();
                        if (this.instancedMesh) {
                            this.instancedMesh.geometry.dispose();
                            this.instancedMesh.material.dispose();
                        }
                    } 
                });
                if (this.pivotGroup) {
                    this.scene.remove(this.pivotGroup);
                    this.pivotGroup.clear(); 
                }
                this.renderer.dispose();
                if (this.controls) {
                    this.controls.dispose();
                }

                // Remove event listeners when disposing
                this.canvas.removeEventListener('mousedown', this.onMouseDown);
                this.canvas.removeEventListener('mousemove', this.onMouseMove);
                this.canvas.removeEventListener('mouseup', this.onMouseUp);
                this.canvas.removeEventListener('mouseout', this.onMouseUp);

                this.canvas.removeEventListener('touchstart', this.onTouchStart); 
                this.canvas.removeEventListener('touchmove', this.onTouchMove); 
                this.canvas.removeEventListener('touchend', this.onTouchEnd);
                this.canvas.removeEventListener('touchcancel', this.onTouchEnd);
            }

            onMouseDown(event) {
                this.isDragging = true;
                this.lastMouseX = event.clientX;
                this.stopAutoRotation(); 
            }

            onMouseMove(event) {
                if (this.isDragging && this.pivotGroup) { 
                    const deltaX = event.clientX - this.lastMouseX;
                    this.pivotGroup.rotation.y += deltaX * 0.01; 
                    this.lastMouseX = event.clientX;
                    event.preventDefault(); 
                }
            }

            onMouseUp(event) {
                this.isDragging = false;
                const modelCard = this.canvas.closest('.model-card');
                if (modelCard) {
                    if (!isMobileDevice) {
                        const rect = modelCard.getBoundingClientRect();
                        if (event.clientX >= rect.left && event.clientX <= rect.right &&
                            event.clientY >= rect.top && event.clientY <= rect.bottom) {
                            this.startAutoRotation();
                        } else {
                            this.stopAutoRotation();
                        }
                    } else {
                        if (intersectionObserver) {
                            const entry = intersectionObserver.takeRecords().find(e => e.target === modelCard);
                            if (entry && entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!this.isDragging && !this.isTouching) { 
                                    this.startAutoRotation(); 
                                }
                            } else {
                                this.stopAutoRotation(); 
                            }
                        }
                    }
                }
            }

            onTouchStart(event) {
                if (event.touches.length === 1) { 
                    this.isTouching = true;
                    this.lastTouchX = event.touches[0].clientX;
                    this.lastTouchY = event.touches[0].clientY; 
                    this.stopAutoRotation(); 
                }
            }

            onTouchMove(event) {
                if (this.isTouching && event.touches.length === 1 && this.pivotGroup) { 
                    const deltaX = event.touches[0].clientX - this.lastTouchX;
                    const deltaY = event.touches[0].clientY - this.lastTouchY; 
                    
                    if (Math.abs(deltaX) > Math.abs(deltaY) || Math.abs(deltaY) < 5) { 
                        this.pivotGroup.rotation.y += deltaX * 0.01; 
                    }
                    this.lastTouchX = event.touches[0].clientX;
                    this.lastTouchY = event.touches[0].clientY; 
                }
            }

            onTouchEnd(event) {
                this.isTouching = false;
                this.lastTouchY = undefined; 
                const modelCard = this.canvas.closest('.model-card');
                if (modelCard) {
                    if (intersectionObserver) {
                        const entry = intersectionObserver.takeRecords().find(e => e.target === modelCard);
                        if (entry && entry.isIntersecting && entry.intersectionRatio > 0.75) {
                            this.startAutoRotation();
                        } else {
                            this.stopAutoRotation();
                        }
                    }
                }
            }
        }

        // Global map to store renderer instances
        const rendererInstances = new Map();
        // Determine if it's a mobile device (or small screen)
        const isMobileDevice = window.innerWidth <= 768; 

        // Intersection Observer for mobile auto-rotation
        let intersectionObserver;
        if (isMobileDevice) {
            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const modelId = entry.target.dataset.modelId;
                    const renderer = rendererInstances.get(modelId);

                    if (renderer) {
                        if (entry.isIntersecting && entry.intersectionRatio > 0.75) { 
                            if (!renderer.isDragging && !renderer.isTouching) {
                                renderer.startAutoRotation();
                                console.log(`Mobile: Modell ${modelId} ist >75% sichtbar. Starte automatische Rotation (wenn nicht gezogen wird).`);
                            }
                        } else {
                            renderer.stopAutoRotation();
                            console.log(`Mobile: Modell ${modelId} ist nicht >75% sichtbar. Stoppe automatische Rotation.`);
                        }
                    }
                });
            }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] }); 
        }


        // Function to create a model card
        function createModelCard(model) {
            const card = document.createElement('div');
            card.className = 'card bg-base-200 rounded-xl overflow-hidden border border-base-content/10 transition-transform duration-300 hover:translate-y-[-5px] hover:shadow-xl model-card'; 
            
            const rating = model.ratingCount > 0 ? (model.rating / model.ratingCount).toFixed(1) : '0.0';
            // Determine if the current user can rate this model
            const canRate = currentUser && currentUser.uid !== model.uploaderUid;

            const uploadDate = model.timestamp ? new Date(model.timestamp.toDate()).toLocaleDateString('de-DE') : 'Unbekannt';

            let uploaderAvatarHtml;
            if (model.uploaderPhotoURL) {
                uploaderAvatarHtml = `<img src="${model.uploaderPhotoURL}" alt="Profilbild" class="w-full h-full object-cover rounded-full">`;
            } else if (model.email) { 
                uploaderAvatarHtml = `<span class="text-white">${model.uploaderEmail.charAt(0).toUpperCase()}</span>`; 
            } else {
                uploaderAvatarHtml = `<i class="fas fa-user"></i>`; 
            }

            const isUploaderOrAdmin = currentUser && (currentUser.uid === model.uploaderUid || isAdmin());

            card.innerHTML = `
                <div class="h-52 flex items-center justify-center overflow-hidden relative text-base-content/60 text-sm text-center">
                    <!-- Skeleton Loader -->
                    <div class="skeleton h-full w-full absolute inset-0 flex flex-col gap-2 p-4 justify-center items-center z-10" id="skeleton-${model.id}">
                        <div class="skeleton h-32 w-full"></div>
                        <div class="skeleton h-4 w-28"></div>
                        <div class="skeleton h-4 w-full"></div>
                    </div>
                    <canvas class="voxel-preview-canvas w-full h-full block opacity-0 absolute inset-0 z-0 transition-opacity duration-500"></canvas>
                    <div class="preview-message absolute inset-0 flex items-center justify-center text-error text-sm hidden"></div>
                </div>
                <div class="card-body p-4">
                    <div class="flex justify-between items-start">
                        <div class="flex flex-col flex-grow">
                            <div class="flex items-center gap-2">
                                <h2 class="card-title text-lg" contenteditable="${isUploaderOrAdmin}" data-model-id="${model.id}" data-field="title">${model.title}</h2>
                                ${isUploaderOrAdmin ? `<span class="edit-icon text-base-content/50 cursor-pointer hidden"><i class="fas fa-pencil-alt"></i></span>` : ''}
                                <span class="save-status text-xs text-base-content/40 ml-2 hidden"></span>
                            </div>
                            <p class="text-base-content/60 text-sm mt-2" contenteditable="${isUploaderOrAdmin}" data-model-id="${model.id}" data-field="description">${model.description}</p>
                            ${isUploaderOrAdmin ? `<span class="edit-icon-desc text-base-content/50 cursor-pointer hidden"><i class="fas fa-pencil-alt"></i></span>` : ''}
                            <span class="save-status-desc text-xs text-base-content/40 ml-2 hidden"></span>
                        </div>
                        <div class="flex flex-col items-end gap-2 ml-4">
                            <div class="badge badge-outline badge-primary">${model.category || 'Allgemein'}</div>
                            ${model.verified ? `<div class="badge badge-success">Verifiziert</div>` : `<div class="badge badge-info">Unverifiziert</div>`}
                        </div>
                    </div>
                    <div class="mt-4 flex flex-col sm:flex-row sm:justify-between items-start sm:items-center gap-4">
                        <div>
                            <div class="flex items-center whitespace-nowrap">
                                <div class="rating rating-sm" data-model-id="${model.id}" data-current-rating="${model.userRating || 0}">
                                    ${[1, 2, 3, 4, 5].map(i => `
                                        <input type="radio" name="rating-${model.id}" class="mask mask-star-2 bg-warning ${canRate ? 'cursor-pointer' : 'cursor-default'}" value="${i}" ${model.userRating === i ? 'checked' : ''} ${canRate ? '' : 'disabled'} aria-label="${i} Sterne bewerten" />
                                    `).join('')}
                                </div>
                                <span class="text-base-content/60 ml-2">${rating} (${model.ratingCount || 0})</span>
                            </div>
                            <div class="text-base-content/60 text-sm mt-1">${model.downloads || 0} Downloads</div>
                        </div>
                        <div class="flex flex-wrap gap-2 justify-start sm:justify-end"> 
                            <button class="btn btn-primary btn-md download-button" data-model-id="${model.id}" data-model-title="${model.title}" aria-label="Modell herunterladen">
                                <i class="fas fa-download"></i>
                            </button>
                            <button class="btn btn-secondary btn-md open-voxelshaper-button" data-model-id="${model.id}" aria-label="In VoxelShaper öffnen">
                                <i class="fas fa-external-link-alt"></i>
                            </button>

                            <!-- Admin-only buttons -->
                            ${isAdmin() ? `
                                ${!model.verified ? `<button class="btn btn-success btn-md verify-button" data-model-id="${model.id}" aria-label="Modell verifizieren">
                                    <i class="fas fa-check"></i> Verifizieren
                                </button>` : `<button class="btn btn-warning btn-md revert-verify-button" data-model-id="${model.id}" aria-label="Verifizierung rückgängig machen">
                                    <i class="fas fa-undo"></i> Verifizierung rückgängig
                                </button>`}
                                <button class="btn btn-error btn-md delete-button" data-model-id="${model.id}" data-model-title="${model.title}" aria-label="Modell löschen">
                                    <i class="fas fa-trash"></i> Löschen
                                </button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="mt-4 flex items-center text-sm text-base-content/60">
                        <div class="avatar">
                            <div class="w-8 h-8 rounded-full bg-neutral text-neutral-content flex items-center justify-center text-lg">
                                ${uploaderAvatarHtml}
                            </div>
                        </div>
                        <span class="ml-2">${model.uploaderEmail ? model.uploaderEmail.split('@')[0] : 'Unbekannt'}</span>
                        <span class="ml-auto">${uploadDate}</span>
                    </div>
                </div>
            `;
            // Add event listener for the download button on the newly created card
            card.querySelector('.download-button').addEventListener('click', function() {
                handleDownload(this.dataset.modelId, this.dataset.modelTitle);
            });

            // Add event listener for the new "Open in VoxelShaper" button
            card.querySelector('.open-voxelshaper-button').addEventListener('click', function() {
                handleOpenOnVoxelShaper(this.dataset.modelId);
            });

            // Add event listener for the verify button
            const verifyButton = card.querySelector('.verify-button');
            if (verifyButton) {
                verifyButton.addEventListener('click', function() {
                    verifyModel(this.dataset.modelId);
                });
            }

            // Add event listener for the revert verification button
            const revertVerifyButton = card.querySelector('.revert-verify-button');
            if (revertVerifyButton) {
                revertVerifyButton.addEventListener('click', function() {
                    revertVerification(this.dataset.modelId);
                });
            }

            // Add event listener for the delete button
            const deleteButton = card.querySelector('.delete-button');
            if (deleteButton) {
                deleteButton.addEventListener('click', function() {
                    showDeleteConfirmationModal(this.dataset.modelId, this.dataset.modelTitle);
                });
            }

            // Add event listener for rating
            const ratingInputs = card.querySelectorAll(`.rating-sm input[type="radio"]`);
            ratingInputs.forEach(input => {
                input.addEventListener('change', function() {
                    if (canRate) {
                        rateModel(model.id, parseInt(this.value));
                    } else {
                        showToast('Bitte melden Sie sich an oder bewerten Sie nicht Ihr eigenes Modell.', 'info');
                        // Revert the radio button state if not allowed to rate
                        const currentModel = allModelsData.find(m => m.id === model.id);
                        if (currentModel && currentModel.userRating) {
                            this.closest('.rating').querySelector(`input[value="${currentModel.userRating}"]`).checked = true;
                        } else {
                            // If no previous rating, uncheck all to revert to "no rating" visual
                            this.closest('.rating').querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = false);
                        }
                    }
                });
            });


            // In-place editing logic
            if (isUploaderOrAdmin) {
                const titleElement = card.querySelector('h2[data-field="title"]');
                const descriptionElement = card.querySelector('p[data-field="description"]');
                const titleEditIcon = card.querySelector('.edit-icon');
                const descEditIcon = card.querySelector('.edit-icon-desc');
                const titleSaveStatus = card.querySelector('.save-status');
                const descSaveStatus = card.querySelector('.save-status-desc');

                // Show/hide edit icons on hover/focus
                titleElement.addEventListener('mouseenter', () => titleEditIcon.classList.remove('hidden'));
                titleElement.addEventListener('mouseleave', () => { if (document.activeElement !== titleElement) titleEditIcon.classList.add('hidden'); });
                titleElement.addEventListener('focus', () => titleEditIcon.classList.remove('hidden'));
                titleElement.addEventListener('blur', () => titleEditIcon.classList.add('hidden'));

                descriptionElement.addEventListener('mouseenter', () => descEditIcon.classList.remove('hidden'));
                descriptionElement.addEventListener('mouseleave', () => { if (document.activeElement !== descriptionElement) descEditIcon.classList.add('hidden'); });
                descriptionElement.addEventListener('focus', () => descEditIcon.classList.remove('hidden'));
                descriptionElement.addEventListener('blur', () => descEditIcon.classList.add('hidden'));


                // Handle saving on blur
                titleElement.addEventListener('blur', async (event) => {
                    const newTitle = event.target.textContent.trim();
                    if (newTitle !== model.title) {
                        await handleInPlaceEdit(model.id, 'title', newTitle, titleSaveStatus);
                    }
                });

                descriptionElement.addEventListener('blur', async (event) => {
                    const newDescription = event.target.textContent.trim();
                    if (newDescription !== model.description) {
                        await handleInPlaceEdit(model.id, 'description', newDescription, descSaveStatus);
                    }
                });

                // Handle saving on Enter keydown
                titleElement.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent new line
                        titleElement.blur(); // Trigger blur to save
                    }
                });

                descriptionElement.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevent new line
                        descriptionElement.blur(); // Trigger blur to save
                    }
                });
            }

            // Assign model ID to the card element for easy lookup in Intersection Observer
            card.dataset.modelId = model.id; 

            return card;
        }

        // Function to initialize the preview renderer for a given card
        function initPreviewRendererForCard(card, model) {
            const previewCanvas = card.querySelector('.voxel-preview-canvas');
            const skeletonElement = card.querySelector(`#skeleton-${model.id}`); 
            const previewMessageDiv = card.querySelector('.preview-message'); 
            const modelId = card.dataset.modelId;
            const voxelsData = model.projectData ? model.projectData.voxels : {};
            const gridSize = (model.projectData && model.projectData.settings && model.projectData.settings.gridSize) ? model.projectData.settings.gridSize : 10;
            
            let previewRendererInstance = null; 
            let retryCount = 0;
            const MAX_RETRIES = 60; 

            // Show skeleton initially, hide canvas and message
            if (skeletonElement) skeletonElement.classList.remove('hidden');
            previewCanvas.classList.add('opacity-0'); 
            previewCanvas.classList.remove('opacity-100');
            if (previewMessageDiv) previewMessageDiv.classList.add('hidden');

            // Dynamic Three.js background color based on the current theme
            const currentTheme = htmlElement.getAttribute('data-theme');
            const threeJsBgColor = getDaisyUICSSColorForThreeJS(currentTheme);

            function initializePreviewRendererWithRetry() {
                console.log(`[VoxelPreviewRenderer] Versuch ${retryCount + 1} für Modell ${modelId}: Canvas clientWidth=${previewCanvas.clientWidth}, clientHeight=${previewCanvas.clientHeight}, offsetWidth=${previewCanvas.offsetWidth}, offsetHeight=${previewCanvas.offsetHeight}`);

                if (previewCanvas.clientWidth === 0 || previewCanvas.clientHeight === 0 || previewCanvas.offsetWidth === 0 || previewCanvas.offsetHeight === 0) {
                    console.log(`[VoxelPreviewRenderer] Canvas-Dimensionen sind 0 für Modell ${modelId}. Wiederhole... (Versuch ${retryCount + 1}/${MAX_RETRIES})`);
                    if (retryCount < MAX_RETRIES) {
                        retryCount++;
                        requestAnimationFrame(initializePreviewRendererWithRetry); 
                    } else {
                        console.warn(`[VoxelPreviewRenderer] Canvas hat nach maximalen Wiederholungen für Modell ${modelId} keine Größe.`);
                        console.error(`[VoxelPreviewRenderer] FEHLER beim Initialisieren des Renderers für Modell ${modelId} nach ${MAX_RETRIES} Versuchen aufgrund von Null-Canvas-Größe.`);
                        previewCanvas.classList.add('hidden'); 
                        if (skeletonElement) skeletonElement.classList.remove('hidden'); 
                        if (previewMessageDiv) {
                            previewMessageDiv.textContent = 'Keine Vorschau verfügbar (Canvas-Größe 0).';
                            previewMessageDiv.classList.remove('hidden'); 
                            previewMessageDiv.classList.add('text-error');
                        }
                        previewRendererInstance = null; 
                    }
                } else {
                    try {
                        console.log(`[VoxelPreviewRenderer] Canvas-Dimensionen sind ${previewCanvas.clientWidth}x${previewCanvas.clientHeight} für Modell ${modelId}. Initialisiere Renderer.`);
                        previewRendererInstance = new VoxelPreviewRenderer(previewCanvas, voxelsData, gridSize, threeJsBgColor); 
                        previewRendererInstance.renderer.render(previewRendererInstance.scene, previewRendererInstance.camera);

                        if (skeletonElement) skeletonElement.classList.add('hidden');
                        previewCanvas.classList.remove('opacity-0');
                        previewCanvas.classList.add('opacity-100');
                        if (previewMessageDiv) previewMessageDiv.classList.add('hidden');

                        rendererInstances.set(model.id, previewRendererInstance);

                        if (!isMobileDevice) {
                            card.addEventListener('mouseenter', () => {
                                console.log(`Desktop: Maus betrat Karte für Modell ${model.id}. Starte automatische Rotation.`);
                                if (previewRendererInstance) {
                                    previewRendererInstance.startAutoRotation();
                                }
                            });
                            card.addEventListener('mouseleave', () => {
                                console.log(`Desktop: Maus verließ Karte für Modell ${model.id}. Stoppe automatische Rotation.`);
                                if (previewRendererInstance) {
                                    previewRendererInstance.stopAutoRotation();
                                }
                            });
                            previewRendererInstance.stopAutoRotation();
                        } else {
                            if (intersectionObserver) {
                                console.log(`Mobile: Beobachte Karte für Modell ${model.id} mit IntersectionObserver.`);
                                intersectionObserver.observe(card); 
                            }
                            previewRendererInstance.stopAutoRotation();
                        }

                        previewRendererInstance.startAnimation();

                    } catch (error) {
                        console.error("[VoxelPreviewRenderer] Fehler beim Initialisieren des VoxelPreviewRenderers für Modell", model.id, ":", error);
                        previewCanvas.classList.add('hidden'); 
                        if (skeletonElement) skeletonElement.classList.remove('hidden'); 
                        if (previewMessageDiv) {
                            previewMessageDiv.textContent = 'Fehler beim Laden der Vorschau.';
                            previewMessageDiv.classList.remove('hidden'); 
                            previewMessageDiv.classList.add('text-error');
                        }
                        previewRendererInstance = null; 
                    }
                }
            }

            requestAnimationFrame(initializePreviewRendererWithRetry); 
        }


        // Intersection Observer for Infinite Scrolling
        let infiniteScrollObserver;

        function setupInfiniteScrollObserver() {
            if (infiniteScrollObserver) {
                infiniteScrollObserver.disconnect();
            }

            infiniteScrollObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && !isLoadingModels && lastVisible) {
                        console.log("[InfiniteScroll] Sentinel sichtbar, lade weitere Modelle...");
                        fetchModels();
                    }
                });
            }, {
                root: null, 
                rootMargin: '0px',
                threshold: 0.1 
            });

            infiniteScrollObserver.observe(loadingSentinel);
        }

        // Function to load models from Firestore
        async function fetchModels() {
            if (isLoadingModels) {
                console.log("[fetchModels] Bereits Modelle am Laden, Abbruch.");
                return;
            }
            isLoadingModels = true;
            loadingSpinner.classList.remove('hidden');
            noMoreModelsMessage.classList.add('hidden'); 

            console.log(`\n--- fetchModels START ---`);
            console.log(`[fetchModels] _isAdmin (global): ${_isAdmin}`);
            console.log(`[fetchModels] statusFilterSelect.value (UI): ${statusFilterSelect.value}`);
            console.log(`[fetchModels] currentUser (global): ${currentUser ? currentUser.email : 'null'}`);
            
            try {
                let modelsCollectionRef = collection(db, "models");
                let queryConstraints = []; // Array to hold all where and orderBy clauses
                let fetchedModels = [];

                const selectedCategory = activeCategory; 
                const selectedStatus = statusFilterSelect.value;
                const currentSortBy = sortBy.value; 
                const currentUserIsAdmin = isAdmin(); // This will use the global _isAdmin
                const searchTerm = searchInput.value.toLowerCase().trim(); 

                console.log(`\n--- fetchModels Query Construction ---`);
                console.log(`[Query] Current User is Admin (from isAdmin() call): ${currentUserIsAdmin}`);
                console.log(`[Query] Selected Category: '${selectedCategory}'`);
                console.log(`[Query] Selected Status: '${selectedStatus}'`);
                console.log(`[Query] Current Sort By: '${currentSortBy}'`);
                console.log(`[Query] Search Term: '${searchTerm}'`);

                let queriesToExecute = [];

                if (currentUserIsAdmin && selectedStatus === 'all') {
                    // Admin and 'All' status: Perform two queries and combine results
                    console.log("[Query] Admin and 'All' status: Preparing two queries (verified=true and verified=false).");
                    
                    // Query for verified models
                    let verifiedConstraints = [];
                    if (selectedCategory !== 'all') {
                        verifiedConstraints.push(where("category", "==", selectedCategory));
                    }
                    verifiedConstraints.push(where("verified", "==", true));
                    if (currentSortBy.startsWith('newest')) {
                        verifiedConstraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                    }
                    if (lastVisible) {
                        verifiedConstraints.push(startAfter(lastVisible));
                    }
                    verifiedConstraints.push(limit(MODELS_PER_LOAD));
                    queriesToExecute.push(query(modelsCollectionRef, ...verifiedConstraints));
                    console.log("[Query]   - Query 1 (Verified):", query(modelsCollectionRef, ...verifiedConstraints));

                    // Query for unverified models
                    let unverifiedConstraints = [];
                    if (selectedCategory !== 'all') {
                        unverifiedConstraints.push(where("category", "==", selectedCategory));
                    }
                    unverifiedConstraints.push(where("verified", "==", false));
                    if (currentSortBy.startsWith('newest')) {
                        unverifiedConstraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                    }
                    if (lastVisible) {
                        unverifiedConstraints.push(startAfter(lastVisible));
                    }
                    unverifiedConstraints.push(limit(MODELS_PER_LOAD));
                    queriesToExecute.push(query(modelsCollectionRef, ...unverifiedConstraints));
                    console.log("[Query]   - Query 2 (Unverified):", query(modelsCollectionRef, ...unverifiedConstraints));

                } else {
                    // Single query path for non-admin or specific admin filters
                    if (currentUserIsAdmin) {
                        console.log("[Query] User is Admin. Applying admin-specific filters (not 'all' status).");
                        if (selectedStatus === 'unverified') {
                            queryConstraints.push(where("verified", "==", false));
                            console.log(`[Query] Added: where("verified", "==", false)`);
                        } else if (selectedStatus === 'verified') {
                            queryConstraints.push(where("verified", "==", true));
                            console.log(`[Query] Added: where("verified", "==", true)`);
                        }
                    } else {
                        console.log("[Query] User is NOT Admin. Applying public/verified filters.");
                        queryConstraints.push(where("visibility", "==", "public"));
                        console.log(`[Query] Added: where("visibility", "==", "public")`);

                        if (selectedStatus === 'verified') {
                            queryConstraints.push(where("verified", "==", true));
                            console.log(`[Query] Added: where("verified", "==", true)`);
                        }
                    }

                    // Apply category filter if not 'all'
                    if (selectedCategory !== 'all') {
                        queryConstraints.push(where("category", "==", selectedCategory));
                        console.log(`[Query] Added: where("category", "==", "${selectedCategory}")`);
                    }

                    // Apply Firestore ordering for 'newest' sorts
                    if (currentSortBy.startsWith('newest')) {
                        queryConstraints.push(orderBy("timestamp", currentSortBy.endsWith('-asc') ? "asc" : "desc"));
                        console.log(`[Query] Added: orderBy("timestamp", "${currentSortBy.endsWith('-asc' ? "asc" : "desc")}")`);
                    }

                    // Handle pagination
                    if (lastVisible) {
                        queryConstraints.push(startAfter(lastVisible));
                        console.log(`[Query] Added: startAfter(lastVisible)`);
                    }
                    queryConstraints.push(limit(MODELS_PER_LOAD));
                    console.log(`[Query] Added: limit(${MODELS_PER_LOAD})`);

                    queriesToExecute.push(query(modelsCollectionRef, ...queryConstraints));
                    console.log(`[Query] Final Firestore Query Object (Single Query):`, queriesToExecute[0]);
                }

                let allDocumentSnapshots = [];
                for (const q of queriesToExecute) {
                    const snapshots = await getDocs(q);
                    allDocumentSnapshots.push(...snapshots.docs);
                }
                
                // Remove duplicates if two queries were executed (e.g., if a model was somehow both verified and unverified, though unlikely)
                // Or simply to ensure unique models if there's any overlap in logic
                const uniqueModelIds = new Set();
                fetchedModels = [];
                allDocumentSnapshots.forEach((doc) => {
                    if (!uniqueModelIds.has(doc.id)) {
                        uniqueModelIds.add(doc.id);
                        fetchedModels.push({ id: doc.id, ...doc.data() });
                    }
                });

                console.log(`[fetchModels] Rohdaten von Firestore erhalten (nach möglicher Zusammenführung): ${fetchedModels.length} Modelle.`);

                // Fetch user's rating for each fetched model if logged in
                if (currentUser) {
                    console.log(`[fetchModels] Benutzer angemeldet (${currentUser.uid}). Rufe Benutzerbewertungen ab.`);
                    for (let i = 0; i < fetchedModels.length; i++) {
                        const model = fetchedModels[i];
                        const ratingDocRef = doc(db, `models/${model.id}/ratings`, currentUser.uid);
                        const ratingDocSnap = await getDoc(ratingDocRef);
                        if (ratingDocSnap.exists()) {
                            fetchedModels[i].userRating = ratingDocSnap.data().rating;
                            console.log(`[fetchModels] Modell ${model.id}: Benutzerbewertung ${fetchedModels[i].userRating} gefunden.`);
                        } else {
                            console.log(`[fetchModels] Modell ${model.id}: Keine Benutzerbewertung gefunden.`);
                        }
                    }
                }

                // Client-side filtering for search term
                let filteredModels = fetchedModels;
                if (searchTerm) {
                    filteredModels = fetchedModels.filter(model =>
                        model.title.toLowerCase().includes(searchTerm) ||
                        model.description.toLowerCase().includes(searchTerm)
                    );
                    console.log(`[fetchModels] Client-seitig gefilterte Modelle (Suchbegriff '${searchTerm}'): ${filteredModels.length} Modelle.`);
                }

                // In-memory sorting for 'popular' and 'top-rated'
                // Note: Firebase queries with 'where' and 'orderBy' on different fields require composite indexes.
                // If you encounter "The query requires an index..." errors, you'll need to create them in the Firebase Console.
                if (! (currentUserIsAdmin && selectedStatus === 'unverified') && !currentSortBy.startsWith('newest')) { // Re-evaluate condition for in-memory sort
                    console.log(`[fetchModels] Wende In-Memory-Sortierung an für: ${currentSortBy}`);
                    filteredModels.sort((a, b) => {
                        let comparison = 0;
                        if (currentSortBy.startsWith('popular')) {
                            comparison = (b.downloads || 0) - (a.downloads || 0); 
                        } else if (currentSortBy.startsWith('top-rated')) {
                            const ratingA = a.ratingCount > 0 ? (a.rating / a.ratingCount) : 0;
                            const ratingB = b.ratingCount > 0 ? (b.rating / b.ratingCount) : 0;
                            comparison = ratingB - ratingA; 
                        }

                        if (currentSortBy.endsWith('-asc')) {
                            return comparison * -1; 
                        }
                        return comparison; 
                    });
                }
                console.log(`--- fetchModels END ---`);

                if (filteredModels.length > 0) {
                    filteredModels.forEach(model => {
                        const newCard = createModelCard(model); 
                        modelsGrid.appendChild(newCard); 
                        initPreviewRendererForCard(newCard, model); 
                    });
                    // lastVisible should be the last document of the *last executed query*.
                    // For the two-query case, this gets complicated for true pagination.
                    // For simplicity, we will set lastVisible to the last doc of the combined set if we fetched enough.
                    // A more robust solution for two-query pagination would involve managing two lastVisible cursors.
                    // For now, we'll use the last document from the *last* query that returned results.
                    if (allDocumentSnapshots.length > 0) {
                        lastVisible = allDocumentSnapshots[allDocumentSnapshots.length - 1];
                    } else {
                        lastVisible = null;
                    }
                    console.log(`[fetchModels] ${filteredModels.length} Modelle zum Grid hinzugefügt. lastVisible aktualisiert.`);
                } else {
                    if (!lastVisible || allDocumentSnapshots.length === 0) {
                        noMoreModelsMessage.classList.remove('hidden'); 
                        console.log("[fetchModels] Keine weiteren Modelle verfügbar.");
                    }
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.unobserve(loadingSentinel);
                        loadingSentinel.classList.add('hidden'); 
                        console.log("[fetchModels] Infinite Scroll Observer deaktiviert.");
                    }
                }

                // This condition for showing/hiding the sentinel needs to be re-evaluated for the two-query case.
                // If we fetched less than MODELS_PER_LOAD across *both* queries, it means we're at the end.
                if (allDocumentSnapshots.length < MODELS_PER_LOAD) {
                    noMoreModelsMessage.classList.remove('hidden');
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.unobserve(loadingSentinel); 
                        loadingSentinel.classList.add('hidden');
                    }
                    console.log("[fetchModels] Weniger Modelle als pro Ladung erwartet, Ende der Liste erreicht.");
                } else {
                    loadingSentinel.classList.remove('hidden'); 
                    if (infiniteScrollObserver) {
                        infiniteScrollObserver.observe(loadingSentinel); 
                    }
                    console.log("[fetchModels] Mehr Modelle verfügbar, Infinite Scroll Observer aktiv.");
                }

                allModelsData = allModelsData.concat(filteredModels); // Add fetched models to global array


            } catch (error) {
                console.error("[fetchModels] FEHLER beim Abrufen von Modellen:", error);
                showToast(`Fehler beim Laden der Modelle: ${error.message}. Bitte überprüfen Sie Ihre Firebase Firestore Sicherheitsregeln und Indizes.`, 'error');
                loadingSentinel.classList.add('hidden'); 
            } finally {
                isLoadingModels = false;
                loadingSpinner.classList.add('hidden');
                console.log("[fetchModels] Ladevorgang abgeschlossen.");
            }
        }

        // Helper function to reset grid and fetch models
        function resetAndFetch() {
            console.log(`[resetAndFetch] Start: Grid wird geleert, Pagination zurückgesetzt.`);
            modelsGrid.innerHTML = ''; // Clear the grid
            lastVisible = null; // Reset pagination
            allModelsData = []; // Clear stored models
            rendererInstances.forEach(renderer => { if (renderer) renderer.dispose(); }); // Dispose Three.js renderers
            rendererInstances.clear(); // Clear renderer map

            setActiveCategory(activeCategory); // Re-apply active category styling
            sortBy.value = 'newest-desc';
            // statusFilterSelect reset depends on admin status, handled in updateUI (but overridden by resetFiltersButton)
            searchInput.value = ''; // Search input is now in header, not reset by general filter reset

            // Disconnect and re-initialize IntersectionObserver for mobile, if applicable
            if (intersectionObserver && isMobileDevice) {
                console.log("[resetAndFetch] Re-initializing mobile IntersectionObserver.");
                intersectionObserver.disconnect();
                intersectionObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        const modelId = entry.target.dataset.modelId;
                        const renderer = rendererInstances.get(modelId);
                        if (renderer) {
                            if (entry.isIntersecting && entry.intersectionRatio > 0.75) {
                                if (!renderer.isDragging && !renderer.isTouching) {
                                    renderer.startAutoRotation();
                                }
                            } else {
                                renderer.stopAutoRotation();
                            }
                        }
                    });
                }, { threshold: [0, 0.25, 0.5, 0.75, 1.0] });
            }
            console.log("[resetAndFetch] Rufe fetchModels auf.");
            fetchModels(); // Reload models
        }


        setPersistence(auth, browserLocalPersistence)
            .then(() => {
                console.log("[Firebase Auth] Persistence set to browserLocalPersistence.");
                onAuthStateChanged(auth, async (user) => { // Make this callback async
                    currentUser = user;
                    currentUserId = user?.uid || null;
                    console.log(`\n[onAuthStateChanged] Auth state changed. User: ${user ? user.email : 'null'}`);

                    // Determine admin status first, asynchronously
                    if (user) {
                        try {
                            const userDocRef = doc(db, "users", user.uid);
                            console.log(`[onAuthStateChanged] Fetching user doc for admin status: users/${user.uid}`);
                            const userDocSnap = await getDoc(userDocRef); // Await this
                            _isAdmin = (userDocSnap.exists() && userDocSnap.data().isAdmin === true);
                            console.log(`[onAuthStateChanged] Admin status determined: _isAdmin=${_isAdmin} (exists: ${userDocSnap.exists()}, isAdmin field: ${userDocSnap.exists() ? userDocSnap.data().isAdmin : 'N/A'})`);
                        } catch (error) {
                            console.error("[onAuthStateChanged] Fehler beim Abrufen des Admin-Status:", error);
                            _isAdmin = false;
                        }
                    } else {
                        _isAdmin = false; // Not logged in, not admin
                        console.log("[onAuthStateChanged] User logged out, _isAdmin set to false.");
                    }

                    // Now update UI based on determined status
                    console.log(`[onAuthStateChanged] Calling updateUI with user: ${user ? user.email : 'null'} and _isAdmin: ${_isAdmin}`);
                    updateUI(user); // This will now use the already determined _isAdmin

                    // Only fetch models if this is the first full auth state check
                    if (!initialAuthCheckCompleted) {
                        initialAuthCheckCompleted = true;
                        console.log("[onAuthStateChanged] Initial auth check completed.");
                        // resetAndFetch is already called by updateUI, so no need to call it here again.
                        // The initial fetch should happen through updateUI -> resetAndFetch.
                    }
                });
            })
            .catch((error) => {
                console.error("[Firebase Auth] Fehler bei setPersistence:", error);
                showToast(`Fehler bei der Anmeldungspersistenz: ${error.message}. Die Funktionalität könnte eingeschränkt sein.`, 'error');
            });


        // Login-Handler
        loginButton.addEventListener('click', (e) => {
            console.log("[UI Event] Login button clicked.");
            lastFocusedElement = e.currentTarget; // Store the element that triggered the modal
            hideMessage(authErrorMessage);
            authModal.showModal();
            emailInput.focus(); // Set focus to the first input field
        });

        // Modal close event listener to return focus
        authModal.addEventListener('close', () => {
            console.log("[UI Event] Auth modal closed.");
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });

        // Firebase Login
        firebaseLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Firebase Login button clicked.");
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value;

            try {
                await signInWithEmailAndPassword(auth, email, password);
                console.log("[Auth] Firebase Login successful.");
                // Add a small delay before closing to potentially mitigate COOP warnings
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich angemeldet!', 'success');
                }, 100); 
            } catch (error) {
                console.error("[Auth] Firebase Login Error:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    errorMessage = "Ungültige E-Mail oder Passwort.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showToast(errorMessage, 'error'); 
            }
        });

        // Firebase Signup
        firebaseSignupButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Firebase Signup button clicked.");
            hideMessage(authErrorMessage);
            const email = emailInput.value;
            const password = passwordInput.value; 

            try {
                await createUserWithEmailAndPassword(auth, email, password);
                console.log("[Auth] Firebase Signup successful.");
                // Add a small delay before closing to potentially mitigate COOP warnings
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Registrierung erfolgreich! Sie sind jetzt angemeldet.', 'success');
                }, 100);
            } catch (error) {
                console.error("[Auth] Firebase Signup Error:", error.code, error.message);
                let errorMessage = "Registrierung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/email-already-in-use') {
                    errorMessage = "Diese E-Mail-Adresse wird bereits verwendet.";
                } else if (error.code === 'auth/weak-password') {
                    errorMessage = "Das Passwort sollte mindestens 6 Zeichen lang sein.";
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = "Ungültiges E-Mail-Format.";
                }
                showToast(errorMessage, 'error'); 
            }
        });

        // Firebase Google Login (now uses popup)
        googleLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Google Login button clicked.");
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, googleProvider);
                console.log("[Auth] Google sign-in successful:", result.user);
                // Add a small delay before closing to potentially mitigate COOP warnings
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich mit Google angemeldet!', 'success');
                }, 100);
            } catch (error) {
                console.error("[Auth] Firebase Google Login Error:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console hinzu (Authentifizierung -> Einstellungen).`;
                } else {
                    errorMessage = `Anmeldung fehlgeschlagen: ${error.message}.`;
                }
                showToast(errorMessage, 'error'); 
            }
        });

        // Firebase GitHub Login (now uses popup)
        githubLoginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] GitHub Login button clicked.");
            hideMessage(authErrorMessage);
            try {
                const result = await signInWithPopup(auth, githubProvider);
                console.log("[Auth] GitHub sign-in successful:", result.user);
                // Add a small delay before closing to potentially mitigate COOP warnings
                setTimeout(() => {
                    authModal.close(); 
                    showToast('Erfolgreich mit GitHub angemeldet!', 'success');
                }, 100);
            } catch (error) {
                console.error("[Auth] Firebase GitHub Login Error:", error.code, error.message);
                let errorMessage = "Anmeldung fehlgeschlagen. Bitte versuchen Sie es erneut.";
                if (error.code === 'auth/popup-closed-by-user' || error.code === 'auth/cancelled-popup-request') {
                    errorMessage = "Anmeldung abgebrochen.";
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = "Diese Anmeldemethode ist in Ihrem Firebase-Projekt nicht aktiviert. Bitte überprüfen Sie die Firebase Console.";
                } else if (error.code === 'auth/network-request-failed') {
                    errorMessage = "Netzwerkfehler. Bitte überprüfen Sie Ihre Internetverbindung.";
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = `Fehler: Nicht autorisierte Domain. Bitte fügen Sie "${window.location.origin}" zu den autorisierten Domains in Ihrer Firebase Console hinzu (Authentifizierung -> Einstellungen).`;
                } else {
                    errorMessage = `Anmeldung fehlgeschlagen: ${error.message}.`;
                }
                showToast(errorMessage, 'error'); 
            }
        });


        // Firebase Logout
        logoutButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Auth] Logout button clicked.");
            try {
                await signOut(auth);
                console.log("[Auth] User successfully logged out.");
                showToast('Erfolgreich abgemeldet!', 'info');
            } catch (error) {
                console.error("[Auth] Firebase Logout Error:", error.message);
                showToast(`Fehler beim Abmelden: ${error.message}`, 'error');
            }
        });

        // Upload Model Button Handler
        uploadModelButton.addEventListener('click', (e) => {
            console.log("[UI Event] Upload Model button clicked.");
            if (!auth.currentUser) {
                lastFocusedElement = e.currentTarget;
                authModal.showModal();
                showToast('Bitte melden Sie sich an, um Modelle hochzuladen.', 'info'); 
            } else {
                lastFocusedElement = e.currentTarget;
                hideMessage(uploadErrorMessage);
                hideMessage(uploadSuccessMessage);
                modelTitleInput.value = ''; 
                modelDescriptionInput.value = ''; 
                modelCategoryInput.value = ''; 
                projectJsonInput.value = ''; 
                visibilitySelect.value = 'public'; 
                
                hideMessage(jsonErrorMessage); 
                uploadSubmitButton.disabled = true; // Keep disabled until file is processed and fields are filled
                
                uploadModal.showModal();
                projectJsonInput.focus(); // Set focus to the file input
            }
        });

        uploadModal.addEventListener('close', () => {
            console.log("[UI Event] Upload modal closed.");
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });

        // Event Listener for "Projektdatei auswählen" input change
        projectJsonInput.addEventListener('change', () => {
            console.log("[Upload] Project JSON file selected.");
            const file = projectJsonInput.files[0];
            if (!file) {
                showToast('Bitte wählen Sie eine Projektdatei aus.', 'error');
                uploadSubmitButton.disabled = true;
                currentProjectJsonData = null;
                currentProjectJsonFile = null;
                console.log("[Upload] No file selected.");
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const parsedJson = JSON.parse(event.target.result);
                    currentProjectJsonData = { projectData: {} }; // Initialize projectData object
                    currentProjectJsonFile = file; 
                    console.log("[Upload] JSON file parsed successfully.");

                    // Determine actual voxel and settings data source
                    let actualVoxels = parsedJson.projectData?.voxels || parsedJson.voxels;
                    let actualSettings = parsedJson.projectData?.settings || parsedJson.settings;

                    // Check if voxel data is present after attempting to find it
                    if (!actualVoxels || Object.keys(actualVoxels).length === 0) {
                        showToast('Die hochgeladene Datei enthält keine Voxeldaten. Bitte laden Sie ein gültiges Modell hoch.', 'error');
                        uploadSubmitButton.disabled = true;
                        currentProjectJsonData = null;
                        currentProjectJsonFile = null;
                        console.warn("[Upload] No voxel data found in the uploaded JSON.");
                        return;
                    }

                    // Normalize currentProjectJsonData to always have a projectData object
                    currentProjectJsonData.projectData.voxels = actualVoxels;
                    currentProjectJsonData.projectData.settings = actualSettings;
                    console.log("[Upload] Normalized projectData structure.");

                    // Convert array-based voxel data to object-based schema
                    if (Array.isArray(currentProjectJsonData.projectData.voxels)) {
                        console.log("[Upload] Converting array-based voxels to object-based.");
                        const convertedVoxels = {};
                        currentProjectJsonData.projectData.voxels.forEach(voxel => {
                            if (voxel.x !== undefined && voxel.y !== undefined && voxel.z !== undefined && voxel.color) {
                                convertedVoxels[`${voxel.x},${voxel.y},${voxel.z}`] = voxel.color;
                            }
                        });
                        currentProjectJsonData.projectData.voxels = convertedVoxels;
                        console.log("[Upload] Voxel data conversion complete.");
                    }
                    
                    // Prefill fields from the original parsedJson (which might have fields at root)
                    // Use filename as default title if not present in JSON
                    modelTitleInput.value = parsedJson.title || file.name.replace(/\.json$/i, '', '.json'); 
                    modelDescriptionInput.value = parsedJson.description || '';
                    console.log("[Upload] Prefilled title and description.");

                    // Set category from JSON, if valid, otherwise default
                    if (parsedJson.category && predefinedCategories.includes(parsedJson.category)) {
                        modelCategoryInput.value = parsedJson.category;
                        console.log(`[Upload] Set category to: ${parsedJson.category}`);
                    } else {
                        modelCategoryInput.value = 'Allgemein'; 
                        console.log("[Upload] Defaulted category to 'Allgemein'.");
                    }

                    if (parsedJson.visibility) {
                        const optionExists = Array.from(visibilitySelect.options).some(option => option.value === parsedJson.visibility);
                        if (optionExists) {
                            visibilitySelect.value = parsedJson.visibility;
                            console.log(`[Upload] Set visibility to: ${parsedJson.visibility}`);
                        } else {
                            visibilitySelect.value = 'public'; 
                            console.log("[Upload] Invalid visibility from JSON, defaulted to 'public'.");
                        }
                    } else {
                        visibilitySelect.value = 'public'; 
                        console.log("[Upload] No visibility from JSON, defaulted to 'public'.");
                    }

                    hideMessage(jsonErrorMessage);
                    // Re-evaluate upload button state
                    if (modelTitleInput.value.trim() !== '' && modelCategoryInput.value.trim() !== '' && currentProjectJsonData) {
                        uploadSubmitButton.disabled = false;
                        console.log("[Upload] Upload button enabled.");
                    } else {
                        uploadSubmitButton.disabled = true;
                        console.log("[Upload] Upload button disabled (missing title, category, or project data).");
                    }
                    showToast('Projektdatei geladen! Details ausfüllen.', 'success');

                } catch (error) {
                    console.error("[Upload] Fehler beim Parsen des Projekt-JSON:", error);
                    showToast('Fehler beim Lesen der Datei. Ungültiges JSON.', 'error');
                    modelTitleInput.value = '';
                    modelDescriptionInput.value = '';
                    modelCategoryInput.value = '';
                    visibilitySelect.value = 'public';
                    uploadSubmitButton.disabled = true;
                    currentProjectJsonData = null;
                    currentProjectJsonFile = null;
                }
            };
            reader.onerror = () => {
                console.error("[Upload] FileReader error.");
                showToast('Fehler beim Lesen der Datei.', 'error');
                uploadSubmitButton.disabled = true;
                currentProjectJsonData = null;
                currentProjectJsonFile = null;
            };
            reader.readAsText(file);
        });

        // Enable/disable upload button based on title and category input
        modelTitleInput.addEventListener('input', () => {
            console.log("[Upload Form] Title input changed.");
            if (modelTitleInput.value.trim() !== '' && modelCategoryInput.value.trim() !== '' && currentProjectJsonData) {
                uploadSubmitButton.disabled = false;
            } else {
                uploadSubmitButton.disabled = true;
            }
        });

        modelCategoryInput.addEventListener('change', () => {
            console.log("[Upload Form] Category input changed.");
            if (modelTitleInput.value.trim() !== '' && modelCategoryInput.value.trim() !== '' && currentProjectJsonData) {
                uploadSubmitButton.disabled = false;
            } else {
                uploadSubmitButton.disabled = true;
            }
        });


        // Handle Model Upload
        uploadSubmitButton.addEventListener('click', async (e) => {
            e.preventDefault();
            console.log("[Upload] Upload submit button clicked.");
            hideMessage(uploadErrorMessage);
            hideMessage(uploadSuccessMessage);

            const title = modelTitleInput.value.trim();
            const description = modelDescriptionInput.value.trim();
            const category = modelCategoryInput.value.trim(); 
            const visibility = visibilitySelect.value; 

            if (!currentProjectJsonData || !currentProjectJsonFile) {
                showToast('Bitte laden Sie zuerst die Projektdatei.', 'error');
                console.warn("[Upload] Attempted upload without project data.");
                return;
            }

            if (!auth.currentUser) {
                showToast('Sie müssen angemeldet sein, um ein Modell hochzuladen.', 'error');
                console.warn("[Upload] Attempted upload while not logged in.");
                return;
            }

            // Category validation
            if (!predefinedCategories.includes(category)) {
                showToast('Bitte wählen Sie eine gültige Kategorie aus der Liste aus.', 'error');
                console.warn("[Upload] Invalid category selected:", category);
                return;
            }

            try {
                console.log("[Upload] Attempting to add document to Firestore 'models' collection.");
                await addDoc(collection(db, "models"), { 
                    title: title, 
                    description: description, 
                    category: category, 
                    visibility: visibility, 
                    fileName: currentProjectJsonFile.name, 
                    projectData: currentProjectJsonData.projectData, 
                    uploaderUid: auth.currentUser.uid,
                    uploaderEmail: auth.currentUser.email,
                    uploaderPhotoURL: auth.currentUser.photoURL || null, 
                    timestamp: serverTimestamp(),
                    downloads: 0, 
                    rating: 0,
                    ratingCount: 0,
                    verified: false,
                });

                console.log("[Upload] Model successfully uploaded to Firestore.");
                showToast('Modell erfolgreich hochgeladen!', 'success');
                uploadModal.close(); 
                resetAndFetch(); 
            } catch (error) {
                console.error("[Upload] Modell-Upload-Fehler:", error);
                if (error.code === 'resource-exhausted') {
                    showToast(`Upload-Fehler: Datei zu groß (max. 1 MB).`, 'error');
                } else {
                    showToast(`Upload-Fehler: ${error.message}`, 'error');
                }
                uploadModal.close(); 
            }
        });

        // Function to create a Three.js scene from voxel data for STL export
        function createSceneFromVoxels(voxelsData) {
            console.log("[STL Export] Creating Three.js scene from voxel data.");
            const scene = new THREE.Scene();
            const scaleFactor = 10; // Scale factor for STL export (1 unit in editor = 10 units in STL for cm)
            const material = new THREE.MeshNormalMaterial(); // Simple material for export
            
            // Collect all geometries
            const geometries = [];

            // Calculate bounding box
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            // First pass: Calculate Bounding Box
            for (const key in voxelsData) {
                const parts = key.split(',').map(Number);
                if (parts.length === 3) {
                    const [x, y, z] = parts;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    minZ = Math.min(minZ, z);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                    maxZ = Math.max(maxZ, z);
                }
            }

            // Calculate center point
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            console.log(`[STL Export] Bounding Box: X[${minX},${maxX}], Y[${minY},${maxY}], Z[${minZ},${maxZ}]`);

            // Second pass: Create geometries with correct position
            for (const key in voxelsData) {
                const parts = key.split(',').map(Number);
                if (parts.length === 3) {
                    const [x, y, z] = parts;
                    
                    const geometry = new THREE.BoxGeometry(scaleFactor, scaleFactor, scaleFactor);
                    
                    // Position relative to the center point
                    const posX = (x - centerX) * scaleFactor;
                    const posY = (y - centerY) * scaleFactor;
                    const posZ = (z - centerZ) * scaleFactor;
                    
                    // Create matrix for positioning
                    const matrix = new THREE.Matrix4().makeTranslation(
                        posX + scaleFactor / 2, 
                        posY + scaleFactor / 2, 
                        posZ + scaleFactor / 2
                    );
                    
                    geometry.applyMatrix4(matrix);
                    geometries.push(geometry);
                }
            }

            // Handle empty models
            if (geometries.length === 0) {
                console.error("[STL Export] No voxels found for export. Returning empty scene.");
                return scene; // Return an empty scene
            }

            // Merge geometries
            const mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
            const mesh = new THREE.Mesh(mergedGeometry, material);
            scene.add(mesh);
            console.log("[STL Export] Geometries merged and mesh added to scene.");

            return scene;
        }


        // Download Handler (now for STL)
        async function handleDownload(modelId, modelTitle) {
            console.log(`[Download] Download requested for model ID: ${modelId}, Title: "${modelTitle}"`);
            if (!auth.currentUser) { 
                lastFocusedElement = document.querySelector(`.download-button[data-model-id="${modelId}"]`);
                authModal.showModal();
                showToast('Bitte melden Sie sich an, um Modelle herunterzuladen.', 'info');
                console.log("[Download] User not logged in, showing auth modal.");
                return;
            }

            showToast(`Download von "${modelTitle}" als STL wird vorbereitet...`, 'info');

            try {
                const docRef = doc(db, "models", modelId);
                console.log(`[Download] Fetching model document from Firestore: models/${modelId}`);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const modelData = docSnap.data();
                    const voxelsData = modelData.projectData ? modelData.projectData.voxels : null;

                    console.log("[Download] Model document found. Voxel data presence:", !!voxelsData); 

                    if (voxelsData && Object.keys(voxelsData).length > 0) {
                        console.log("[Download] Voxel data available. Creating Three.js scene for STL export.");
                        const sceneToExport = createSceneFromVoxels(voxelsData);
                        const exporter = new THREE.STLExporter();
                        console.log("[Download] Exporting scene to STL string.");
                        const stlString = exporter.parse(sceneToExport);

                        const blob = new Blob([stlString], { type: 'text/plain' }); // Use 'text/plain' for ASCII STL
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${modelTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.stl`; 
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log(`[Download] STL file "${a.download}" created and triggered download.`);

                        try {
                            console.log(`[Download] Updating download count for model ${modelId}. Current: ${modelData.downloads || 0}`);
                            await updateDoc(docRef, {
                                downloads: (modelData.downloads || 0) + 1
                            });
                            showToast(`"${modelTitle}.stl" erfolgreich heruntergeladen!`, 'success');
                            console.log("[Download] Download count updated successfully.");
                        } catch (updateError) {
                            console.error("[Download] Fehler beim Aktualisieren der Download-Zählung:", updateError);
                            showToast(`STL-Download erfolgreich, aber Fehler beim Aktualisieren des Zählers: ${updateError.message}.`, 'warning');
                        }

                    } else {
                         console.error("[Download] Keine Voxeldaten im Dokument für den STL-Export gefunden.");
                         showToast('Fehler beim Download: Keine Voxeldaten für STL-Export gefunden.', 'error');
                    }

                } else {
                    console.error("[Download] Dokument nicht gefunden für Modell ID:", modelId);
                    showToast('Fehler beim Download: Modell nicht gefunden.', 'error');
                }
            } catch (error) {
                console.error("[Download] Fehler beim Herunterladen des Modell-STL:", error);
                showToast(`Fehler beim Download der STL-Datei: ${error.message}`, 'error');
            }
        }

        // Function to open in VoxelShaper
        async function handleOpenOnVoxelShaper(modelId) {
            console.log(`[Open VoxelShaper] Opening model ID ${modelId} in VoxelShaper.`);
            showToast(`Modell ${modelId} wird in VoxelShaper geöffnet!`, 'info');

            try {
                const docRef = doc(db, "models", modelId);
                console.log(`[Open VoxelShaper] Fetching model document from Firestore: models/${modelId}`);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const editorUrl = `https://voxelshaper.com/?modelId=${modelId}`;
                    
                    // Create a temporary anchor element and click it
                    const a = document.createElement('a');
                    a.href = editorUrl;
                    a.target = '_blank'; // Open in a new tab
                    a.rel = 'noopener noreferrer'; // Security best practice for _blank
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a); // Clean up the temporary element

                    console.log(`[Open VoxelShaper] Triggered new tab with URL: ${editorUrl}`);

                } else {
                    console.error("[Open VoxelShaper] Dokument nicht gefunden für Modell ID:", modelId);
                    showToast('Fehler beim Öffnen: Modell nicht gefunden. Es wurde möglicherweise gelöscht oder die ID ist falsch.', 'error');
                }
            } catch (error) {
                console.error("[Open VoxelShaper] Fehler beim Öffnen des Modells in VoxelShaper:", error);
                showToast(`Fehler beim Öffnen des Modells: ${error.message}`, 'error');
            }
        }

        // Admin Function: Verify Model
        async function verifyModel(modelId) {
            console.log(`[Admin Action] Verify model ID: ${modelId}. Current _isAdmin status: ${_isAdmin}`);
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Verifizieren von Modellen.', 'error');
                console.warn("[Admin Action] Unauthorized attempt to verify model.");
                return;
            }
            try {
                const modelRef = doc(db, "models", modelId);
                console.log(`[Admin Action] Updating model ${modelId} to verified: true.`);
                await updateDoc(modelRef, { verified: true });
                showToast('Modell erfolgreich verifiziert!', 'success');
                console.log("[Admin Action] Model verified successfully. Resetting and fetching models.");
                resetAndFetch(); 
            } catch (error) {
                console.error("[Admin Action] Fehler beim Verifizieren des Modells:", error);
                showToast(`Fehler beim Verifizieren des Modells: ${error.message}`, 'error');
            }
        }

        // Admin Function: Revert Verification
        async function revertVerification(modelId) {
            console.log(`[Admin Action] Revert verification for model ID: ${modelId}. Current _isAdmin status: ${_isAdmin}`);
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Rückgängigmachen der Verifizierung.', 'error');
                console.warn("[Admin Action] Unauthorized attempt to revert verification.");
                return;
            }
            try {
                const modelRef = doc(db, "models", modelId);
                console.log(`[Admin Action] Updating model ${modelId} to verified: false.`);
                await updateDoc(modelRef, { verified: false });
                showToast('Verifizierung erfolgreich rückgängig gemacht!', 'success');
                console.log("[Admin Action] Verification reverted successfully. Resetting and fetching models.");
                resetAndFetch(); 
            } catch (error) {
                console.error("[Admin Action] Fehler beim Rückgängigmachen der Verifizierung:", error);
                showToast(`Fehler beim Rückgängigmachen der Verifizierung: ${error.message}`, 'error');
            }
        }

        // Admin Function: Delete Model
        async function deleteModel(modelId) {
            console.log(`[Admin Action] Delete model ID: ${modelId}. Current _isAdmin status: ${_isAdmin}`);
            if (!isAdmin()) {
                showToast('Keine Berechtigung zum Löschen von Modellen.', 'error');
                console.warn("[Admin Action] Unauthorized attempt to delete model.");
                return;
            }
            try {
                console.log(`[Admin Action] Deleting model document from Firestore: models/${modelId}`);
                await deleteDoc(doc(db, "models", modelId));
                showToast('Modell erfolgreich gelöscht!', 'success');
                console.log("[Admin Action] Model deleted successfully from Firestore.");
                // Remove the card from the UI
                const cardToRemove = document.querySelector(`.model-card[data-model-id="${modelId}"]`);
                if (cardToRemove) {
                    const renderer = rendererInstances.get(modelId);
                    if (renderer) {
                        renderer.dispose();
                        rendererInstances.delete(modelId);
                        console.log(`[Admin Action] Disposed Three.js renderer for model ${modelId}.`);
                    }
                    cardToRemove.remove();
                    console.log(`[Admin Action] Model card removed from UI for model ${modelId}.`);
                }
                // If the grid becomes empty or nearly empty, fetch more models
                if (modelsGrid.children.length < MODELS_PER_LOAD / 2) { 
                    console.log("[Admin Action] Grid low on models, fetching more.");
                    fetchModels();
                }
            } catch (error) {
                console.error("[Admin Action] Fehler beim Löschen des Modells:", error);
                showToast(`Fehler beim Löschen des Modells: ${error.message}`, 'error');
            }
        }

        // Function to handle rating a model
        async function rateModel(modelId, newRating) {
            console.log(`[Rating] User attempting to rate model ${modelId} with ${newRating} stars.`);
            if (!currentUser) {
                showToast('Bitte melden Sie sich an, um Modelle zu bewerten.', 'info');
                console.warn("[Rating] Attempted rating while not logged in.");
                return;
            }

            const modelRef = doc(db, "models", modelId);
            const ratingRef = doc(db, `models/${modelId}/ratings`, currentUser.uid); // Corrected model.id to modelId

            try {
                console.log("[Rating] Starting Firestore transaction for rating.");
                await runTransaction(db, async (transaction) => {
                    const modelDoc = await transaction.get(modelRef);
                    const ratingDoc = await transaction.get(ratingRef);

                    if (!modelDoc.exists()) {
                        console.error("[Rating] Model does not exist for rating.");
                        throw "Model does not exist!";
                    }

                    const modelData = modelDoc.data();
                    
                    // Check if the current user is the uploader of this model
                    if (currentUser.uid === modelData.uploaderUid) {
                        console.warn("[Rating] User attempted to rate their own model.");
                        throw new Error('Sie können Ihre eigenen Modelle nicht bewerten.');
                    }

                    let currentRatingSum = modelData.rating || 0;
                    let currentRatingCount = modelData.ratingCount || 0;
                    let oldRating = 0;

                    if (ratingDoc.exists()) {
                        oldRating = ratingDoc.data().rating;
                        // Update existing rating
                        currentRatingSum = currentRatingSum - oldRating + newRating;
                        console.log(`[Rating] Updating existing rating. Old: ${oldRating}, New: ${newRating}. Sum: ${currentRatingSum}`);
                    } else {
                        // Add new rating
                        currentRatingSum = currentRatingSum + newRating;
                        currentRatingCount = currentRatingCount + 1;
                        console.log(`[Rating] Adding new rating. New: ${newRating}. Sum: ${currentRatingSum}, Count: ${currentRatingCount}`);
                    }

                    // Update the model document
                    transaction.update(modelRef, {
                        rating: currentRatingSum,
                        ratingCount: currentRatingCount
                    });
                    console.log("[Rating] Model document updated in transaction.");

                    // Set/update the user's specific rating
                    transaction.set(ratingRef, {
                        rating: newRating,
                        timestamp: serverTimestamp()
                    });
                    console.log("[Rating] User's specific rating updated in transaction.");
                });

                showToast('Bewertung erfolgreich abgegeben!', 'success');
                console.log("[Rating] Transaction successful. Resetting and fetching models.");
                // Re-fetch models to update UI with new average rating
                resetAndFetch();

            } catch (error) {
                console.error("[Rating] Fehler beim Bewerten des Modells:", error);
                showToast(`Fehler beim Bewerten des Modells: ${error.message}`, 'error');
            }
        }


        // Handle in-place editing for title and description
        async function handleInPlaceEdit(modelId, field, newValue, statusElement) {
            console.log(`[In-Place Edit] Attempting to edit model ${modelId}, field '${field}' to '${newValue}'.`);
            if (!currentUser) {
                showToast('Sie müssen angemeldet sein, um Änderungen vorzunehmen.', 'error');
                console.warn("[In-Place Edit] Unauthorized: Not logged in.");
                return;
            }

            // Get the current model data to check uploaderUid
            const modelRef = doc(db, "models", modelId);
            console.log(`[In-Place Edit] Fetching model document for permission check: models/${modelId}`);
            const modelSnap = await getDoc(modelRef);
            if (!modelSnap.exists()) {
                showToast('Modell nicht gefunden.', 'error');
                console.error("[In-Place Edit] Model not found for in-place edit.");
                return;
            }
            const modelData = modelSnap.data();

            // Check if current user is the uploader or an admin
            if (currentUser.uid !== modelData.uploaderUid && !isAdmin()) {
                showToast('Keine Berechtigung zum Bearbeiten dieses Modells.', 'error');
                console.warn(`[In-Place Edit] Unauthorized: User ${currentUser.uid} is not uploader (${modelData.uploaderUid}) and not admin.`);
                // Revert text to original if not authorized
                const element = document.querySelector(`[data-model-id="${modelId}"][data-field="${field}"]`);
                if (element) {
                    element.textContent = modelData[field];
                    console.log(`[In-Place Edit] Reverted text to original for field '${field}'.`);
                }
                return;
            }
            console.log(`[In-Place Edit] User authorized to edit. Uploader: ${currentUser.uid === modelData.uploaderUid}, Admin: ${isAdmin()}`);


            if (statusElement) {
                statusElement.textContent = 'Speichern...';
                statusElement.classList.remove('hidden');
                statusElement.classList.remove('text-success', 'text-error');
                statusElement.classList.add('text-base-content/40');
                console.log("[In-Place Edit] Displaying 'Saving...' status.");
            }

            const updateData = {};
            updateData[field] = newValue;

            try {
                console.log(`[In-Place Edit] Attempting to update Firestore document for model ${modelId}, field '${field}'.`);
                await updateDoc(modelRef, updateData);
                if (statusElement) {
                    statusElement.textContent = 'Gespeichert!';
                    statusElement.classList.remove('text-base-content/40');
                    statusElement.classList.add('text-success');
                }
                showToast(`"${field}" erfolgreich aktualisiert!`, 'success');
                console.log(`[In-Place Edit] Field '${field}' updated successfully.`);
            } catch (error) {
                console.error(`[In-Place Edit] Fehler beim Aktualisieren von "${field}":`, error);
                if (statusElement) {
                    statusElement.textContent = 'Fehler!';
                    statusElement.classList.remove('text-base-content/40');
                    statusElement.classList.add('text-error');
                }
                showToast(`Fehler beim Aktualisieren von "${field}": ${error.message}`, 'error');
            } finally {
                if (statusElement) {
                    setTimeout(() => {
                        statusElement.classList.add('hidden');
                        statusElement.textContent = '';
                        console.log("[In-Place Edit] Hiding status message.");
                    }, 2000); // Hide status after 2 seconds
                }
            }
        }


        // Delete Confirmation Modal Logic
        document.getElementById('confirm-delete-button').addEventListener('click', () => {
            console.log("[UI Event] Confirm Delete button clicked.");
            if (modelIdToDelete) {
                deleteModel(modelIdToDelete);
                document.getElementById('delete-confirm-modal').close();
                modelIdToDelete = null; 
            }
        });

        function showDeleteConfirmationModal(modelId, modelTitle) {
            console.log(`[UI Event] Showing delete confirmation modal for model ID: ${modelId}, Title: "${modelTitle}"`);
            modelIdToDelete = modelId;
            document.getElementById('model-to-delete-title').textContent = modelTitle;
            lastFocusedElement = document.querySelector(`.delete-button[data-model-id="${modelId}"]`);
            document.getElementById('delete-confirm-modal').showModal();
            document.getElementById('confirm-delete-button').focus(); // Focus confirm button
        }

        document.getElementById('delete-confirm-modal').addEventListener('close', () => {
            console.log("[UI Event] Delete confirmation modal closed.");
            if (lastFocusedElement) {
                lastFocusedElement.focus();
                lastFocusedElement = null;
            }
        });


        // Event Listener for Filter Selects
        // categoryFilterSelect.addEventListener('change', () => { // Replaced by category buttons
        //     resetAndFetch(); 
        // });

        sortBy.addEventListener('change', () => {
            console.log("[Filter] Sort by changed. Resetting and fetching models.");
            resetAndFetch(); 
        });

        statusFilterSelect.addEventListener('change', () => {
            console.log("[Filter] Status filter changed. Resetting and fetching models.");
            resetAndFetch();
        });

        // Event Listener for Search Input
        searchInput.addEventListener('keyup', () => {
            console.log("[Search] Search input keyup event. Filtering client-side.");
            // Client-side filtering of already loaded models
            const searchTerm = searchInput.value.toLowerCase().trim();
            const cards = modelsGrid.querySelectorAll('.model-card');
            cards.forEach(card => {
                const title = card.querySelector('.card-title').textContent.toLowerCase();
                const description = card.querySelector('p[data-field="description"]').textContent.toLowerCase(); // More specific selector
                if (title.includes(searchTerm) || description.includes(searchTerm)) {
                    card.style.display = ''; // Show
                } else {
                    card.style.display = 'none'; // Hide
                }
            });
            // If the search term is cleared, re-fetch to ensure all models are visible again
            if (searchTerm === '' && modelsGrid.children.length !== allModelsData.length) {
                console.log("[Search] Search term cleared, re-fetching all models.");
                resetAndFetch();
            }
        });

        // Event Listener for Reset Filters Button
        resetFiltersButton.addEventListener('click', () => {
            console.log("[Filter] Reset Filters button clicked. Resetting all filters and fetching models.");
            manualFilterResetActive = true; // Set flag to prevent updateUI from overriding
            activeCategory = 'all'; // Reset active category
            initializeCategoryOptions(); // Re-render category buttons with 'all' active
            sortBy.value = 'newest-desc';
            statusFilterSelect.value = 'verified'; // Explicitly set to verified
            searchInput.value = ''; // Clear search input
            console.log(`[Filter] After reset button click: statusFilterSelect.value = ${statusFilterSelect.value}, _isAdmin = ${_isAdmin}, manualFilterResetActive = ${manualFilterResetActive}`);
            resetAndFetch();
            // Reset the flag after a short delay to allow fetchModels to use the correct filter
            setTimeout(() => {
                manualFilterResetActive = false;
                console.log("[Filter] manualFilterResetActive set to false after delay.");
            }, 500); // Small delay
        });


        // Event Listeners for Navbar Buttons
        navDiscoverButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Entdecken' button clicked.");
            sortBy.value = 'newest-desc'; // Default sort for "Entdecken"
            activeCategory = 'all'; // Set active category
            initializeCategoryOptions(); // Update category buttons
            statusFilterSelect.value = 'verified'; // Always set to verified for general navigation
            resetAndFetch();
        });

        navPopularButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Beliebt' button clicked.");
            sortBy.value = 'popular-desc'; // Sort by popular for "Beliebt"
            activeCategory = 'all'; // Set active category
            initializeCategoryOptions(); // Update category buttons
            statusFilterSelect.value = 'verified'; // Always set to verified for general navigation
            resetAndFetch();
        });

        navNewButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Neu' button clicked.");
            sortBy.value = 'newest-desc'; // Sort by newest for "Neu" (same as discover, but explicit)
            activeCategory = 'all'; // Set active category
            initializeCategoryOptions(); // Update category buttons
            statusFilterSelect.value = 'verified'; // Always set to verified for general navigation
            resetAndFetch();
        });

        navCategoriesButton.addEventListener('click', (e) => {
            e.preventDefault();
            console.log("[Navbar] 'Kategorien' button clicked.");
            // This button could simply reset filters to "Allgemein" and "Neueste"
            // For now, let's make it reset to default category view.
            sortBy.value = 'newest-desc';
            activeCategory = 'all'; // Set active category
            initializeCategoryOptions(); // Update category buttons
            statusFilterSelect.value = 'verified'; // Always set to verified for general navigation
            resetAndFetch();
        });


        // Initial loading of models when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log("[DOMContentLoaded] Page fully loaded.");
            const savedTheme = localStorage.getItem('theme');
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            let initialTheme = 'dark'; 
            if (savedTheme) {
                initialTheme = savedTheme;
            } else if (!systemPrefersDark) { 
                initialTheme = 'light';
            }

            htmlElement.setAttribute('data-theme', initialTheme);
            themeToggle.checked = (initialTheme === 'dark'); 
            console.log(`[DOMContentLoaded] Initial theme set to: ${initialTheme}`);

            initializeCategoryOptions(); // Initialize category buttons on load
            console.log("[DOMContentLoaded] Category options initialized.");

            setupInfiniteScrollObserver();
            console.log("[DOMContentLoaded] Infinite scroll observer setup completed.");
        });

        // Theme Toggle Event Listener
        themeToggle.addEventListener('change', () => {
            const isChecked = themeToggle.checked;
            const newTheme = isChecked ? 'dark' : 'light';
            htmlElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            console.log(`[Theme Toggle] Theme changed to: ${newTheme}. Resetting and fetching models.`);

            resetAndFetch(); 
        });

    </script>
</body>
</html>
