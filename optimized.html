<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Voxel-Editor – Verbesserter Export & Rendering</title>
<style>
body{margin:0;overflow:hidden;font-family:sans-serif;display:flex;flex-direction:column;height:100vh;background:#282c34;color:#e0e0e0}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode, #current-control-mode{
    font-weight:700;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#current-mode{ color:#81c784; } /* Green for Add */
#current-control-mode { color: #ffe082; } /* Amber for control mode */

#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box; /* Ensure border (if added back) doesn't push content out */
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    display: none;
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Style for the new terrain controls panel */
#terrainControlsPanel {
    background: #3a3f47;
    padding: 14px;
    margin-top: 10px;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    align-items: center;
    border: 1px solid #4a4f57;
    transition: all 0.3s ease-in-out;
}

/* Mobile Controls CSS */
#mobile-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: space-between;
    padding: 15px;
    box-sizing: border-box;
    pointer-events: none; /* Allow canvas interaction through controls */
    z-index: 50; /* Above info-box but below modals */
}

#mobile-controls .d-pad, #mobile-controls .action-buttons {
    display: grid;
    gap: 8px;
    pointer-events: auto; /* Re-enable pointer events for buttons */
}

#mobile-controls .d-pad {
    grid-template-columns: repeat(3, 60px);
    grid-template-rows: repeat(3, 60px);
    width: 188px; /* 3*60 + 2*4 (gap) */
    height: 188px; /* 3*60 + 2*4 (gap) */
}

#mobile-controls .action-buttons {
    grid-template-columns: repeat(2, 70px);
    grid-template-rows: repeat(3, 60px);
    width: 148px; /* 2*70 + 1*8 */
    height: 188px; /* 3*60 + 2*4 */
}

#mobile-controls button {
    background-color: rgba(85, 92, 102, 0.8); /* Semi-transparent */
    color: #e0e0e0;
    border: 1px solid #4a4f57;
    border-radius: 8px;
    font-size: 1.1em;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none; /* Prevent text selection on tap */
    -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
}

#mobile-controls button:active {
    background-color: rgba(106, 114, 127, 0.9); /* Darker on active */
    transform: scale(0.98);
}

/* D-pad grid positioning */
#move-forward { grid-area: 1 / 2 / 2 / 3; }
#move-left    { grid-area: 2 / 1 / 3 / 2; }
#move-backward{ grid-area: 2 / 2 / 3 / 3; }
#move-right   { grid-area: 2 / 3 / 3 / 4; }
#move-up      { grid-area: 1 / 3 / 2 / 4; /* Top Right */ }
#move-down    { grid-area: 3 / 3 / 4 / 4; /* Bottom Right */ }

/* Voxel action buttons */
#add-voxel { grid-area: 1 / 1 / 2 / 2; }
#delete-voxel { grid-area: 2 / 1 / 3 / 2; }
#draw-voxel { grid-area: 3 / 1 / 4 / 2; }

/* Camera rotation area - a hidden div that covers the right side of the screen */
#mobile-camera-area {
    position: absolute;
    top: 0;
    right: 0;
    width: 50%; /* Right half of the screen */
    height: 100%;
    pointer-events: auto; /* Enable touch events */
    z-index: 1; /* Below other mobile controls but above canvas */
    /* background-color: rgba(255,0,0,0.1); /* For debugging touch area */ */
}

/* Control mode toggle button specific styling for mobile */
#toggleControlModeBtn {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 100;
    padding: 10px 15px;
    font-size: 0.9em;
    background-color: rgba(68, 72, 79, 0.8);
    border-radius: 5px;
    cursor: pointer;
    border: 1px solid #4a4f57;
    color: #e0e0e0;
}
#toggleControlModeBtn:hover {
    background-color: rgba(85, 92, 102, 0.9);
}

/* Responsive adjustments for smaller screens (e.g., mobile phones) */
@media (max-width: 768px) {
    #controls {
        padding: 8px; /* Reduced padding */
        gap: 6px; /* Reduced gap */
        justify-content: flex-start; /* Align items to start for better wrapping */
    }

    #controls button, #controls label {
        padding: 6px 12px; /* Reduced button padding */
        font-size: 0.9em; /* Smaller font size */
    }

    #grid-size-slider {
        width: 100px; /* Smaller slider width */
    }

    #current-mode, #current-control-mode {
        min-width: unset; /* Remove fixed width */
        max-width: unset; /* Remove fixed width */
        text-align: left; /* Allow natural text alignment */
        flex-basis: 100%; /* Take full width on a new line if needed */
        order: -1; /* Move to the top of the controls on mobile */
        margin-bottom: 5px;
    }

    /* Adjust specific elements if they still cause overflow */
    #fly-speed-slider {
        width: 80px; /* Even smaller for fly speed */
    }
}


</style>
</head>
<body>
<div id="controls">
    <label for="grid-size-slider">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="90" value="10">
    <span id="grid-size-display">10×10×10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff">
    <div id="color-preset-1" class="color-preset-box"></div>
    <div id="color-preset-2" class="color-preset-box"></div>
    <div id="color-preset-3" class="color-preset-box"></div>

    <button id="modeToggle">Modus wechseln</button><span id="current-mode">Modus: Hinzufügen</span>
    <button id="clearBtn">Alles löschen</button>
    <button id="fillLevelBtn">Ebene füllen</button>
    <button id="saveBtn">Projekt speichern</button>
    <button id="loadBtn">Projekt laden</button>
    <button id="exportStlBtn">STL Export</button>

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="2.0" step="0.01" value="0.1">
    <span id="fly-speed-display">0.10</span>
    
    <button id="toggleTerrainControlsBtn">Gelände-Optionen</button>
    <button id="helpToggleBtn">Hilfe</button>
    <button id="toggleControlModeBtn">Desktop / Mobil</button><span id="current-control-mode">Steuerung: Desktop</span>
</div>

<div id="terrainControlsPanel" style="display:none;">
    <button id="generateTerrainBtn">Gelände generieren</button>
    <label for="terrain-height-scale">Höhe:</label>
    <input type="number" id="terrain-height-scale" value="10" min="1" step="1">
    <label for="terrain-frequency">Frequenz:</label>
    <input type="number" id="terrain-frequency" value="0.05" min="0.001" max="0.5" step="0.001">
    <label for="terrain-octaves">Oktaven:</label>
    <input type="number" id="terrain-octaves" value="4" min="1" max="10" step="1">
    <label for="terrain-lacunarity">Lacunarity:</label>
    <input type="number" id="terrain-lacunarity" value="2.0" min="1.0" max="4.0" step="0.1">
    <label for="terrain-gain">Gain:</label>
    <input type="number" id="terrain-gain" value="0.5" min="0.1" max="1.0" step="0.01">
    <label for="terrain-seed">Seed:</label>
    <input type="text" id="terrain-seed" placeholder="Zahl oder Text">
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    </div>
    <input type="file" id="fileInput" accept=".json">

    <div id="mobile-controls" style="display: none;">
        <div class="d-pad">
            <button id="move-up-btn">⬆︎</button>
            <button id="move-left-btn">⬅︎</button>
            <button id="move-backward-btn">⬇︎</button>
            <button id="move-right-btn">⮕</button>
            <button id="move-forward-btn">⬆︎⬆︎</button>
            <button id="move-down-btn">⬇︎⬇︎</button>
        </div>
        <div class="action-buttons">
            <button id="add-voxel-btn">Hinzufügen</button>
            <button id="delete-voxel-btn">Löschen</button>
            <button id="draw-voxel-btn">Zeichnen</button>
        </div>
        <div id="mobile-camera-area"></div>
    </div>
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt löschen</h3>
        <p>Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>

<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;

/* ---------- globale Variablen ---------- */
let scene, cam, ren, gridHelper, boxHelper;
let euler; // Declare euler globally
const voxels = new Map(); // Stores { color: hex_color } for each voxel, not the mesh
let cvs;
let containerDiv; // Reference to the container div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt für aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse für Alt+Mausrad
let currentShiftDragLevel = null; // Speichert die Ebene für den aktuellen Shift-Drag-Vorgang
// Lade die Farbe aus dem Local Storage oder nutze Weiß als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = localStorage.getItem('moveSpeed') || 0.1;
// Lade die Gittergröße aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;

// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgrün (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen für Lichter, die Schatten werfen, um sie später anpassen zu können
let mainDirectionalLight;

// Globale Variablen für Dragging-Status
let isShiftDragging = false;
let isControlDragging = false;
let rotate = false; // Moved to global as it's used across handlers

// Performance optimization: Single mesh for all voxels
let voxelGeometry;
let voxelMesh;
let meshMaterial; // Material for the combined mesh

// Modus-Enum
const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen'
};
let currentMode = Modes.ADD; // Standardmodus

// Undo/Redo History
const history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// Global terrain parameters (can be adjusted by UI)
let terrainHeightScale = 10;
let terrainFrequency = 0.05;
let terrainOctaves = 4;
let terrainLacunarity = 2.0;
let terrainGain = 0.5;
let terrainSeed = ''; // Empty string means random seed
let hasUserTypedSeed = false; // Flag to track if user has manually set the seed
// Global instance of the noise generator
let noise2D;

/* --- Control Mode Variables --- */
const ControlModes = {
    DESKTOP: 'Desktop',
    MOBILE: 'Mobil'
};
let currentControlMode;
let keys = {}; // Global keys object for movement
let rotSpeed = 0.002; // Rotation speed for desktop
let mobileTouchStartX = 0;
let mobileTouchStartY = 0;
let mobileIsDraggingCamera = false;

// Pinch zoom variables
let initialPinchDistance = 0;
let isPinching = false;
let pinchZoomSpeed = 0.05; // Adjust this value to control zoom sensitivity


/* ---------- Initialisierung ---------- */
window.onload = () => {
    containerDiv = document.getElementById('container'); // Get reference to the container div
    cvs = document.getElementById('voxelCanvas');
    
    // Make sure THREE is defined here before using it
    if (typeof THREE === 'undefined') {
        console.error("THREE ist nicht definiert. Es gab ein Problem beim Laden der Three.js-Bibliothek. Überprüfen Sie die CDN-Links oder Ihre Internetverbindung.");
        alert("Fehler: Die Kern-3D-Bibliothek konnte nicht geladen werden. Bitte versuchen Sie es erneut oder überprüfen Sie Ihre Internetverbindung.");
        return; // Stop execution if THREE is not available
    }
    // Also check for BufferGeometryUtils and STLExporter
    if (typeof THREE.BufferGeometryUtils === 'undefined') {
        console.warn("WARNUNG: THREE.BufferGeometryUtils ist nicht definiert. Der STL Export könnte fehlschlagen, wenn diese Utility benötigt wird.");
    }
    if (typeof THREE.STLExporter === 'undefined') {
        console.warn("WARNUNG: THREE.STLExporter ist nicht definiert. Der STL Export wird fehlschlagen.");
    }
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);
    cam = new THREE.PerspectiveCamera(75, containerDiv.clientWidth / containerDiv.clientHeight, 0.1, 1000);
    // Kameraposition an die Gittergröße anpassen
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(window.devicePixelRatio);
    ren.shadowMap.enabled = true;
    ren.shadowMap.type = THREE.PCFSoftShadowMap; // Weichere Schatten
    /* Licht */
    // Verbesserte Beleuchtung, Intensität reduziert
    scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444, 0.3)); // Himmel- und Bodenlicht, Intensität 0.3
    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.7); // Intensität reduziert auf 0.7
    mainDirectionalLight.position.set(5, 10, 7).normalize().multiplyScalar(50);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 1024;
    mainDirectionalLight.shadow.mapSize.height = 1024;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    const d = GRID * VS * 0.7;
    mainDirectionalLight.shadow.camera.left = -d;
    mainDirectionalLight.shadow.camera.right = d;
    mainDirectionalLight.shadow.camera.top = d;
    mainDirectionalLight.shadow.camera.bottom = -d;
    mainDirectionalLight.shadow.camera.updateProjectionMatrix();
    scene.add(mainDirectionalLight);
    const d2 = new THREE.DirectionalLight(0xffffff, 0.15);
    d2.position.set(-5, -5, -7).normalize();
    scene.add(d2); // Intensität reduziert auf 0.15

    // Initialize voxel rendering components
    meshMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true, // Enable vertex colors to render different voxel colors
        roughness: 0.9,
        metalness: 0.0
    });
    voxelGeometry = new THREE.BufferGeometry(); // Start with an empty geometry
    voxelMesh = new THREE.Mesh(voxelGeometry, meshMaterial);
    voxelMesh.castShadow = true;
    voxelMesh.receiveShadow = true;
    scene.add(voxelMesh);
    updateVoxelGeometry(); // Initial empty geometry

    rebuildHelpers(); // Erstellt Grid und Box initial
    window.addEventListener('resize', onResize);
    onResize(); // Initial call to set size
    updateGridHelperPosition();
    /* Steuerung */
    euler = new THREE.Euler().setFromQuaternion(cam.quaternion, 'YXZ'); // Initialize euler here

    const setModeDisplay = () => {
        const m = document.getElementById('current-mode');
        m.textContent = `Modus: ${currentMode}`;
        let borderColor;
        switch (currentMode) {
            case Modes.ADD:
                m.style.color = '#81c784'; // Green
                borderColor = '#81c784';
                break;
            case Modes.DELETE:
                m.style.color = '#ef5350'; // Red
                borderColor = '#ef5350';
                break;
            case Modes.DRAW:
                m.style.color = '#ffa726'; // Orange
                borderColor = '#ffa726';
                break;
        }
        // Apply the border color to the container div
        if (containerDiv) { // Ensure containerDiv is defined
            containerDiv.style.border = `2px solid ${borderColor}`; // 2px solid border with dynamic color
        }
    };
    setModeDisplay();
    document.getElementById('modeToggle').onclick = () => {
        cycleMode();
        setModeDisplay();
    };

    // MODAL-HANDLING FÜR "ALLES LÖSCHEN"
    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').onclick = () => {
        clearConfirmationModal.style.display = 'flex'; // Show modal
    };

    document.getElementById('saveAndClearBtn').onclick = () => {
        saveJSON(); // Save first
        clearAll(); // Then clear
        clearConfirmationModal.style.display = 'none'; // Hide modal
    };

    document.getElementById('clearWithoutSaveBtn').onclick = () => {
        clearAll(); // Clear directly
        clearConfirmationModal.style.display = 'none'; // Hide modal
    };

    document.getElementById('cancelClearBtn').onclick = () => {
        clearConfirmationModal.style.display = 'none'; // Hide modal
    };
    // ENDE MODAL-HANDLING

    document.getElementById('fillLevelBtn').onclick = fillActiveLevel;
    document.getElementById('saveBtn').onclick = saveJSON;
    document.getElementById('loadBtn').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('fileInput').onchange = loadJSON;
    document.getElementById('exportStlBtn').onclick = exportSTL;

    // Terrain Generation Button Logic
    document.getElementById('generateTerrainBtn').onclick = () => {
        // Warning if scene is not empty
        if (voxels.size > 0) {
            const confirmGenerate = confirm("Das Generieren von Gelände wird alle vorhandenen Würfel löschen. Möchten Sie fortfahren?");
            if (!confirmGenerate) {
                return; // User cancelled
            }
        }

        const seedInput = document.getElementById('terrain-seed');

        // If the user hasn't manually typed a seed OR if they typed and then cleared it
        if (!hasUserTypedSeed || seedInput.value === '') {
            terrainSeed = Date.now().toString() + Math.random().toString(36).substring(2, 15);
            seedInput.value = terrainSeed; // Display the new random seed
            hasUserTypedSeed = false; // Reset the flag, as this is now an auto-generated seed
        } else {
            // User has manually typed and the field is not empty, so use their custom seed.
            // terrainSeed is already updated by the oninput handler.
        }
        generateTerrain();
    };

    // Gittergröße Slider Event Listener
    const gridSizeSlider = document.getElementById('grid-size-slider');
    const gridSizeDisplay = document.getElementById('grid-size-display');
    gridSizeSlider.value = GRID;
    gridSizeDisplay.textContent = `${GRID}×${GRID}×${GRID}`;
    gridSizeSlider.oninput = (e) => {
        let newGridSize = parseInt(e.target.value, 10);

        // Calculate max coordinate among existing voxels
        let maxCoord = 0;
        voxels.forEach((data, k) => {
            const [x, y, z] = k.split(',').map(Number);
            maxCoord = Math.max(maxCoord, x, y, z);
        });

        const minPossibleGridSize = Math.max(5, maxCoord + 1); // Grid must be at least 5

        if (newGridSize < minPossibleGridSize) {
            newGridSize = minPossibleGridSize;
            // Update the slider value to clamp it visually
            gridSizeSlider.value = newGridSize;
        }

        if (newGridSize !== GRID) {
            const oldGrid = GRID;
            const oldVoxelsState = [...voxels.entries()].map(([id, data]) => {
                const parts = id.split(',').map(Number);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            GRID = newGridSize;
            gridSizeDisplay.textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            // No need to remove voxels explicitly as newGridSize is clamped to contain all existing ones.

            // Add to history
            const newVoxelsState = [...voxels.entries()].map(([id, data]) => {
                const parts = id.split(',').map(Number);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            addCommand('resizeGrid', null, null, null, null, null, oldVoxelsState, newVoxelsState, { oldGrid: oldGrid, newGrid: GRID });

            // Update rendering and camera
            updateVoxelGeometry();
            rebuildHelpers();
            updateGridHelperPosition();

            // Adjust camera position and lookAt relative to the new grid size
            cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
            cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
            const d_shadow = GRID * VS * 0.7;
            mainDirectionalLight.shadow.camera.left = -d_shadow;
            mainDirectionalLight.shadow.camera.right = d_shadow;
            mainDirectionalLight.shadow.camera.top = d_shadow;
            mainDirectionalLight.shadow.camera.bottom = -d_shadow;
            mainDirectionalLight.shadow.camera.updateProjectionMatrix();
        }
    };

    // Farbauswahl Event Listener
    const colorPicker = document.getElementById('color-picker');
    colorPicker.value = currentColor;
    colorPicker.oninput = (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        // Update the active preset color if one is active
        if (activePresetIndex !== -1) {
            presetColors[activePresetIndex] = currentColor;
            document.getElementById(`color-preset-${activePresetIndex + 1}`).style.backgroundColor = currentColor;
            localStorage.setItem(`voxelPresetColor${activePresetIndex + 1}`, currentColor);
        }
    };

    // Initialize preset color boxes and set initial active preset
    for (let i = 1; i <= 3; i++) {
        const presetBox = document.getElementById(`color-preset-${i}`);
        presetBox.style.backgroundColor = presetColors[i - 1]; // Set initial color
        presetBox.onclick = () => {
            setActivePreset(i - 1); // Set this preset as active
        };
        // Allow changing preset colors with the color picker context menu or double click
        presetBox.oncontextmenu = (e) => {
            e.preventDefault(); // Prevent default right-click menu
            // Temporarily set the color picker to the preset color's value for editing
            colorPicker.value = presetColors[i - 1];
            colorPicker.click(); // Open the color picker
            // When the color picker changes, its oninput handler will save the new color.
            // We need to specifically update the preset color too.
            const tempInputHandler = (event) => {
                presetColors[i - 1] = event.target.value;
                presetBox.style.backgroundColor = presetColors[i - 1];
                localStorage.setItem(`voxelPresetColor${i}`, presetColors[i - 1]);
                colorPicker.removeEventListener('input', tempInputHandler); // Clean up
                // After changing a preset, make sure the global currentColor and picker reflect it
                currentColor = presetColors[i - 1];
                colorPicker.value = currentColor;
                localStorage.setItem('voxelEditorColor', currentColor);
            };
            colorPicker.addEventListener('input', tempInputHandler);
        };
        presetBoxes.push(presetBox);
    }

    // Set the initial current color based on local storage, and then activate the corresponding preset if it matches.
    // This ensures the correct color is active if the user previously selected a preset and it was saved.
    const savedColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
    let matchedPreset = false;
    for(let i = 0; i < presetColors.length; i++) {
        // Compare hex codes (normalize to uppercase if needed for consistency)
        if (presetColors[i].toUpperCase() === savedColor.toUpperCase()) {
            setActivePreset(i);
            matchedPreset = true;
            break;
        }
    }
    if (!matchedPreset) {
        // If the saved color doesn't match any preset, ensure no preset is marked active.
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    }
    colorPicker.value = savedColor;
    currentColor = savedColor;


    // Help Toggle Button and Local Storage
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');

    // Load initial visibility state from Local Storage
    // Default to 'false' (hidden) if not found in Local Storage
    const helpVisible = localStorage.getItem('voxelEditorHelpVisible');
    if (helpVisible === 'true') {
        infoBox.style.display = 'block';
    } else {
        infoBox.style.display = 'none';
    }

    helpToggleBtn.onclick = () => {
        if (infoBox.style.display === 'none') {
            infoBox.style.display = 'block';
            localStorage.setItem('voxelEditorHelpVisible', 'true');
        } else {
            infoBox.style.display = 'none';
            localStorage.setItem('voxelEditorHelpVisible', 'false');
        }
    };

    // Fly Speed Slider
    const flySpeedSlider = document.getElementById('fly-speed-slider');
    const flySpeedDisplay = document.getElementById('fly-speed-display');
    // Load initial fly speed from local storage
    moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
    flySpeedSlider.value = moveSpeed;
    flySpeedDisplay.textContent = moveSpeed.toFixed(2);
    flySpeedSlider.oninput = (e) => {
        moveSpeed = parseFloat(e.target.value);
        flySpeedDisplay.textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed.toString()); // Save to local storage
    };

    // Terrain Parameters Inputs
    // These consts are local to window.onload. The generateTerrain function will use the global variables directly.
    const terrainHeightScaleInput = document.getElementById('terrain-height-scale');
    const terrainFrequencyInput = document.getElementById('terrain-frequency');
    const terrainOctavesInput = document.getElementById('terrain-octaves');
    const terrainLacunarityInput = document.getElementById('terrain-lacunarity');
    const terrainGainInput = document.getElementById('terrain-gain');
    const terrainSeedInput = document.getElementById('terrain-seed'); // Still need this to get value initially

    terrainHeightScaleInput.value = terrainHeightScale;
    terrainFrequencyInput.value = terrainFrequency;
    terrainOctavesInput.value = terrainOctaves;
    terrainLacunarityInput.value = terrainLacunarity;
    terrainGainInput.value = terrainGain;
    terrainSeedInput.value = terrainSeed;

    // Add oninput listeners for terrain parameters to update global variables
    terrainHeightScaleInput.oninput = (e) => terrainHeightScale = parseFloat(e.target.value);
    terrainFrequencyInput.oninput = (e) => terrainFrequency = parseFloat(e.target.value);
    terrainOctavesInput.oninput = (e) => terrainOctaves = parseInt(e.target.value, 10);
    terrainLacunarityInput.oninput = (e) => terrainLacunarity = parseFloat(e.target.value);
    terrainGainInput.oninput = (e) => terrainGain = parseFloat(e.target.value);
    terrainSeedInput.oninput = (e) => {
        terrainSeed = e.target.value;
        hasUserTypedSeed = (e.target.value !== ''); // Set flag if user types anything
    };

    // Initialize noise2D globally
    // Check if seedrandom is defined before trying to use it for ValueNoise2D
    if (typeof seedrandom === 'undefined') {
        console.error("Error: seedrandom library is not loaded. Terrain generation may not work as expected.");
        alert("Error: seedrandom library could not be loaded. Please check your internet connection or try refreshing the page. Terrain generation feature might not work.");
        // If seedrandom is crucial and failing, you might want to disable the terrain generation button.
        // document.getElementById('generateTerrainBtn').disabled = true;
        // Or provide a non-seeded fallback:
        noise2D = new (class { // Anonymous class for a basic Math.random-based noise
            constructor() {
                this.p = Array.from({length: 256}, (_, i) => i);
                for(let i=0; i<256; i++) this.p[i+256] = this.p[i];
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) { return (this.p[hash & 0xFF] / 255.0) * 2 - 1; } // Simplified gradient for value noise
            noise(x, y) {
                let X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                let u = this.fade(x), v = this.fade(y);

                let A = this.p[X] + Y, AA = this.p[A], AB = this.p[A + 1];
                
                // Using values at corners (0,0), (1,0), (0,1), (1,1)
                const val00 = this.grad(AA, x, y);
                const val10 = this.grad(this.p[X + 1] + Y, x - 1, y);
                const val01 = this.grad(AB, x, y - 1);
                const val11 = this.grad(this.p[X + 1] + Y + 1, x - 1, y - 1);

                let x1 = this.lerp(u, val00, val10);
                let x2 = this.lerp(u, val01, val11);

                return this.lerp(v, x1, x2);
            }
            octaveNoise(x, y, octaves, frequency, lacunarity, gain) {
                let total = 0, maxVal = 0, amplitude = 1;
                for (let i = 0; i < octaves; i++) {
                    total += this.noise(x * frequency, y * frequency) * amplitude;
                    maxVal += amplitude;
                    amplitude *= gain;
                    frequency *= lacunarity;
                }
                return total / maxVal;
            }
        })();
    } else {
        noise2D = new ValueNoise2D(terrainSeed); // Initialized with default (random) seed if terrainSeed is empty
    }


    // Toggle Terrain Controls Panel
    const toggleTerrainControlsBtn = document.getElementById('toggleTerrainControlsBtn');
    const terrainControlsPanel = document.getElementById('terrainControlsPanel');
    toggleTerrainControlsBtn.onclick = () => {
        if (terrainControlsPanel.style.display === 'none') {
            terrainControlsPanel.style.display = 'flex';
        } else {
            terrainControlsPanel.style.display = 'none';
        }
    };

    cvs.oncontextmenu = e => e.preventDefault();

    /* --- Control Mode Implementation --- */
    const isMobileDevice = () => {
        return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth <= 768 && window.innerHeight <= 1024);
    };

    const infoBoxContent = {
        [ControlModes.DESKTOP]: `
            <strong>Steuerung (Desktop)</strong><br>
            Rechte MT gehalten + Maus → Kamera drehen (Fly Mode)<br>
            WASD / E / Q → bewegen<br>
            Linke MT → Voxel hinzuf./löschen/zeichnen<br>
            <strong>Alt + Mausrad → Zeichenebene Y hoch/runter (Gitter folgt)</strong><br>
            <strong>Alt + Shift + Mausrad → Zeichenebene Z hoch/runter (Gitter folgt)</strong><br>
            <strong>Alt + Control + Mausrad → Zeichenebene X hoch/runter (Gitter folgt)</strong><br>
            <strong>Shift + Linke MT gedrückt + Maus ziehen → Voxel Aktion auf aktiver Ebene (Hinzufügen / Löschen / Zeichnen)</strong><br>
            <strong>Control + Linke MT gedrückt + Maus ziehen → Voxel ziehen zum Hinzufügen (Stapeln, nur im Hinzufügen-Modus)</strong><br>
            Mausrad → Kamera Geschwindigkeit anpassen<br>
            <strong>Tab → Modus wechseln (Hinzufügen / Löschen / Zeichnen)</strong><br>
            <strong>1, 2, 3 → Voreingestellte Farbe wählen</strong><br>
            <strong>Strg + Z → Rückgängig (Undo)</strong><br>
            <strong>Strg + Y oder Strg + Shift + Z → Wiederholen (Redo)</strong>
        `,
        [ControlModes.MOBILE]: `
            <strong>Steuerung (Mobil)</strong><br>
            Rechten Bildschirmbereich ziehen → Kamera drehen<br>
            <strong>Zwei Finger kneifen/spreizen → Zoom Kamera</strong><br>
            D-Pad / Pfeile → Bewegen<br>
            'Hinzufügen' Button → Voxel hinzufügen<br>
            'Löschen' Button → Voxel löschen<br>
            'Zeichnen' Button → Voxel zeichnen<br>
            'Modus wechseln' Button → Modus wechseln<br>
            (Mobile Steuerung unterstützt keine Alt/Shift/Control-Modifikatoren, oder Undo/Redo über Gesten. Bitte Desktop-Modus verwenden.)
        `
    };

    const updateInfoBox = () => {
        infoBox.innerHTML = infoBoxContent[currentControlMode];
        // Re-check help visibility setting from localStorage, in case it was toggled while hidden
        const helpVisible = localStorage.getItem('voxelEditorHelpVisible');
        if (helpVisible === 'true' && currentControlMode === ControlModes.DESKTOP) {
            infoBox.style.display = 'block';
        } else {
            infoBox.style.display = 'none'; // Always hide help for mobile, as it's not well-suited for touch
        }
    };

    const mobileActionButtons = {
        add: document.getElementById('add-voxel-btn'),
        delete: document.getElementById('delete-voxel-btn'),
        draw: document.getElementById('draw-voxel-btn')
    };

    const mobileMoveButtons = {
        forward: document.getElementById('move-forward-btn'),
        backward: document.getElementById('move-backward-btn'),
        left: document.getElementById('move-left-btn'),
        right: document.getElementById('move-right-btn'),
        up: document.getElementById('move-up-btn'),
        down: document.getElementById('move-down-btn')
    };

    // Assign data-key attribute for easier management
    mobileMoveButtons.forward.dataset.key = 'KeyW';
    mobileMoveButtons.backward.dataset.key = 'KeyS';
    mobileMoveButtons.left.dataset.key = 'KeyA';
    mobileMoveButtons.right.dataset.key = 'KeyD';
    mobileMoveButtons.up.dataset.key = 'KeyE';
    mobileMoveButtons.down.dataset.key = 'KeyQ';

    const enableDesktopControls = () => {
        currentControlMode = ControlModes.DESKTOP;
        localStorage.setItem('voxelEditorControlMode', ControlModes.DESKTOP);
        document.getElementById('current-control-mode').textContent = `Steuerung: ${ControlModes.DESKTOP}`;
        document.getElementById('mobile-controls').style.display = 'none';
        document.getElementById('toggleControlModeBtn').textContent = 'Mobil-Steuerung';

        // Enable Desktop Listeners
        cvs.addEventListener('pointerdown', handleDesktopPointerDown);
        cvs.addEventListener('pointermove', handleDesktopPointerMove);
        cvs.addEventListener('pointerup', handleDesktopPointerUp);
        cvs.addEventListener('wheel', handleDesktopWheel, { passive: false });
        window.addEventListener('keydown', handleDesktopKeyDown);
        window.addEventListener('keyup', handleDesktopKeyUp);

        // Disable Mobile Listeners
        document.getElementById('mobile-camera-area').removeEventListener('touchstart', handleMobileTouchStart);
        document.getElementById('mobile-camera-area').removeEventListener('touchmove', handleMobileTouchMove);
        document.getElementById('mobile-camera-area').removeEventListener('touchend', handleMobileTouchEnd);

        // Remove handlers for mobile move buttons
        Object.values(mobileMoveButtons).forEach(btn => {
            btn.removeEventListener('touchstart', () => keys[btn.dataset.key] = true);
            btn.removeEventListener('touchend', () => keys[btn.dataset.key] = false);
        });

        // Clear onclick handlers for mobile action buttons
        Object.values(mobileActionButtons).forEach(btn => {
            btn.onclick = null; // Set onclick to null to remove the handler
        });

        // Ensure no active keys from mobile controls
        keys = {};
        updateInfoBox();
    };

    const enableMobileControls = () => {
        currentControlMode = ControlModes.MOBILE;
        localStorage.setItem('voxelEditorControlMode', ControlModes.MOBILE);
        document.getElementById('current-control-mode').textContent = `Steuerung: ${ControlModes.MOBILE}`;
        document.getElementById('mobile-controls').style.display = 'flex';
        document.getElementById('toggleControlModeBtn').textContent = 'Desktop-Steuerung';

        // Enable Mobile Listeners
        const mobileCameraArea = document.getElementById('mobile-camera-area');
        mobileCameraArea.addEventListener('touchstart', handleMobileTouchStart);
        mobileCameraArea.addEventListener('touchmove', handleMobileTouchMove);
        mobileCameraArea.addEventListener('touchend', handleMobileTouchEnd);

        // Add handlers for mobile move buttons
        Object.values(mobileMoveButtons).forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent default touch behavior
                keys[btn.dataset.key] = true;
            }, { passive: false });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault(); // Prevent default touch behavior
                keys[btn.dataset.key] = false;
            }, { passive: false });
        });

        // Assign onclick handlers for mobile action buttons
        mobileActionButtons.add.onclick = () => {
            const intersection = getIntersection(cam, new THREE.Vector2(0,0)); // Use center of screen for add
            if (intersection) {
                const intersectPoint = intersection.point;
                const normal = intersection.face.normal;
                const newX = Math.floor(intersectPoint.x + normal.x * 0.1);
                const newY = Math.floor(intersectPoint.y + normal.y * 0.1);
                const newZ = Math.floor(intersectPoint.z + normal.z * 0.1);
                addVoxel(newX, newY, newZ, currentColor);
            }
        };
        mobileActionButtons.delete.onclick = () => {
            const intersection = getIntersection(cam, new THREE.Vector2(0,0)); // Use center of screen for delete
            if (intersection) {
                const { x, y, z } = intersection.object.position;
                deleteVoxel(x, y, z);
            }
        };
        mobileActionButtons.draw.onclick = () => {
            // Mobile draw mode: toggle active level based on camera's view?
            // Or simply use the current activeDrawingLevel if set
            // For simplicity on mobile, maybe 'draw' just means paint the voxel under crosshair
            const intersection = getIntersection(cam, new THREE.Vector2(0,0));
            if (intersection) {
                const { x, y, z } = intersection.object.position;
                drawVoxel(x, y, z, currentColor);
            }
        };

        // Disable Desktop Listeners
        cvs.removeEventListener('pointerdown', handleDesktopPointerDown);
        cvs.removeEventListener('pointermove', handleDesktopPointerMove);
        cvs.removeEventListener('pointerup', handleDesktopPointerUp);
        cvs.removeEventListener('wheel', handleDesktopWheel);
        window.removeEventListener('keydown', handleDesktopKeyDown);
        window.removeEventListener('keyup', handleDesktopKeyUp);

        updateInfoBox();
    };

    // Determine initial control mode
    const savedControlMode = localStorage.getItem('voxelEditorControlMode');
    if (savedControlMode === ControlModes.MOBILE || (savedControlMode === null && isMobileDevice())) {
        enableMobileControls();
    } else {
        enableDesktopControls();
    }

    // Toggle button for control mode
    document.getElementById('toggleControlModeBtn').onclick = () => {
        if (currentControlMode === ControlModes.DESKTOP) {
            enableMobileControls();
        } else {
            enableDesktopControls();
        }
    };

    // Initial update of info box content based on determined mode
    updateInfoBox();


    animate(); // Start the animation loop
};

/* --- Event Handlers for Mobile Controls --- */
function handleMobileTouchStart(event) {
    if (currentControlMode !== ControlModes.MOBILE) return;

    if (event.touches.length === 1) {
        mobileIsDraggingCamera = true;
        mobileTouchStartX = event.touches[0].clientX;
        mobileTouchStartY = event.touches[0].clientY;
        isPinching = false; // Reset pinch state
    } else if (event.touches.length === 2) {
        // Two-finger touch detected, likely a pinch gesture
        isPinching = true;
        mobileIsDraggingCamera = false; // Disable single-finger camera drag when pinching
        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
    }
}

function handleMobileTouchMove(event) {
    if (currentControlMode !== ControlModes.MOBILE) return;

    if (isPinching && event.touches.length === 2) {
        event.preventDefault(); // Prevent page scrolling during pinch zoom
        const dx = event.touches[0].clientX - event.touches[1].clientX;
        const dy = event.touches[0].clientY - event.touches[1].clientY;
        const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);

        const deltaPinch = currentPinchDistance - initialPinchDistance;

        // Adjust camera's field of view (FOV) for zooming.
        // A smaller FOV value results in a more "zoomed-in" view.
        // Clamp FOV to reasonable limits to prevent issues (e.g., 10 to 100 degrees).
        cam.fov = Math.max(10, Math.min(100, cam.fov - deltaPinch * pinchZoomSpeed));
        cam.updateProjectionMatrix();

        initialPinchDistance = currentPinchDistance; // Update initial distance for next move event
    } else if (mobileIsDraggingCamera && event.touches.length === 1) {
        event.preventDefault(); // Prevent page scrolling during camera rotation
        const currentX = event.touches[0].clientX;
        const currentY = event.touches[0].clientY;

        const deltaX = currentX - mobileTouchStartX;
        const deltaY = currentY - mobileTouchStartY;

        // Rotate the camera around its current target (the center of the grid)
        const target = new THREE.Vector3(GRID / 2, GRID / 2, GRID / 2);
        const currentCameraDistance = cam.position.distanceTo(target);

        // Apply rotation based on touch drag
        // Horizontal rotation (yaw) around the Y-axis (up axis of the scene)
        const yaw = -deltaX * rotSpeed * 2; // Invert deltaX for intuitive horizontal drag
        const yawQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
        cam.position.applyQuaternion(yawQuaternion);

        // Vertical rotation (pitch) around the camera's local X-axis (right axis)
        const pitch = deltaY * rotSpeed * 2;
        const cameraRight = new THREE.Vector3().crossVectors(cam.up, cam.position.clone().sub(target)).normalize();
        const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(cameraRight, pitch);

        // Apply pitch, but prevent flipping and excessive angles
        const newQuaternion = cam.quaternion.clone().multiply(pitchQuaternion).normalize();
        const tempCam = cam.clone();
        tempCam.quaternion.copy(newQuaternion);
        const upVector = new THREE.Vector3(0, 1, 0); // World up
        const rotatedUp = upVector.clone().applyQuaternion(tempCam.quaternion);
        // Check if the camera is trying to go beyond ~89 degrees up/down from horizontal
        if (Math.abs(rotatedUp.dot(upVector)) < 0.01 && Math.abs(pitch) > 0.001) { // If nearly horizontal and still pitching
            // Prevent further pitch if it would flip
        } else {
            cam.quaternion.copy(newQuaternion);
        }
        
        cam.lookAt(target);

        mobileTouchStartX = currentX;
        mobileTouchStartY = currentY;
    }
}

function handleMobileTouchEnd(event) {
    if (currentControlMode !== ControlModes.MOBILE) return;
    mobileIsDraggingCamera = false;
    isPinching = false;
    initialPinchDistance = 0; // Reset
}


/* --- Allgemeine Funktionen für Voxel-Operationen --- */
function addVoxel(x, y, z, color) {
    if (x < 0 || x >= GRID || y < 0 || y >= GRID || z < 0 || z >= GRID) {
        // console.warn("Voxel außerhalb des Gitters versucht hinzuzufügen.");
        return;
    }
    const id = `${x},${y},${z}`;
    if (voxels.has(id)) {
        // Only update color if different
        if (voxels.get(id).color !== color) {
            const oldColor = voxels.get(id).color;
            voxels.set(id, { color: color });
            addCommand('updateVoxel', x, y, z, oldColor, color);
            updateVoxelGeometry(x, y, z);
        }
        return;
    }
    voxels.set(id, { color: color });
    addCommand('addVoxel', x, y, z, null, color); // Add to history
    updateVoxelGeometry(x, y, z);
}

function deleteVoxel(x, y, z) {
    const id = `${x},${y},${z}`;
    if (!voxels.has(id)) return;
    const oldColor = voxels.get(id).color; // Store for undo
    voxels.delete(id);
    addCommand('deleteVoxel', x, y, z, oldColor, null); // Add to history
    updateVoxelGeometry(x, y, z);
}

function drawVoxel(x, y, z, color) {
    const id = `${x},${y},${z}`;
    if (!voxels.has(id)) return;
    const oldColor = voxels.get(id).color;
    if (oldColor === color) return; // No change, no need to redraw or add to history
    voxels.set(id, { color: color });
    addCommand('drawVoxel', x, y, z, oldColor, color); // Add to history
    updateVoxelGeometry(x, y, z);
}


function getIntersection(camera, pointer) {
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    mouse.x = (pointer.x / ren.domElement.clientWidth) * 2 - 1;
    mouse.y = -(pointer.y / ren.domElement.clientHeight) * 2 + 1;

    // Use a fixed point in the center of the screen for mobile (crosshair)
    if (currentControlMode === ControlModes.MOBILE) {
        mouse.x = 0;
        mouse.y = 0;
    }

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObject(voxelMesh); // Check intersection with the combined mesh
    if (intersects.length > 0) {
        const intersect = intersects[0];
        // Calculate the voxel position from the intersection point and normal
        // This is crucial for adding/deleting/drawing in grid space
        const point = intersect.point;
        const normal = intersect.face.normal;

        // Shift the point slightly along the normal to get the face of the target voxel
        // Then convert to grid coordinates
        let x = Math.round(point.x / VS - HALF);
        let y = Math.round(point.y / VS - HALF);
        let z = Math.round(point.z / VS - HALF);

        // Adjust for floating point inaccuracies or slight offsets if directly on the grid line
        // Ensure x, y, z are snapped to the center of the voxel's face.
        if (normal.x === 1) x--;
        if (normal.y === 1) y--;
        if (normal.z === 1) z--;
        
        // Return object containing original intersection data and calculated grid coordinates
        return {
            point: intersect.point,
            face: intersect.face,
            object: intersect.object,
            faceIndex: intersect.faceIndex,
            uv: intersect.uv,
            x: x, y: y, z: z, // Grid coordinates of the intersected voxel
            normal: normal // Normal of the intersected face
        };
    }
    return null;
}

function updateVoxelGeometry(updatedX = -1, updatedY = -1, updatedZ = -1) {
    const positions = [];
    const colors = [];
    const indices = [];
    let vertexCount = 0;

    // A single voxel's geometry (centered at 0,0,0)
    // Vertices for a cube (8 vertices)
    const vertices = [
        // Front face (Z+)
        -HALF, -HALF,  HALF, // 0
         HALF, -HALF,  HALF, // 1
         HALF,  HALF,  HALF, // 2
        -HALF,  HALF,  HALF, // 3
        // Back face (Z-)
        -HALF, -HALF, -HALF, // 4
         HALF, -HALF, -HALF, // 5
         HALF,  HALF, -HALF, // 6
        -HALF,  HALF, -HALF  // 7
    ];

    // Indices for the 6 faces, using the 8 vertices
    // Note: These indices refer to the 8 vertices defined above.
    // When we add a voxel, we'll map these to the global `positions` array.
    const cubeIndices = [
        0, 1, 2,  0, 2, 3,  // Front
        5, 4, 7,  5, 7, 6,  // Back
        4, 0, 3,  4, 3, 7,  // Left
        1, 5, 6,  1, 6, 2,  // Right
        3, 2, 6,  3, 6, 7,  // Top
        4, 5, 1,  4, 1, 0   // Bottom
    ];

    voxels.forEach((data, id) => {
        const [x, y, z] = id.split(',').map(Number);
        const color = new THREE.Color(data.color);

        // Only rebuild affected areas if coordinates are provided
        // For now, rebuild all, as optimized partial updates are complex
        // if (updatedX !== -1 && (x < updatedX - 1 || x > updatedX + 1 || y < updatedY - 1 || y > updatedY + 1 || z < updatedZ - 1 || z > updatedZ + 1)) {
        //     return; // Skip voxels not in the immediate vicinity (for optimization)
        // }

        // Add 8 vertices for this voxel
        for (let i = 0; i < vertices.length; i += 3) {
            positions.push(vertices[i] + x); // X
            positions.push(vertices[i + 1] + y); // Y
            positions.push(vertices[i + 2] + z); // Z
            colors.push(color.r, color.g, color.b); // Assign color to each vertex
        }

        // Add 36 indices for this voxel (6 faces * 2 triangles * 3 vertices)
        for (let i = 0; i < cubeIndices.length; i++) {
            indices.push(cubeIndices[i] + vertexCount);
        }
        vertexCount += 8; // Each voxel adds 8 vertices
    });

    if (positions.length === 0) {
        // If no voxels, clear the geometry
        voxelGeometry.dispose();
        voxelGeometry = new THREE.BufferGeometry();
        voxelMesh.geometry = voxelGeometry;
        return;
    }

    // Dispose of the old geometry to free up memory
    if (voxelMesh.geometry) {
        voxelMesh.geometry.dispose();
    }

    voxelGeometry = new THREE.BufferGeometry();
    voxelGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    voxelGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); // Use colors
    voxelGeometry.setIndex(indices);

    // Compute normals for lighting
    voxelGeometry.computeVertexNormals();

    voxelMesh.geometry = voxelGeometry;
}

function rebuildHelpers() {
    // Remove old helpers if they exist
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    // Create new GridHelper
    gridHelper = new THREE.GridHelper(GRID * VS, GRID, 0x888888, 0x444444);
    scene.add(gridHelper);

    // Create new BoxHelper to represent the bounds
    const boxGeometry = new THREE.BoxGeometry(GRID * VS, GRID * VS, GRID * VS);
    const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0, wireframe: true });
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    // Position the box to align with the grid
    box.position.set(GRID * HALF, GRID * HALF, GRID * HALF);
    boxHelper = new THREE.BoxHelper(box, 0xff0000); // Red color for the boundary box
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    // Position the grid helper relative to the current active drawing level
    const offset = HALF; // Center of a voxel is 0.5, 0.5, 0.5
    gridHelper.position.set(GRID * HALF, activeDrawingLevel.y + offset, GRID * HALF);

    // Make the active level visible with a plane or a highlight
    // For simplicity, we just update the grid helper's position.
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
}

function clearAll() {
    // Store current state for undo
    const oldVoxelsState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });
    
    voxels.clear();
    updateVoxelGeometry(); // Clear the mesh
    addCommand('clearAll', null, null, null, null, null, oldVoxelsState, []); // Add to history
    console.log("Alle Voxel gelöscht.");
}

function fillActiveLevel() {
    const oldVoxelsState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    const yLevel = activeDrawingLevel.y;
    let addedCount = 0;
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            const id = `${x},${yLevel},${z}`;
            if (!voxels.has(id)) {
                voxels.set(id, { color: currentColor });
                addedCount++;
            } else if (voxels.get(id).color !== currentColor) {
                voxels.set(id, { color: currentColor }); // Update color if different
                addedCount++;
            }
        }
    }
    if (addedCount > 0) {
        updateVoxelGeometry();
        const newVoxelsState = [...voxels.entries()].map(([id, data]) => {
            const parts = id.split(',').map(Number);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        addCommand('fillLevel', null, null, null, null, null, oldVoxelsState, newVoxelsState, { level: yLevel, axis: 'y' });
        console.log(`Ebene Y=${yLevel} mit ${addedCount} Voxeln gefüllt/aktualisiert.`);
    } else {
        console.log(`Ebene Y=${yLevel} ist bereits vollständig mit der aktuellen Farbe gefüllt.`);
    }
}


/* --- Speichern und Laden --- */
function saveJSON() {
    const data = {
        gridSize: GRID,
        voxels: Array.from(voxels.entries()).map(([id, voxelData]) => {
            const [x, y, z] = id.split(',').map(Number);
            return { x, y, z, color: voxelData.color };
        }),
        // Save current color and fly speed
        currentColor: currentColor,
        moveSpeed: moveSpeed,
        terrainHeightScale: terrainHeightScale,
        terrainFrequency: terrainFrequency,
        terrainOctaves: terrainOctaves,
        terrainLacunarity: terrainLacunarity,
        terrainGain: terrainGain,
        terrainSeed: terrainSeed,
        hasUserTypedSeed: hasUserTypedSeed
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log("Projekt als JSON gespeichert.");
}

function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const loadedData = JSON.parse(e.target.result);

            // Store current state for undo
            const oldVoxelsState = [...voxels.entries()].map(([id, data]) => {
                const parts = id.split(',').map(Number);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            const oldGrid = GRID;

            // Apply loaded data
            GRID = loadedData.gridSize || 10;
            localStorage.setItem('voxelEditorGridSize', GRID);
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            
            voxels.clear();
            if (loadedData.voxels) {
                loadedData.voxels.forEach(v => {
                    voxels.set(`${v.x},${v.y},${v.z}`, { color: v.color });
                });
            }
            updateVoxelGeometry();
            rebuildHelpers();
            updateGridHelperPosition();
            resetCameraPosition();

            // Load and apply other settings
            currentColor = loadedData.currentColor || '#ffffff';
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;

            moveSpeed = loadedData.moveSpeed || 0.1;
            localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            document.getElementById('fly-speed-slider').value = moveSpeed;
            document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);

            // Load terrain parameters
            terrainHeightScale = loadedData.terrainHeightScale !== undefined ? loadedData.terrainHeightScale : 10;
            terrainFrequency = loadedData.terrainFrequency !== undefined ? loadedData.terrainFrequency : 0.05;
            terrainOctaves = loadedData.terrainOctaves !== undefined ? loadedData.terrainOctaves : 4;
            terrainLacunarity = loadedData.terrainLacunarity !== undefined ? loadedData.terrainLacunarity : 2.0;
            terrainGain = loadedData.terrainGain !== undefined ? loadedData.terrainGain : 0.5;
            terrainSeed = loadedData.terrainSeed !== undefined ? loadedData.terrainSeed : '';
            hasUserTypedSeed = loadedData.hasUserTypedSeed !== undefined ? loadedData.hasUserTypedSeed : false;

            document.getElementById('terrain-height-scale').value = terrainHeightScale;
            document.getElementById('terrain-frequency').value = terrainFrequency;
            document.getElementById('terrain-octaves').value = terrainOctaves;
            document.getElementById('terrain-lacunarity').value = terrainLacunarity;
            document.getElementById('terrain-gain').value = terrainGain;
            document.getElementById('terrain-seed').value = terrainSeed;
            // Re-initialize noise generator with loaded seed
            noise2D = new ValueNoise2D(terrainSeed);

            // Update preset colors if saved
            for (let i = 1; i <= 3; i++) {
                if (loadedData[`voxelPresetColor${i}`]) {
                    presetColors[i - 1] = loadedData[`voxelPresetColor${i}`];
                    localStorage.setItem(`voxelPresetColor${i}`, loadedData[`voxelPresetColor${i}`]);
                    document.getElementById(`color-preset-${i}`).style.backgroundColor = presetColors[i - 1];
                }
            }

            // After loading, update the current active preset if the loaded currentColor matches one.
            let matchedPreset = false;
            for(let i = 0; i < presetColors.length; i++) {
                if (presetColors[i].toUpperCase() === currentColor.toUpperCase()) {
                    setActivePreset(i);
                    matchedPreset = true;
                    break;
                }
            }
            if (!matchedPreset) {
                presetBoxes.forEach(box => box.classList.remove('active'));
                activePresetIndex = -1;
            }


            // Add to history (load operation is treated as a state change)
            const newVoxelsState = [...voxels.entries()].map(([id, data]) => {
                const parts = id.split(',').map(Number);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });
            addCommand('loadProject', null, null, null, null, null, oldVoxelsState, newVoxelsState, { oldGrid: oldGrid, newGrid: GRID });

            console.log("Projekt erfolgreich geladen.");

        } catch (error) {
            console.error("Fehler beim Laden der JSON-Datei:", error);
            alert("Fehler beim Laden der Datei. Bitte stellen Sie sicher, dass es sich um eine gültige Voxel-Editor-JSON-Datei handelt.");
        }
    };
    reader.readAsText(file);
}

function exportSTL() {
    if (voxels.size === 0) {
        alert("Keine Voxel zum Exportieren vorhanden.");
        return;
    }

    // Create a single geometry from all existing voxels
    const combinedGeometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = []; // STL doesn't support colors directly, but good to have if we were doing other exports
    const indices = [];
    let vertexCount = 0;

    const voxelCubeGeometry = new THREE.BoxBufferGeometry(VS, VS, VS); // A single voxel cube geometry
    // Calculate vertices for a cube (centered at 0,0,0)
    // Convert to non-indexed for direct vertex output for simplicity with BufferGeometryUtils merge
    const tempPositions = Array.from(voxelCubeGeometry.attributes.position.array);
    const tempIndices = Array.from(voxelCubeGeometry.index.array);

    // Generate individual non-indexed vertices for faces for simpler merging
    const faceVertexPositions = [];
    for(let i=0; i < tempIndices.length; i++) {
        const idx = tempIndices[i];
        faceVertexPositions.push(tempPositions[idx * 3], tempPositions[idx * 3 + 1], tempPositions[idx * 3 + 2]);
    }
    const perVoxelGeometry = new THREE.BufferGeometry();
    perVoxelGeometry.setAttribute('position', new THREE.Float32BufferAttribute(faceVertexPositions, 3));
    perVoxelGeometry.computeVertexNormals(); // Crucial for STL to have correct normals

    const geometries = [];

    voxels.forEach((data, id) => {
        const [x, y, z] = id.split(',').map(Number);
        const instanceGeometry = perVoxelGeometry.clone();
        instanceGeometry.translate(x + HALF, y + HALF, z + HALF); // Translate to its grid position
        geometries.push(instanceGeometry);
    });

    // Merge all geometries into a single one
    let mergedGeometry;
    try {
        mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
    } catch (error) {
        console.error("Error merging geometries for STL export:", error);
        alert("Fehler beim Zusammenführen der Voxel für den STL-Export. Konsultieren Sie die Konsole für Details.");
        return;
    }
    

    const exporter = new THREE.STLExporter();
    const stlString = exporter.parse(new THREE.Mesh(mergedGeometry)); // Pass a mesh to the exporter

    const blob = new Blob([stlString], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    console.log("Projekt als STL exportiert.");

    // Dispose of temporary geometries
    geometries.forEach(g => g.dispose());
    if (mergedGeometry) mergedGeometry.dispose();
}

/* --- Camera Movement and Interaction --- */
function animate() {
    requestAnimationFrame(animate);

    // Handle desktop key movements (if desktop mode active)
    if (currentControlMode === ControlModes.DESKTOP) {
        const forward = new THREE.Vector3();
        cam.getWorldDirection(forward);
        forward.y = 0; // Lock to horizontal movement
        forward.normalize();

        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();

        if (keys['KeyW']) cam.position.addScaledVector(forward, moveSpeed);
        if (keys['KeyS']) cam.position.addScaledVector(forward, -moveSpeed);
        if (keys['KeyA']) cam.position.addScaledVector(right, -moveSpeed);
        if (keys['KeyD']) cam.position.addScaledVector(right, moveSpeed);
        if (keys['KeyE']) cam.position.y += moveSpeed;
        if (keys['KeyQ']) cam.position.y -= moveSpeed;
    } else if (currentControlMode === ControlModes.MOBILE) {
        // Mobile D-pad movement
        const forward = new THREE.Vector3();
        cam.getWorldDirection(forward);
        forward.y = 0; // Lock to horizontal movement
        forward.normalize();

        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();

        if (keys['KeyW']) cam.position.addScaledVector(forward, moveSpeed * 2); // Faster mobile movement
        if (keys['KeyS']) cam.position.addScaledVector(forward, -moveSpeed * 2);
        if (keys['KeyA']) cam.position.addScaledVector(right, -moveSpeed * 2);
        if (keys['KeyD']) cam.position.addScaledVector(right, moveSpeed * 2);
        if (keys['KeyE']) cam.position.y += moveSpeed * 2;
        if (keys['KeyQ']) cam.position.y -= moveSpeed * 2;
    }
    

    ren.render(scene, cam);
}

// Helper for desktop pointer events
let isPointerDown = false;
let startPointerX, startPointerY;
let pointerButton; // 0 for left, 1 for middle, 2 for right

function handleDesktopPointerDown(event) {
    if (currentControlMode !== ControlModes.DESKTOP) return;

    isPointerDown = true;
    startPointerX = event.clientX;
    startPointerY = event.clientY;
    pointerButton = event.button;

    // Right-click for camera rotation (only if not already rotating)
    if (pointerButton === 2) {
        rotate = true;
        cvs.setPointerCapture(event.pointerId); // Capture pointer for consistent dragging
    }
    // Left-click for voxel interaction
    else if (pointerButton === 0) {
        // Check for Shift or Control key for drag operations
        if (event.shiftKey) {
            isShiftDragging = true;
            currentShiftDragLevel = { x: activeDrawingLevel.x, y: activeDrawingLevel.y, z: activeDrawingLevel.z };
        } else if (event.ctrlKey) {
            isControlDragging = true;
        } else {
            // Normal click action
            const intersection = getIntersection(cam, event);
            if (intersection) {
                if (currentMode === Modes.ADD) {
                    addVoxel(intersection.x + intersection.normal.x, intersection.y + intersection.normal.y, intersection.z + intersection.normal.z, currentColor);
                } else if (currentMode === Modes.DELETE) {
                    deleteVoxel(intersection.x, intersection.y, intersection.z);
                } else if (currentMode === Modes.DRAW) {
                    drawVoxel(intersection.x, intersection.y, intersection.z, currentColor);
                }
            }
        }
    }
}

function handleDesktopPointerMove(event) {
    if (currentControlMode !== ControlModes.DESKTOP) return;

    if (rotate) {
        const deltaX = event.clientX - startPointerX;
        const deltaY = event.clientY - startPointerY;

        // Apply rotation to Euler angles
        euler.y -= deltaX * rotSpeed;
        euler.x -= deltaY * rotSpeed;

        // Clamp vertical rotation (pitch) to prevent camera flipping
        euler.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, euler.x));

        cam.quaternion.setFromEuler(euler);

        // After rotation, look at the center of the grid
        cam.lookAt(GRID / 2, GRID / 2, GRID / 2);

        startPointerX = event.clientX;
        startPointerY = event.clientY;
    } else if (isShiftDragging) {
        const intersection = getIntersection(cam, event);
        if (intersection && currentShiftDragLevel) {
            // Calculate a temporary active level based on drag, then apply action
            const tempX = Math.round(intersection.x + intersection.normal.x);
            const tempY = Math.round(intersection.y + intersection.normal.y);
            const tempZ = Math.round(intersection.z + intersection.normal.z);

            // Determine if the current voxel is on the original drag level's plane
            // This logic assumes drawing on a specific plane (x, y, or z)
            let voxelX, voxelY, voxelZ;
            if (activeDrawingLevel.y === currentShiftDragLevel.y) { // If original drag was on Y plane
                voxelX = tempX;
                voxelY = currentShiftDragLevel.y;
                voxelZ = tempZ;
            } else if (activeDrawingLevel.x === currentShiftDragLevel.x) { // If original drag was on X plane
                voxelX = currentShiftDragLevel.x;
                voxelY = tempY;
                voxelZ = tempZ;
            } else if (activeDrawingLevel.z === currentShiftDragLevel.z) { // If original drag was on Z plane
                voxelX = tempX;
                voxelY = tempY;
                voxelZ = currentShiftDragLevel.z;
            } else { // Fallback, use the intersected voxel directly
                voxelX = tempX;
                voxelY = tempY;
                voxelZ = tempZ;
            }

            // Apply action to the voxel
            if (currentMode === Modes.ADD) {
                addVoxel(voxelX, voxelY, voxelZ, currentColor);
            } else if (currentMode === Modes.DELETE) {
                deleteVoxel(voxelX, voxelY, voxelZ);
            } else if (currentMode === Modes.DRAW) {
                drawVoxel(voxelX, voxelY, voxelZ, currentColor);
            }
        }
    } else if (isControlDragging) {
        if (currentMode === Modes.ADD) { // Only Control-drag for ADD mode
            const intersection = getIntersection(cam, event);
            if (intersection) {
                // Calculate position relative to the intersected voxel's top face
                const newX = Math.round(intersection.x + intersection.normal.x);
                const newY = Math.round(intersection.y + intersection.normal.y);
                const newZ = Math.round(intersection.z + intersection.normal.z);
                addVoxel(newX, newY, newZ, currentColor);
            }
        }
    }
}

function handleDesktopPointerUp(event) {
    if (currentControlMode !== ControlModes.DESKTOP) return;

    if (pointerButton === 2) {
        rotate = false;
        cvs.releasePointerCapture(event.pointerId);
    } else if (pointerButton === 0) {
        isShiftDragging = false;
        isControlDragging = false;
        currentShiftDragLevel = null;
    }
    isPointerDown = false;
}

function handleDesktopWheel(event) {
    if (currentControlMode !== ControlModes.DESKTOP) return;
    event.preventDefault(); // Prevent page scrolling

    if (event.altKey) {
        const delta = Math.sign(event.deltaY); // -1 for scroll up, 1 for scroll down

        if (event.shiftKey) {
            // Alt + Shift + Wheel for Z-axis level
            activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z + delta));
            currentDrawingAxis = 'z';
            console.log(`Aktive Zeichenebene Z: ${activeDrawingLevel.z}`);
        } else if (event.ctrlKey) {
            // Alt + Control + Wheel for X-axis level
            activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x + delta));
            currentDrawingAxis = 'x';
            console.log(`Aktive Zeichenebene X: ${activeDrawingLevel.x}`);
        } else {
            // Alt + Wheel for Y-axis level
            activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y + delta));
            currentDrawingAxis = 'y';
            console.log(`Aktive Zeichenebene Y: ${activeDrawingLevel.y}`);
        }
        updateGridHelperPosition(); // Update grid helper to show the active level
    } else {
        // Normal mouse wheel for camera speed adjustment
        moveSpeed -= Math.sign(event.deltaY) * 0.01;
        moveSpeed = Math.max(0.01, Math.min(2.0, moveSpeed)); // Clamp between 0.01 and 2.0
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    }
}

function handleDesktopKeyDown(event) {
    if (currentControlMode !== ControlModes.DESKTOP) return;
    keys[event.code] = true;

    // Handle Tab for mode switching
    if (event.code === 'Tab') {
        event.preventDefault(); // Prevent default tab behavior
        cycleMode();
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    }

    // Handle number keys for preset colors
    if (event.code === 'Digit1') setActivePreset(0);
    if (event.code === 'Digit2') setActivePreset(1);
    if (event.code === 'Digit3') setActivePreset(2);

    // Undo/Redo (Ctrl+Z, Ctrl+Y, Ctrl+Shift+Z)
    if (event.ctrlKey && event.code === 'KeyZ') {
        event.preventDefault(); // Prevent browser undo
        undo();
    }
    if (event.ctrlKey && (event.code === 'KeyY' || (event.shiftKey && event.code === 'KeyZ'))) {
        event.preventDefault(); // Prevent browser redo
        redo();
    }
}

function handleDesktopKeyUp(event) {
    if (currentControlMode !== ControlModes.DESKTOP) return;
    keys[event.code] = false;
}


/* --- Undo/Redo Funktionen --- */
function addCommand(type, x, y, z, oldColor, newColor, oldState = null, newState = null, metadata = {}) {
    // Clear any "redo" history if a new action is performed
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    const command = {
        type: type,
        x: x, y: y, z: z,
        oldColor: oldColor,
        newColor: newColor,
        oldState: oldState, // For full grid state changes (clear, load, terrain, resize)
        newState: newState,
        metadata: metadata // For additional info like oldGrid/newGrid
    };
    history.push(command);
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift(); // Remove oldest command
    }
    historyPointer = history.length - 1;
    // console.log("Command added:", command, "History length:", history.length, "Pointer:", historyPointer);
}

function undo() {
    if (historyPointer < 0) {
        console.log("Nichts rückgängig zu machen.");
        return;
    }

    const command = history[historyPointer];
    console.log("Rückgängig:", command);

    switch (command.type) {
        case 'addVoxel':
            voxels.delete(`${command.x},${command.y},${command.z}`);
            updateVoxelGeometry(command.x, command.y, command.z);
            break;
        case 'deleteVoxel':
            voxels.set(`${command.x},${command.y},${command.z}`, { color: command.oldColor });
            updateVoxelGeometry(command.x, command.y, command.z);
            break;
        case 'drawVoxel':
        case 'updateVoxel': // Same logic for draw and update
            voxels.set(`${command.x},${command.y},${command.z}`, { color: command.oldColor });
            updateVoxelGeometry(command.x, command.y, command.z);
            break;
        case 'clearAll':
            // Restore all voxels from oldState
            voxels.clear();
            if (command.oldState) {
                command.oldState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
            }
            updateVoxelGeometry();
            break;
        case 'fillLevel':
            // Revert to old state for fillLevel. This is the simplest way to handle it,
            // as individual voxel states might have been complex.
            voxels.clear();
            if (command.oldState) {
                command.oldState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
            }
            updateVoxelGeometry();
            break;
        case 'resizeGrid':
            if (command.metadata && command.metadata.oldGrid) {
                GRID = command.metadata.oldGrid;
                localStorage.setItem('voxelEditorGridSize', GRID);
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                
                voxels.clear();
                if (command.oldState) {
                    command.oldState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
                }
                updateVoxelGeometry();
                rebuildHelpers();
                updateGridHelperPosition();
                resetCameraPosition(); // Adjust camera for new (old) grid
            }
            break;
        case 'generateTerrain':
            voxels.clear();
            if (command.oldState) { // oldState for terrain generation is usually empty
                command.oldState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
            }
            updateVoxelGeometry();
            break;
        case 'loadProject':
            // Special handling for load - apply old state, including old grid size
            applyState(command.oldState, command.metadata.oldGrid);
            // Also revert other saved settings
            currentColor = command.metadata.oldColor || '#ffffff';
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;

            moveSpeed = command.metadata.oldMoveSpeed || 0.1;
            localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            document.getElementById('fly-speed-slider').value = moveSpeed;
            document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);

            terrainHeightScale = command.metadata.oldTerrainHeightScale !== undefined ? command.metadata.oldTerrainHeightScale : 10;
            terrainFrequency = command.metadata.oldTerrainFrequency !== undefined ? command.metadata.oldTerrainFrequency : 0.05;
            terrainOctaves = command.metadata.oldTerrainOctaves !== undefined ? command.metadata.oldTerrainOctaves : 4;
            terrainLacunarity = command.metadata.oldTerrainLacunarity !== undefined ? command.metadata.oldTerrainLacunarity : 2.0;
            terrainGain = command.metadata.oldTerrainGain !== undefined ? command.metadata.oldTerrainGain : 0.5;
            terrainSeed = command.metadata.oldTerrainSeed !== undefined ? command.metadata.oldTerrainSeed : '';
            hasUserTypedSeed = command.metadata.oldHasUserTypedSeed !== undefined ? command.metadata.oldHasUserTypedSeed : false;
            document.getElementById('terrain-height-scale').value = terrainHeightScale;
            document.getElementById('terrain-frequency').value = terrainFrequency;
            document.getElementById('terrain-octaves').value = terrainOctaves;
            document.getElementById('terrain-lacunarity').value = terrainLacunarity;
            document.getElementById('terrain-gain').value = terrainGain;
            document.getElementById('terrain-seed').value = terrainSeed;
            noise2D = new ValueNoise2D(terrainSeed);

            // Revert preset colors
            if (command.metadata.oldPresetColors) {
                for (let i = 0; i < command.metadata.oldPresetColors.length; i++) {
                    presetColors[i] = command.metadata.oldPresetColors[i];
                    localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                    document.getElementById(`color-preset-${i + 1}`).style.backgroundColor = presetColors[i];
                }
            }
            // Update active preset based on reverted current color
            let matchedPreset = false;
            for(let i = 0; i < presetColors.length; i++) {
                if (presetColors[i].toUpperCase() === currentColor.toUpperCase()) {
                    setActivePreset(i);
                    matchedPreset = true;
                    break;
                }
            }
            if (!matchedPreset) {
                presetBoxes.forEach(box => box.classList.remove('active'));
                activePresetIndex = -1;
            }

            break;
    }
    historyPointer--;
}

function redo() {
    if (historyPointer >= history.length - 1) {
        console.log("Nichts wiederherzustellen.");
        return;
    }

    historyPointer++;
    const command = history[historyPointer];
    console.log("Wiederherstellen:", command);

    switch (command.type) {
        case 'addVoxel':
            voxels.set(`${command.x},${command.y},${command.z}`, { color: command.newColor });
            updateVoxelGeometry(command.x, command.y, command.z);
            break;
        case 'deleteVoxel':
            voxels.delete(`${command.x},${command.y},${command.z}`);
            updateVoxelGeometry(command.x, command.y, command.z);
            break;
        case 'drawVoxel':
        case 'updateVoxel':
            voxels.set(`${command.x},${command.y},${command.z}`, { color: command.newColor });
            updateVoxelGeometry(command.x, command.y, command.z);
            break;
        case 'clearAll':
            voxels.clear();
            updateVoxelGeometry();
            break;
        case 'fillLevel':
            // Restore from newState for fillLevel
            voxels.clear();
            if (command.newState) {
                command.newState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
            }
            updateVoxelGeometry();
            break;
        case 'resizeGrid':
            if (command.metadata && command.metadata.newGrid) {
                GRID = command.metadata.newGrid;
                localStorage.setItem('voxelEditorGridSize', GRID);
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                
                voxels.clear();
                if (command.newState) {
                    command.newState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
                }
                updateVoxelGeometry();
                rebuildHelpers();
                updateGridHelperPosition();
                resetCameraPosition();
            }
            break;
        case 'generateTerrain':
            voxels.clear();
            if (command.newState) {
                command.newState.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
            }
            updateVoxelGeometry();
            break;
        case 'loadProject':
            // Apply new state, including new grid size
            applyState(command.newState, command.metadata.newGrid);
            // Also re-apply other saved settings that were loaded
            currentColor = command.metadata.newColor || '#ffffff';
            localStorage.setItem('voxelEditorColor', currentColor);
            document.getElementById('color-picker').value = currentColor;

            moveSpeed = command.metadata.newMoveSpeed || 0.1;
            localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
            document.getElementById('fly-speed-slider').value = moveSpeed;
            document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);

            terrainHeightScale = command.metadata.newTerrainHeightScale !== undefined ? command.metadata.newTerrainHeightScale : 10;
            terrainFrequency = command.metadata.newTerrainFrequency !== undefined ? command.metadata.newTerrainFrequency : 0.05;
            terrainOctaves = command.metadata.newTerrainOctaves !== undefined ? command.metadata.newTerrainOctaves : 4;
            terrainLacunarity = command.metadata.newTerrainLacunarity !== undefined ? command.metadata.newTerrainLacunarity : 2.0;
            terrainGain = command.metadata.newTerrainGain !== undefined ? command.metadata.newTerrainGain : 0.5;
            terrainSeed = command.metadata.newTerrainSeed !== undefined ? command.metadata.newTerrainSeed : '';
            hasUserTypedSeed = command.metadata.newHasUserTypedSeed !== undefined ? command.metadata.newHasUserTypedSeed : false;
            document.getElementById('terrain-height-scale').value = terrainHeightScale;
            document.getElementById('terrain-frequency').value = terrainFrequency;
            document.getElementById('terrain-octaves').value = terrainOctaves;
            document.getElementById('terrain-lacunarity').value = terrainLacunarity;
            document.getElementById('terrain-gain').value = terrainGain;
            document.getElementById('terrain-seed').value = terrainSeed;
            noise2D = new ValueNoise2D(terrainSeed);

            // Reapply preset colors
            if (command.metadata.newPresetColors) {
                for (let i = 0; i < command.metadata.newPresetColors.length; i++) {
                    presetColors[i] = command.metadata.newPresetColors[i];
                    localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                    document.getElementById(`color-preset-${i + 1}`).style.backgroundColor = presetColors[i];
                }
            }
            // Update active preset based on re-applied current color
            let matchedPreset = false;
            for(let i = 0; i < presetColors.length; i++) {
                if (presetColors[i].toUpperCase() === currentColor.toUpperCase()) {
                    setActivePreset(i);
                    matchedPreset = true;
                    break;
                }
            }
            if (!matchedPreset) {
                presetBoxes.forEach(box => box.classList.remove('active'));
                activePresetIndex = -1;
            }
            break;
    }
}

function applyState(state, newGridSize = GRID) {
    const oldGrid = GRID; // Store current GRID before applying new state's grid
    voxels.clear(); // Clear current state

    // If grid size changed, update GRID and related elements
    if (newGridSize && newGridSize !== GRID) {
        GRID = newGridSize;
        localStorage.setItem('voxelEditorGridSize', GRID);
        document.getElementById('grid-size-slider').value = GRID;
        document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        rebuildHelpers(); // Rebuild helpers for new grid size
        updateGridHelperPosition();
        resetCameraPosition(); // Adjust camera for new grid
    }

    if (state) {
        state.forEach(v => voxels.set(`${v.gx},${v.gy},${v.gz}`, { color: v.color }));
    }
    updateVoxelGeometry();
    console.log("State angewendet.");
}


/* --- Weitere Hilfsfunktionen --- */
function onResize() {
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
}

// Cycle through modes: Add -> Delete -> Draw -> Add
function cycleMode() {
    if (currentMode === Modes.ADD) {
        currentMode = Modes.DELETE;
    } else if (currentMode === Modes.DELETE) {
        currentMode = Modes.DRAW;
    } else {
        currentMode = Modes.ADD;
    }
    // Update the border color of the container to reflect the new mode
    const borderColor = document.getElementById('current-mode').style.color; // Get color from the mode display
    if (containerDiv && borderColor) {
        containerDiv.style.border = `2px solid ${borderColor}`;
    }
}

// Function to set an active preset color
function setActivePreset(index) {
    // Remove 'active' class from all preset boxes
    presetBoxes.forEach((box, i) => {
        if (i === index) {
            box.classList.add('active'); // Add 'active' class to the selected box
        } else {
            box.classList.remove('active');
        }
    });
    currentColor = presetColors[index]; // Set global current color
    document.getElementById('color-picker').value = currentColor; // Update color picker
    localStorage.setItem('voxelEditorColor', currentColor); // Save to local storage
    activePresetIndex = index; // Set the active preset index
}

// Perlin Noise implementation for terrain generation (simple 2D value noise)
class ValueNoise2D {
    constructor(seed = '') {
        this.random = seedrandom(seed);
        this.p = Array.from({length: 256}, (_, i) => i);
        // Shuffle p array
        for(let i = 0; i < this.p.length; i++) {
            const j = Math.floor(this.random() * this.p.length);
            [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
        }
        // Duplicate p array to avoid modulo operations
        for(let i = 0; i < 256; i++) {
            this.p[i + 256] = this.p[i];
        }
    }

    // Helper functions
    fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    lerp(t, a, b) { return a + t * (b - a); }
    
    // Gradient function for value noise (returns a random value based on hash)
    grad(hash, x, y) {
        // Simple random value based on the hash (permutation value)
        // This is a common way to get a deterministic "gradient" for value noise
        // without actual gradient vectors.
        const v = this.p[hash & 0xFF] / 255.0; // Normalize to 0-1
        return v * 2 - 1; // Scale to -1 to 1
    }

    noise(x, y) {
        // Find unit grid cell containing point
        let X = Math.floor(x) & 255;
        let Y = Math.floor(y) & 255;

        // Relative coordinates of the point within the cell
        x -= Math.floor(x);
        y -= Math.floor(y);

        // Compute fade curves for x and y
        let u = this.fade(x);
        let v = this.fade(y);

        // Hash coordinates of the 4 corners
        let A = this.p[X] + Y, AA = this.p[A], AB = this.p[A + 1];
        let B = this.p[X + 1] + Y, BA = this.p[B], BB = this.p[B + 1];

        // Interpolate between grid point values
        let res = this.lerp(v,
                    this.lerp(u, this.grad(AA, x, y), this.grad(BA, x - 1, y)),
                    this.lerp(u, this.grad(AB, x, y - 1), this.grad(BB, x - 1, y - 1))
                );
        return res;
    }

    // Octave noise (Fractal Brownian Motion)
    octaveNoise(x, y, octaves, frequency, lacunarity, gain) {
        let total = 0;
        let amplitude = 1;
        let maxVal = 0; // Used to normalize the output to -1 to 1

        for (let i = 0; i < octaves; i++) {
            total += this.noise(x * frequency, y * frequency) * amplitude;
            maxVal += amplitude; // Sum of amplitudes for normalization
            amplitude *= gain;
            frequency *= lacunarity;
        }
        return total / maxVal; // Normalize to [-1, 1]
    }
}

function generateTerrain() {
    console.log("Generiere Gelände mit:");
    console.log(`  Höhe: ${terrainHeightScale}`);
    console.log(`  Frequenz: ${terrainFrequency}`);
    console.log(`  Oktaven: ${terrainOctaves}`);
    console.log(`  Lacunarity: ${terrainLacunarity}`);
    console.log(`  Gain: ${terrainGain}`);
    console.log(`  Seed: ${terrainSeed}`);

    // Create a new noise generator with the current seed
    noise2D = new ValueNoise2D(terrainSeed);

    // Capture old state for undo
    const oldVoxelsState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    voxels.clear(); // Clear existing voxels

    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            // Generate noise value for this (x, z) coordinate
            // Noise output is in [-1, 1]. Map it to a height within the grid.
            let height = noise2D.octaveNoise(
                x, z,
                terrainOctaves,
                terrainFrequency,
                terrainLacunarity,
                terrainGain
            );
            // Map height from [-1, 1] to [0, GRID - 1]
            height = (height + 1) / 2; // Normalize to [0, 1]
            let voxelHeight = Math.floor(height * terrainHeightScale);
            voxelHeight = Math.max(0, Math.min(GRID - 1, voxelHeight)); // Clamp to grid boundaries

            for (let y = 0; y <= voxelHeight; y++) {
                // Example: set color based on height or a fixed color
                // For simplicity, using a fixed color or the current selected color
                let color = currentColor;
                // Optional: color variation based on height
                if (y < GRID * 0.2) color = '#8B4513'; // Brown for lower levels
                else if (y < GRID * 0.5) color = '#708237'; // Green for middle levels
                else color = '#AAAAAA'; // Grey for higher levels

                // Use the currently selected color if user prefers
                if (document.getElementById('color-picker').value !== '#ffffff') { // If user changed from default white
                    color = currentColor;
                }

                voxels.set(`${x},${y},${z}`, { color: color });
            }
        }
    }
    updateVoxelGeometry();

    // Add to history
    const newVoxelsState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });
    addCommand('generateTerrain', null, null, null, null, null, oldVoxelsState, newVoxelsState, {
        heightScale: terrainHeightScale,
        frequency: terrainFrequency,
        octaves: terrainOctaves,
        lacunarity: terrainLacunarity,
        gain: terrainGain,
        seed: terrainSeed
    });

    console.log("Gelände-Generierung abgeschlossen.");
}


</script>
</body>
</html>
