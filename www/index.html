<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>
<style>
/* CSS f√ºr den Body mit Safe-Area-Anpassungen */
body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;

    /* --- WICHTIG: ANPASSUNGEN F√úR SICHERE BEREICHE --- */
    /* Verschiebt den Inhalt nach unten, um Platz f√ºr die Statusleiste/Notch zu schaffen */
    padding-top: env(safe-area-inset-top);
    /* F√ºgt Polsterung f√ºr den unteren Bereich hinzu (z.B. f√ºr Home-Indikatoren auf iPhones) */
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Entscheidend: Stellt sicher, dass das Padding in der 100vh H√∂he enthalten ist */
    box-sizing: border-box;
    /* NEW: Prevent full page zoom on mobile */
    touch-action: pan-x pan-y;
    /* NEW: Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}

/* verhindert, dass das OS den Canvas als Text selektiert */
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;    /* iOS Kontextmen√º */
}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode{
    font-weight:700;
    color:#81c784;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
    /* Prevent accidental zooming */
    touch-action: none;
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box; /* Ensure border (if added back) doesn't push content out */
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    display: none;
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
/* NEW: Apply to input[type="color"] as well */
.color-preset-box, input[type="color"].color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    /* Ensure input type color specific styles are overridden for rectangular shape */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0;
}

input[type="color"].color-preset-box::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"].color-preset-box::-webkit-color-swatch {
    border: none; /* Remove inner border from default swatch */
    border-radius: 3px; /* Slightly smaller radius than outer for visual effect */
}
input[type="color"].color-preset-box::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"].color-preset-box::-moz-color-swatch {
    border: none;
    border-radius: 3px;
}


.color-preset-box:hover, input[type="color"].color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active, input[type="color"].color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* ---------------------------------------------------
    HAMBURGER-BUTTON
    --------------------------------------------------- */
#menuToggle{
    position: fixed;
    /* top: 10px; <-- DIESE ZEILE WIRD GE√ÑNDERT! */
    top: calc(10px + env(safe-area-inset-top)); /* <-- NEU: Verschiebt es um 10px + Safe-Area nach unten */
    right: 10px;
    z-index: 1500;             /* √ºber allen Panels */
    width: 42px; height: 42px;
    font-size: 1.4em;
    line-height: 42px;
    text-align: center;
    background:#555c66;
    color:#e0e0e0;
    border:none;
    border-radius:8px;
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.4);
}
#menuToggle:hover{background:#6a727f}

/* ---------------------------------------------------
    Responsive-Regel: Auf Viewports ‚â§ 768 px wird
    das Bedienfeld anfangs versteckt.
    --------------------------------------------------- */
@media (max-width:768px){
    #controls{display:none;}
    /* Mobile button sizing */
    button {
        min-width: 44px;
        min-height: 44px; /* Meet touch target guidelines */
    }
}
/* Canvas & Container: KEINE default-Gesten */
#container,
#voxelCanvas{
    touch-action: none;           /* iOS ‚â•13.4, Android, Desktop */
    -ms-touch-action: none;       /* altes Edge/IE */

    /* ‚Üê neu: sorge daf√ºr, dass die CSS-Border innen sitzt */
           box-sizing: border-box;
}

/* NEW: Accessibility - Screen Reader Only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

/* NEW: Touch Indicator */
.touch-indicator {
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(0, 150, 255, 0.3);
    transform: translate(-50%, -50%);
    pointer-events: none;
    animation: pulse 0.5s;
    display: none; /* Hidden by default */
    z-index: 2000; /* Ensure it's on top */
}


@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
    50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.2; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
}

/* NEW: Mobile-specific controls */
.mobile-only {
    display: none; /* Hidden by default */
    position: absolute;
    bottom: calc(20px + env(safe-area-inset-bottom)); /* Adjust for safe area */
    right: calc(20px + env(safe-area-inset-right)); /* Adjust for safe area */
    flex-direction: column;
    gap: 12px;
    z-index: 1000;
}

@media (max-width: 768px) {
    .mobile-only {
        display: flex; /* Show on mobile */
    }
    
    .mobile-btn {
        width: 60px;
        height: 60px;
        font-size: 24px;
        border-radius: 50%;
        background: rgba(90, 90, 120, 0.8);
        color: white;
        border: 2px solid white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(0,0,0,.4);
    }
    .mobile-btn:hover {
        background: rgba(110, 110, 140, 0.9);
    }
}
</style>
</head>
<body>
<button id="menuToggle" aria-label="Men√º umschalten">‚ò∞</button>

<div id="controls">
    <label for="grid-size-slider">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="90" value="10" aria-label="Gittergr√∂√üe anpassen">
    <span id="grid-size-display">10√ó10√ó10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe w√§hlen">
    <!-- NEW: Preset color inputs are now type="color" -->
    <input type="color" id="color-preset-1" class="color-preset-box" value="#8B4513" aria-label="Voreingestellte Farbe 1">
    <input type="color" id="color-preset-2" class="color-preset-box" value="#708237" aria-label="Voreingestellte Farbe 2">
    <input type="color" id="color-preset-3" class="color-preset-box" value="#6495ED" aria-label="Voreingestellte Farbe 3">

    <button id="modeToggle" aria-label="Modus wechseln">Modus wechseln</button><span id="current-mode">Modus: Hinzuf√ºgen</span>
    <button id="clearBtn" aria-label="Alles l√∂schen">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export">STL Export</button>
    <button id="exportObjBtn" aria-label="OBJ Export">OBJ Export</button>

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen">
    <span id="fly-speed-display">0.10</span>

    <label for="block-size-selector">Blockgr√∂√üe:</label>
    <button id="block-size-1x1" class="block-size-btn active" aria-label="Blockgr√∂√üe 1x1">1x1</button>
    <button id="block-size-4x4" class="block-size-btn" aria-label="Blockgr√∂√üe 4x4">4x4</button>
    <button id="block-size-8x8" class="block-size-btn" aria-label="Blockgr√∂√üe 8x8">8x8</button>
    <button id="block-size-10x10" class="block-size-btn" aria-label="Blockgr√∂√üe 10x10">10x10</button>

    <button id="helpToggleBtn" aria-label="Hilfe umschalten">Hilfe</button>
    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen">Zur Szene zur√ºckkehren</button>

    <!-- Image Template Controls -->
    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" style="display:none;" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <input type="file" id="imageFileInput" accept="image/*" style="display:none;">
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus ‚Üí Kamera drehen (Fly Mode)<br>
    WASD / E / Q ‚Üí bewegen<br>
    Linke MT ‚Üí Voxel hinzuf./l√∂schen/zeichnen<br>
    **Alt + Mausrad ‚Üí Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad ‚Üí Zeichenebene Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad ‚Üí Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel Aktion auf aktiver Ebene (Hinzuf√ºgen / L√∂schen / Zeichnen)**<br>
    **Control + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel ziehen zum Hinzuf√ºgen (Stapeln, nur im Hinzuf√ºgen-Modus)**<br>
    **NEU: Extrudieren (Modus "Extrudieren")**<br>
    **Linke MT gedr√ºckt + Maus ziehen auf existierendem Voxel ‚Üí Voxel extrudieren/verl√§ngern**<br>
    Mausrad ‚Üí Kamera Geschwindigkeit anpassen<br>
    **Tab ‚Üí Modus wechseln (Hinzuf√ºgen / L√∂schen / Zeichnen / Extrudieren)**<br>
    **1, 2, 3 ‚Üí Voreingestellte Farbe w√§hlen**<br>
    **Strg + Z ‚Üí R√ºckg√§ngig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z ‚Üí Wiederholen (Redo)**
    </div>
    <div id="touch-indicator" class="touch-indicator"></div>
    <input type="file" id="fileInput" accept=".json">
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt l√∂schen</h3>
        <p>M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h3 id="messageModalTitle">Nachricht</h3>
        <p id="messageModalText"></p>
        <div class="modal-buttons">
            <button id="messageModalCloseBtn" class="cancel">Schlie√üen</button>
        </div>
    </div>
</div>

<!-- NEW: Mobile controls -->
<div id="mobile-controls" class="mobile-only">
    <button class="mobile-btn" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera wechseln">üì∑</button>
    <button class="mobile-btn" id="mobile-extrude-mode" aria-label="Extrude Modus">‚ñ§</button> <!-- NEW BUTTON -->
    <button class="mobile-btn" id="mobile-assist" aria-label="Touch-Assist umschalten">üß≤</button>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>

<!-- VoxelShaperIO Library (embedded) -->
<script>
var VoxelShaperIO = (function() {
    // Helper to convert hex to RGBA for VOX palette
    function hexToRgba(hex) {
        if (!hex || hex.length !== 7) return 0x00000000; // Default to transparent black
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return (r << 24) | (g << 16) | (b << 8) | 0xFF; // RGBA
    }

    // Helper to convert RGBA to hex
    function rgbaToHex(rgba) {
        const r = (rgba >>> 24) & 0xFF;
        const g = (rgba >>> 16) & 0xFF;
        const b = (rgba >>> 8) & 0xFF;
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
    }

    class VoxModel {
        constructor(sizeX, sizeY, sizeZ, voxels = [], palette = new Uint32Array(256)) {
            this.sizeX = sizeX;
            this.sizeY = sizeY;
            this.sizeZ = sizeZ;
            this.voxels = voxels; // Array of {x, y, z, c} where c is palette index
            this.palette = palette; // Uint32Array of RGBA colors
            // Initialize default palette if not provided
            if (this.palette.every(val => val === 0)) {
                this.palette[1] = hexToRgba("#FF0000"); // Red
                this.palette[2] = hexToRgba("#00FF00"); // Green
                this.palette[3] = hexToRgba("#0000FF"); // Blue
                // ... add more default colors as needed
            }
        }
    }

    // Basic OBJ exporter (simplified, no materials)
    function voxToOBJ(voxModel, cubeSize = 1) {
        let obj = `# VoxelShaper OBJ Export\n`;
        let vertexCount = 0;

        voxModel.voxels.forEach(v => {
            const x = v.x * cubeSize;
            const y = v.y * cubeSize;
            const z = v.z * cubeSize;

            // Vertices for a cube
            obj += `v ${x} ${y} ${z}\n`;
            obj += `v ${x + cubeSize} ${y} ${z}\n`;
            obj += `v ${x + cubeSize} ${y + cubeSize} ${z}\n`;
            obj += `v ${x} ${y + cubeSize} ${z}\n`;
            obj += `v ${x} ${y} ${z + cubeSize}\n`;
            obj += `v ${x + cubeSize} ${y} ${z + cubeSize}\n`;
            obj += `v ${x + cubeSize} ${y + cubeSize} ${z + cubeSize}\n`;
            obj += `v ${x} ${y + cubeSize} ${z + cubeSize}\n`;

            // Faces (simplified, assuming no normals/texture coords for now)
            // Front face
            obj += `f ${vertexCount + 1} ${vertexCount + 2} ${vertexCount + 3} ${vertexCount + 4}\n`;
            // Back face
            obj += `f ${vertexCount + 5} ${vertexCount + 8} ${vertexCount + 7} ${vertexCount + 6}\n`;
            // Top face
            obj += `f ${vertexCount + 4} ${vertexCount + 3} ${vertexCount + 7} ${vertexCount + 8}\n`;
            // Bottom face
            obj += `f ${vertexCount + 1} ${vertexCount + 5} ${vertexCount + 6} ${vertexCount + 2}\n`;
            // Right face
            obj += `f ${vertexCount + 2} ${vertexCount + 6} ${vertexCount + 7} ${vertexCount + 3}\n`;
            // Left face
            obj += `f ${vertexCount + 5} ${vertexCount + 1} ${vertexCount + 4} ${vertexCount + 8}\n`;

            vertexCount += 8;
        });
        return obj;
    }

    // Helper for writing binary data
    class DataViewWriter {
        constructor(initialCapacity = 1024) {
            this.buffer = new ArrayBuffer(initialCapacity);
            this.dataView = new DataView(this.buffer);
            this.position = 0;
        }

        _ensureCapacity(bytesNeeded) {
            if (this.position + bytesNeeded > this.buffer.byteLength) {
                const newCapacity = Math.max(this.buffer.byteLength * 2, this.position + bytesNeeded);
                const newBuffer = new ArrayBuffer(newCapacity);
                new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
                this.buffer = newBuffer;
                this.dataView = new DataView(this.buffer);
            }
        }

        writeString(str) {
            this._ensureCapacity(str.length);
            for (let i = 0; i < str.length; i++) {
                this.dataView.setUint8(this.position++, str.charCodeAt(i));
            }
        }

        writeInt32(value) {
            this._ensureCapacity(4);
            this.dataView.setInt32(this.position, value, true); // Little-endian
            this.position += 4;
        }

        writeUint32(value) {
            this._ensureCapacity(4);
            this.dataView.setUint32(this.position, value, true); // Little-endian
            this.position += 4;
        }

        writeUint8(value) {
            this._ensureCapacity(1);
            this.dataView.setUint8(this.position++, value);
        }

        getBuffer() {
            return this.buffer.slice(0, this.position);
        }
    }

    // Helper for reading binary data
    class DataViewReader {
        constructor(arrayBuffer) {
            this.buffer = arrayBuffer;
            this.dataView = new DataView(arrayBuffer);
            this.position = 0;
        }

        readString(length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(this.dataView.getUint8(this.position++));
            }
            return str;
        }

        readInt32() {
            const value = this.dataView.getInt32(this.position, true); // Little-endian
            this.position += 4;
            return value;
        }

        readUint32() {
            const value = this.dataView.getUint32(this.position, true); // Little-endian
            this.position += 4;
            return value;
        }

        readUint8() {
            return this.dataView.getUint8(this.position++);
        }
    }

    function saveBlob(data, filename) {
        const blob = new Blob([data], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    return {
        VoxModel,
        voxToOBJ,
        saveBlob,
        rgbaToHex // Export rgbaToHex for debugging
    };
})();
</script>


<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;

/* ==============================================================
   FAST NUMERIC VOXEL-KEY  (max. GRID 0-1023 in jeder Achse)
   --------------------------------------------------------------
   ‚Äì 30-Bit-Packing:  x<<20 | y<<10 | z
   ‚Äì 100 % kollisionsfrei, >10√ó schneller als String-Hash,
     0 % GC-Druck
   ============================================================== */
// 10 Bit pro Achse  ‚Üí  0 ‚Ä¶ 1023
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;   // 0x3FF
const SHIFT_X  = VOX_BITS * 2;          // 20
const SHIFT_Y  = VOX_BITS;              // 10
// SHIFT_Z = 0

/**
 * Kombiniert (x,y,z) zu einem einzigen 30-Bit-Integer-Key.
 * - Alle Koordinaten m√ºssen 0 ‚â§ coord ‚â§ 1023 sein.
 */
function key(x, y, z) {
    // >>> 0 zwingt in den 32-Bit-Integer-Bereich
    return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0;
}

/**
 * Invers zu `key()` ‚Äì liefert [x, y, z].
 */
function parseKey(k) {
    return [
        (k >>> SHIFT_X) & VOX_MASK,
        (k >>> SHIFT_Y) & VOX_MASK,
        k & VOX_MASK
    ];
}

/* ---------- globale Variablen ---------- */
let isHoldDrawingActive = false;   // NEW: Verfolgt, ob ein Long-Press-Zeichnen aktiv ist
const LONG_PRESS_DELAY_MS = 500;   // NEW: Wartezeit (in Millisekunden) f√ºr Long-Press-Erkennung

/* ----------------------------------------------
   GLOBAL ‚Äì neue Hilfs-Variablen
---------------------------------------------- */
// --- Touch Gesture Constants ---
const PINCH_ZOOM_MULT = 40;     // Zoom-Geschwindigkeit ‚Üë
const TAP_DIST_TH = 10;         // max. Bewegung (px) f√ºr 'Tap'
const MOVE_PX = 10;             // ab hier gilt es als Drag
const DT_MS = 250;              // max. Abstand Taps (ms)
const PAN_PIX_TH = 10;          // ab px Bewegung ‚Üí Pan
const PINCH_REL_TH = 0.08;      // ‚â•8 % Distanz√§nderung ‚Üí Pinch
const ROTATE_SPEED_TOUCH = 0.004; // Drehgeschwindigkeit f√ºr Touch
const PAN_SPEED_TOUCH = 0.1;   // Pan-Geschwindigkeit f√ºr Touch

// --- Touch State ---
let activePointers = new Map(); // Map<pointerId, {x, y, pointerType}>
let gestureState = {
    type: 'none', // 'none', 'tap', 'pan', 'pinch', 'rotate'
    startDist: 0,
    startMid: { x: 0, y: 0 },
    lastMid: { x: 0, y: 0 },
    lastDist: 0,
    startTime: 0,
    initialPointerCount: 0,
};
let tapCandidate = null; // {x, y, time}
let doubleTapDragActive = false; // Flag for double-tap-and-drag drawing
let touchIndicator; // DOM element for visual feedback

let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;   // Globale Drehgeschwindigkeit f√ºr Maus

let euler; // Declare euler globally
const voxels = new Map();   // Map<number,{color}>
let cvs;
let containerDiv; // Reference to the container div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt f√ºr aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse f√ºr Alt+Mausrad

// NEW: Global object to store fixed plane parameters for drag operations
let fixedDragPlaneParams = { level: null, axis: null };

// Lade die Farbe aus dem Local Storage oder nutze Wei√ü als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
// Lade die Gittergr√∂√üe aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;

// Load other settings from local storage or set defaults
activeDrawingLevel.x = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
activeDrawingLevel.y = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
activeDrawingLevel.z = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';
let currentBlockSize = parseInt(localStorage.getItem('voxelEditorCurrentBlockSize') || '1'); // Declared here


// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgr√ºn (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen f√ºr Lichter, die Schatten werfen, um sie sp√§ter anpassen zu k√∂nnen
let mainDirectionalLight;
let fillDirectionalLight; // NEW: Zweites gerichtetes Licht
let hemisphereLight;      // NEW: Hemisph√§renlicht
let groundPlane;          // NEW: Bodenplatte

// Globale Variablen f√ºr Dragging-Status
let isShiftDragging = false;   // physische Shift-Taste

function shiftActive(){        // true, wenn Shift an
    return isShiftDragging;
}
let isControlDragging = false;
// Removed 'rotate' global variable as it's redundant with pointer lock
let isPointerLocked = false; // NEW: Track pointer lock status
let lastActionVoxelCoords = null; // NEW: Tracks the last voxel acted upon for drag drawing
let initialClickPos = null; // To differentiate click from drag
let firstMoveAfterLock = true; // NEW: Flag to ignore first movement after pointer lock

// Performance optimization: InstancedMesh
let instancedMesh; // Replaces voxelMesh and voxelGeometry
const dummy = new THREE.Object3D(); // For setting instance matrices
const tempColor = new THREE.Color(); // For setting instance colors

// NEU: Globale Variable f√ºr den Vorschau-Voxel
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // depthTest: false, damit er immer sichtbar ist
// NEW: Z-Fighting fix for preview voxel
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Initialize here
// ENDE NEU

// Modus-Enum
const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
    EXTRUDE: 'Extrudieren', // NEW
};
let currentMode = Modes.ADD; // Standardmodus

// Undo/Redo History
let history = []; // Declared globally
let historyPointer = -1; // Declared globally
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// NEW: Global variables for image template
let templateImageMesh = null;
// Updated templateImageData structure to store scaled dimensions
let templateImageData = null; // { src: base64, position: [], rotation: [], scale: [], locked: boolean, scaledWidth: number, scaledHeight: number }

// NEW: Mobile specific flags and variables
let isMobile = window.matchMedia('(max-width: 768px)').matches;
let touchAssistEnabled = false; // For magnetic targeting

// NEW: Extrude specific variables
let initialExtrudeVoxel = null; // Stores {gx, gy, gz} of the voxel clicked to start extrusion
let initialExtrudeColor = null; // Stores the color of the initialExtrudeVoxel
let isExtruding = false; // Flag for extrusion drag in progress
let voxelsAtExtrudeStart = null; // Map<key, {color}> snapshot of voxels before extrusion starts


/* ---------- Hilfsfunktionen (alle vor window.onload verschoben) ---------- */

function onResize() {
    // Use containerDiv for sizing
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    // NEW: Adjust pixel ratio for mobile performance
    if (isMobile) {
        ren.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
    } else {
        ren.setPixelRatio(window.devicePixelRatio);
    }
}

function handleGesture() {
    const pointers = [...activePointers.values()];
    if (pointers.length === 0) return;

    // --- Single-finger drag for camera rotation ---
    if (pointers.length === 1 && gestureState.type === 'rotate') {
        const p = pointers[0];
        const dx = p.x - gestureState.lastMid.x;
        const dy = p.y - gestureState.lastMid.y;

        euler.y -= dx * ROTATE_SPEED_TOUCH;
        euler.x -= dy * ROTATE_SPEED_TOUCH;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);

        gestureState.lastMid = { x: p.x, y: p.y };
        return;
    }

    // --- Multi-finger gestures (pan/pinch) ---
    if (pointers.length >= 2) {
        const [p0, p1] = pointers;
        const midX = (p0.x + p1.x) * 0.5;
        const midY = (p0.y + p1.y) * 0.5;
        const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

        // --- Determine gesture type on first move ---
        if (gestureState.type === 'none') {
            const dMid = Math.hypot(midX - gestureState.startMid.x, midY - gestureState.startMid.y);
            const relDelta = Math.abs(dist - gestureState.startDist) / gestureState.startDist;

            if (relDelta > PINCH_REL_TH) {
                gestureState.type = 'pinch';
            } else if (dMid > PAN_PIX_TH) {
                gestureState.type = 'pan';
            }
            return; // Wait for next move event to execute
        }

        // --- Execute Pinch (Zoom) ---
        else if (gestureState.type === 'pinch') {
            const scale = dist / gestureState.lastDist;
            const zoomDelta = (1 - scale) * PINCH_ZOOM_MULT * moveSpeed;
            cam.position.addScaledVector(
                cam.getWorldDirection(new THREE.Vector3()),
                zoomDelta
            );
            gestureState.lastDist = dist;
        }
        // --- Execute Pan (Strafe) ---
        else if (gestureState.type === 'pan') {
            const panFactor = PAN_SPEED_TOUCH * moveSpeed;
            const dx = (midX - gestureState.lastMid.x) * panFactor;
            const dy = (midY - gestureState.lastMid.y) * panFactor;

            const dir = cam.getWorldDirection(new THREE.Vector3());
            const right = new THREE.Vector3().crossVectors(dir, cam.up).normalize();
            // Use world up for vertical panning to avoid disorienting movement
            const upVec = new THREE.Vector3(0, 1, 0);

            cam.position.addScaledVector(right, -dx);
            cam.position.addScaledVector(upVec, dy);

            gestureState.lastMid = { x: midX, y: midY };
        }
    }
}


function releasePointer(id, eventType) { // Add eventType parameter
    activePointers.delete(id);

    // NEW: Handle three-finger swipe for undo/redo
    if (gestureState.initialPointerCount >= 3 && activePointers.size === 0 && initialClickPos && eventType.pointerType === 'touch') {
        const dx = eventType.clientX - initialClickPos.x;
        const absDx = Math.abs(dx);

        if (absDx > 50) { // Horizontal swipe threshold
            if (dx > 0) redo();
            else undo();
        }
    }

    if (activePointers.size < 2) {
        gestureState.type = 'none';
        if (activePointers.size === 1) {
            const last = [...activePointers.values()][0];
            gestureState.lastMid = { x: last.x, y: last.y };
        }
    }

    if (activePointers.size === 0) {
        doubleTapDragActive = false;
        lastActionVoxelCoords = null;
        touchIndicator.style.display = 'none';
        // Also reset fixed drag plane params for touch
        fixedDragPlaneParams = { level: null, axis: null };
        // NEW: Reset extrude state on touch release
        if (isExtruding) {
            isExtruding = false;
            initialExtrudeVoxel = null;
            initialExtrudeColor = null;
            voxelsAtExtrudeStart = null;
        }
    }
}

function rebuildHelpers() {
    if (typeof THREE === 'undefined') {
        console.error("THREE is not defined in rebuildHelpers. Cannot rebuild helpers.");
        return;
    }
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.z = Math.PI / 2;
        gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    switch (currentMode) {
        case Modes.ADD:
            currentMode = Modes.DELETE;
            break;
        case Modes.DELETE:
            currentMode = Modes.DRAW;
            break;
        case Modes.DRAW:
            currentMode = Modes.EXTRUDE; // NEW
            break;
        case Modes.EXTRUDE: // NEW
            currentMode = Modes.ADD;
            break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
    // When mode changes, reset fixed drag plane parameters
    fixedDragPlaneParams = { level: null, axis: null };
    // Also reset extrude state
    isExtruding = false;
    initialExtrudeVoxel = null;
    initialExtrudeColor = null;
    voxelsAtExtrudeStart = null;
    lastActionVoxelCoords = null; // Reset this too
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor); // Save as current selected color

        // Update active class for visual feedback
        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index; // Store which preset is active
    }
}

// New function to save current color to a preset slot
function savePresetColor(index, colorValue) { // Modified to accept colorValue
    if (index >= 0 && index < presetColors.length) {
        presetColors[index] = colorValue; // Update the array with the new color
        localStorage.setItem(`voxelPresetColor${index + 1}`, colorValue); // Persist to local storage
        // The input type="color" itself will update its background color
        // No need to call setActivePreset here, as it's a direct edit of the preset
        console.log(`Preset color ${index + 1} saved: ${colorValue}`);
    }
}

function addCommand(type, gx, gy, gz, oldColor = null, newColor = null, oldState = null, newState = null, commandData = null) {
    // Clear redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    history.push({ type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData });
    historyPointer++;

    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

function executeCommand(command, reverse = false) {
    const { type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData } = command;
    switch (type) {
        case 'add':
            if (reverse) {
                removeVoxel(gx, gy, gz, true); // true for fromHistory
            } else {
                addVoxel(gx, gy, gz, newColor, true); // true for fromHistory
            }
            break;
        case 'delete':
            if (reverse) {
                addVoxel(gx, gy, gz, oldColor, true); // Re-add with original color
            } else {
                removeVoxel(gx, gy, gz, true);
            }
            break;
        case 'recolor':
            if (reverse) {
                recolorVoxel(gx, gy, gz, oldColor, true);
            } else {
                recolorVoxel(gx, gy, gz, newColor, true);
            }
            break;
        case 'clearAll':
            if (reverse) {
                clearAllInternal(true); // Clear current state first without history
                // Restore old state by adding voxels back
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear directly without history
            }
            break;
        case 'fillLevel':
            if (reverse) {
                clearAllInternal(true); // Clear current state
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear current state
                newState.forEach(v => addVoxel(v.gx, gy, v.gz, v.color, true));
            }
            break;
        case 'resizeGrid':
            const targetGridSize = reverse ? commandData.oldGrid : commandData.newGrid;
            GRID = targetGridSize;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            clearAllInternal(true); // Clear current state without history
            const targetState = reverse ? oldState : newState;
            targetState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            break;
        case 'extrude': // NEW
            clearAllInternal(true); // Clear current state
            const stateToApply = reverse ? oldState : newState;
            stateToApply.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            break;
    }
    rebuildHelpers(); // Ensure helpers reflect the new state
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // true for reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // false for forward
    }
}

/**
 * Helper function to set instance color using Uint8Array.
 * This function is now called only from the animate loop during frustum culling.
 * @param {number} id - The instance ID (index in the visible buffer).
 * @param {string} hex - The color in hexadecimal string format (e.g., "#RRGGBB").
 */
function setInstanceColor(id, hex){
    const c = new THREE.Color(hex);
    // Ensure the buffer is a Uint8Array before setting values
    if (instancedMesh.instanceColor.array instanceof Uint8Array) {
        instancedMesh.instanceColor.setXYZ(
            id,
            (c.r * 255) | 0,
            (c.g * 255) | 0,
            (c.b * 255) | 0
        );
    } else {
        // Fallback for Float32Array (should not happen after patch)
        instancedMesh.instanceColor.setXYZ(id, c.r, c.g, c.b);
    }
}


// Function to add a voxel (updates the voxels Map, InstancedMesh is rebuilt in animate)
function addVoxel(gx, gy, gz, colorHex, fromHistory = false) {
    // Clamp coordinates to grid boundaries
    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    const k = key(gx, gy, gz);

    if (voxels.has(k)) {
        // Voxel already exists, check if color is different (recolor)
        const existingData = voxels.get(k);
        if (existingData.color !== colorHex) {
            if (!fromHistory) {
                addCommand('recolor', gx, gy, gz, existingData.color, colorHex);
            }
            voxels.set(k, { color: colorHex }); // Update color in map
        }
        // If color is the same, do nothing.
        return;
    } else {
        // New voxel, add to voxels map
        if (!fromHistory) {
            addCommand('add', gx, gy, gz, null, colorHex);
        }
        voxels.set(k, { color: colorHex }); // Store color in map
    }
}


// Function to remove a voxel (updates the voxels Map, InstancedMesh is rebuilt in animate)
function removeVoxel(gx, gy, gz, fromHistory = false) {
    const k = key(gx, gy, gz);
    if (!voxels.has(k)) {
        return; // Voxel does not exist
    }

    const removedVoxelData = voxels.get(k);

    if (!fromHistory) {
        addCommand('delete', gx, gy, gz, removedVoxelData.color, null);
    }

    voxels.delete(k); // Remove from map
}

// Function to recolor a voxel (updates the voxels Map, InstancedMesh is rebuilt in animate)
function recolorVoxel(gx, gy, gz, newColorHex, fromHistory = false) {
    const k = key(gx, gy, gz);
    if (!voxels.has(k)) {
        return; // Voxel does not exist
    }

    const existingData = voxels.get(k);
    if (existingData.color === newColorHex) {
        return; // Color is already the same
    }

    if (!fromHistory) {
        addCommand('recolor', gx, gy, gz, existingData.color, newColorHex);
    }

    voxels.set(k, { color: newColorHex }); // Update color in map
}

// NEW: Helper function to perform the actual voxel modification for a block
function performVoxelModification(baseX, baseY, baseZ, mode, color, blockSize = 1) {
    // Determine the two axes along which the block will extend
    let axis1, axis2;
    if (currentDrawingAxis === 'y') {
        axis1 = 'x';
        axis2 = 'z';
    } else if (currentDrawingAxis === 'x') {
        axis1 = 'y';
        axis2 = 'z';
    } else { // currentDrawingAxis === 'z'
        axis1 = 'x';
        axis2 = 'y';
    }

    for (let i = 0; i < blockSize; i++) {
        for (let j = 0; j < blockSize; j++) {
            let x = baseX, y = baseY, z = baseZ;

            // Adjust coordinates based on block size and current drawing axis
            if (axis1 === 'x') x = baseX + i;
            else if (axis1 === 'y') y = baseY + i;
            else if (axis1 === 'z') z = baseZ + i;

            if (axis2 === 'x') x = baseX + j;
            else if (axis2 === 'y') y = baseY + j;
            else if (axis2 === 'z') z = baseZ + j;

            // Ensure the fixed axis remains at its base coordinate
            if (currentDrawingAxis === 'x') x = baseX;
            else if (currentDrawingAxis === 'y') y = baseY;
            else if (currentDrawingAxis === 'z') z = baseZ;

            // Clamp coordinates to grid boundaries
            const clampedX = Math.max(0, Math.min(GRID - 1, x));
            const clampedY = Math.max(0, Math.min(GRID - 1, y));
            const clampedZ = Math.max(0, Math.min(GRID - 1, z));

            const voxelKey = key(clampedX, clampedY, clampedZ);
            const actualHasVoxel = voxels.has(voxelKey);

            switch (mode) {
                case Modes.ADD:
                    if (!actualHasVoxel) {
                        addVoxel(clampedX, clampedY, clampedZ, color);
                    }
                    break;
                case Modes.DELETE:
                    if (actualHasVoxel) {
                        removeVoxel(clampedX, clampedY, clampedZ);
                    }
                    break;
                case Modes.DRAW:
                    if (actualHasVoxel && voxels.get(voxelKey).color !== color) {
                        recolorVoxel(clampedX, clampedY, clampedZ, color);
                    }
                    break;
            }
        }
    }
}

// NEW: DDA (Digital Differential Analyzer) for 3D Line Drawing
function drawLineOfVoxels(start, end, mode, color, blockSize = 1) {
    let x = start.gx;
    let y = start.gy;
    let z = start.gz;
    const x2 = end.gx;
    const y2 = end.gy;
    const z2 = end.gz;

    const dx = x2 - x;
    const dy = y2 - y;
    const dz = z2 - z;

    const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

    if (steps === 0) {
        performVoxelModification(x, y, z, mode, color, blockSize);
        return;
    }

    const x_inc = dx / steps;
    const y_inc = dy / steps;
    const z_inc = dz / steps;

    for (let i = 0; i <= steps; i++) {
        // Apply modification for the base of the block
        performVoxelModification(Math.round(x), Math.round(y), Math.round(z), mode, color, blockSize);
        x += x_inc;
        y += y_inc;
        z += z_inc;
    }
}


// NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Voxels
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            // Dispose old geometry
            if (previewVoxelMesh.geometry) {
                previewVoxelMesh.geometry.dispose();
            }

            const blockDimX = (currentDrawingAxis === 'y' || currentDrawingAxis === 'z') ? currentBlockSize * VS : VS;
            const blockDimY = (currentDrawingAxis === 'x' || currentDrawingAxis === 'z') ? currentBlockSize * VS : VS;
            const blockDimZ = (currentDrawingAxis === 'x' || currentDrawingAxis === 'y') ? currentBlockSize * VS : VS;

            const tempGeometry = new THREE.BoxGeometry(blockDimX, blockDimY, blockDimZ);
            previewVoxelMesh.geometry = tempGeometry;

            // Calculate the center of the block relative to its (x,y,z) base corner
            const centerX = x * VS + blockDimX / 2;
            const centerY = y * VS + blockDimY / 2;
            const centerZ = z * VS + blockDimZ / 2;

            previewVoxelMesh.position.set(centerX, centerY, centerZ);

            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor); // Vorschau-Farbe an aktuelle Farbe anpassen
            // Optional: Passe die Opazit√§t basierend auf dem Modus an
            if (currentMode === Modes.DELETE) {
                previewVoxelMaterial.opacity = 0.2; // Weniger sichtbar beim L√∂schen
            } else {
                previewVoxelMaterial.opacity = 0.5; // Standard Opazit√§t
            }
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}
// ENDE NEU

// NEW helper function to set the fixed drag plane parameters
function setFixedDragPlane(clientX, clientY, mode) {
    // Only set fixed drag plane for ADD mode
    if (mode !== Modes.ADD) {
        fixedDragPlaneParams = { level: null, axis: null };
        return;
    }

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);
    // Raycast against the instancedMesh for hit detection
    const objectsToIntersect = [instancedMesh];
    const intersects = raycaster.intersectObjects(objectsToIntersect);

    if (intersects.length > 0) {
        const hit = intersects[0];
        // The face normal is in world coordinates for the hit face
        const hitNormal = hit.face.normal.clone();
        
        // BUGFIX: Move the intersection point slightly *inside* the hit voxel
        // This ensures that flooring the coordinate gives the coordinate of the HIT voxel, not the next one.
        const hitPoint = hit.point.clone().sub(hitNormal.multiplyScalar(0.01));

        // Convert world position to grid coordinates
        const hitVoxelX = Math.floor(hitPoint.x / VS);
        const hitVoxelY = Math.floor(hitPoint.y / VS);
        const hitVoxelZ = Math.floor(hitPoint.z / VS);

        let level, axis;

        // The normal needs to be reset for axis detection after being used for the offset calculation
        const axisNormal = hit.face.normal;
        const absNx = Math.abs(axisNormal.x);
        const absNy = Math.abs(axisNormal.y);
        const absNz = Math.abs(axisNormal.z);

        // When adding, we want to place on the *next* layer relative to the hit voxel
        if (absNy > absNx && absNy > absNz) { 
            axis = 'y';
            level = hitVoxelY + Math.round(axisNormal.y);
        } else if (absNx > absNy && absNx > absNz) {
            axis = 'x';
            level = hitVoxelX + Math.round(axisNormal.x);
        } else {
            axis = 'z';
            level = hitVoxelZ + Math.round(axisNormal.z);
        }
        fixedDragPlaneParams.level = level;
        fixedDragPlaneParams.axis = axis;
    } else {
        // If no voxel is hit, default to the current active drawing level and axis
        fixedDragPlaneParams.axis = currentDrawingAxis;
        fixedDragPlaneParams.level = activeDrawingLevel[currentDrawingAxis];
    }
}

// NEW: Magnetic targeting helper for touch assist
function getNearestVoxelCenter(intersectionPoint) {
    const gx = Math.floor(intersectionPoint.x / VS);
    const gy = Math.floor(intersectionPoint.y / VS);
    const gz = Math.floor(intersectionPoint.z / VS);

    // Calculate the center of the grid cell
    return new THREE.Vector3(
        gx * VS + HALF,
        gy * VS + HALF,
        gz * VS + HALF
    );
}


// Modified calculateTargetVoxelCoords to use fixedDragPlaneParams and touchAssist
function calculateTargetVoxelCoords(clientX, clientY, mode, isDragging, isStackingAdd, pointerType) { // Added pointerType
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    const objectsToIntersect = [instancedMesh];
    let targetVoxelCoords = null;
    let intersectionPoint = new THREE.Vector3();

    // BUGFIX for Drag-Drawing: Use the fixed plane ONLY for ADD mode when dragging.
    if (isDragging && mode === Modes.ADD && fixedDragPlaneParams.level !== null && fixedDragPlaneParams.axis !== null) {
        let planeNormal = new THREE.Vector3();
        if (fixedDragPlaneParams.axis === 'y') planeNormal.set(0, 1, 0);
        else if (fixedDragPlaneParams.axis === 'x') planeNormal.set(1, 0, 0);
        else planeNormal.set(0, 0, 1);
        
        const drawingPlane = new THREE.Plane(planeNormal, -(fixedDragPlaneParams.level * VS));

        if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // Force the coordinate on the fixed axis to be the fixed level
            if (fixedDragPlaneParams.axis === 'y') gy = fixedDragPlaneParams.level;
            else if (fixedDragPlaneParams.axis === 'x') gx = fixedDragPlaneParams.level;
            else if (fixedDragPlaneParams.axis === 'z') gz = fixedDragPlaneParams.level;

            targetVoxelCoords = { gx, gy, gz };
        } else {
            return null; // No intersection with fixed plane
        }
    }
    // Logic for single clicks or initial point of drag, or for DELETE/DRAW/EXTRUDE modes when dragging
    else {
        const intersects = raycaster.intersectObjects(objectsToIntersect);
        if (intersects.length > 0) {
            const hit = intersects[0];
            const hitNormal = hit.face.normal.clone();
            intersectionPoint.copy(hit.point);

            // BUGFIX: Move point slightly inside the hit voxel to get correct base coordinates
            const hitPointInside = hit.point.clone().sub(hitNormal.multiplyScalar(0.01));
            const hitVoxelX = Math.floor(hitPointInside.x / VS);
            const hitVoxelY = Math.floor(hitPointInside.y / VS);
            const hitVoxelZ = Math.floor(hitPointInside.z / VS);

            if (mode === Modes.ADD) {
                // Place on the face normal to the hit voxel
                targetVoxelCoords = {
                    gx: hitVoxelX + Math.round(hit.face.normal.x),
                    gy: hitVoxelY + Math.round(hit.face.normal.y),
                    gz: hitVoxelZ + Math.round(hit.face.normal.z)
                };
            } else { // DELETE, DRAW, or EXTRUDE
                // Target the hit voxel itself
                targetVoxelCoords = { gx: hitVoxelX, gy: hitVoxelY, gz: hitVoxelZ };
            }
        } else if (mode === Modes.ADD) {
            // Fallback for ADD when nothing is hit, use activeDrawingLevel
            let planeNormal = new THREE.Vector3();
            if (currentDrawingAxis === 'y') planeNormal.set(0, 1, 0);
            else if (currentDrawingAxis === 'x') planeNormal.set(1, 0, 0);
            else planeNormal.set(0, 0, 1);
            
            const drawingPlane = new THREE.Plane(planeNormal, -(activeDrawingLevel[currentDrawingAxis] * VS));

            if (raycaster.ray.intersectPlane(drawingPlane, intersectionPoint)) {
                let gx = Math.floor(intersectionPoint.x / VS);
                let gy = Math.floor(intersectionPoint.y / VS);
                let gz = Math.floor(intersectionPoint.z / VS);

                if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

                targetVoxelCoords = { gx, gy, gz };
            } else {
                return null;
            }
        }
    }

    if (targetVoxelCoords) {
        // Apply touch assist (magnetic targeting) if enabled for touch devices
        if (pointerType === 'touch' && touchAssistEnabled && intersectionPoint) {
            const snappedPos = getNearestVoxelCenter(intersectionPoint);
            targetVoxelCoords.gx = Math.round(snappedPos.x / VS - HALF);
            targetVoxelCoords.gy = Math.round(snappedPos.y / VS - HALF);
            targetVoxelCoords.gz = Math.round(snappedPos.z / VS - HALF);
        }

        // Clamp coordinates to grid boundaries
        targetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gx));
        targetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gy));
        targetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gz));
        return targetVoxelCoords;
    }
    return null;
}

function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        addCommand('clearAll', null, null, null, null, null, oldState, []);
    }
    voxels.clear();
    rebuildHelpers(); // Ensure helpers are reset or updated appropriately
}

function clearAll() {
    clearAllInternal(false); // User initiated clear, adds to history
}


function fillActiveLevel() {
    // Capture the current state before the fill for undo/redo
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    // Clear existing voxels on the plane for fill, without adding to history
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x; // Use x as y-coordinate for horizontal plane
                gz = z; // Use z as z-coordinate
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z; // Use z as y-coordinate for horizontal plane
                gz = activeDrawingLevel.z;
            }
            const k = key(gx, gy, gz);
            if (voxels.has(k)) {
                voxelsToRemove.push(k);
            }
        }
    }
    // Remove all existing voxels on the plane
    voxelsToRemove.forEach(k => {
        const [gx, gy, gz] = parseKey(k);
        removeVoxel(gx, gy, gz, true); // true for fromHistory, to avoid adding individual delete commands
    });


    // Add new voxels for the fill
    const newState = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x;
                gz = z;
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z;
                gz = activeDrawingLevel.z;
            }
            addVoxel(gx, gy, gz, currentColor, true); // true for fromHistory, to avoid adding individual add commands
            newState.push({ gx, gy, gz, color: currentColor });
        }
    }

    // Add a single command for the entire fill operation
    addCommand('fillLevel', null, null, null, null, null, oldState, newState);
}


// With InstancedMesh, this function primarily signals updates.
// The actual matrix and color updates happen in addVoxel, removeVoxel, recolorVoxel.
// With frustum culling, this function is less relevant as animate loop rebuilds.
function updateVoxelGeometry() {
    // This function is now effectively a no-op as the animate loop handles updates.
}


function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => { // k is now a number
        const [gx,gy,gz] = parseKey(k); // Parse the numeric key back to coords
        data[`${gx},${gy},${gz}`] = value.color; // Save as string key
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        moveSpeed: moveSpeed, // Save fly speed
        currentBlockSize: currentBlockSize, // Save current block size
        templateImageData: templateImageData // NEW: Save template image data
    };

    const projectData = {
        voxels: data,
        settings: settings
    };

    const json = JSON.stringify(projectData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function resetToDefaultProject() {
    clearAllInternal(true); // Clear everything without adding to history
    GRID = 10;
    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    localStorage.setItem('voxelEditorGridSize', GRID);

    currentColor = '#ffffff';
    document.getElementById('color-picker').value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);

    activeDrawingLevel = { x: 0, y: 0, z: 0 };
    currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);

    moveSpeed = 0.1;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

    currentBlockSize = 1;
    setBlockSize(currentBlockSize);
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);

    // Reset preset colors to defaults
    presetColors[0] = '#8B4513';
    presetColors[1] = '#708237';
    presetColors[2] = '#6495ED';
    localStorage.setItem('voxelPresetColor1', presetColors[0]);
    localStorage.setItem('voxelPresetColor2', presetColors[1]);
    localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => {
        // For input type="color", setting value directly updates its visual
        box.value = presetColors[i];
        box.classList.remove('active');
    });
    activePresetIndex = -1;

    removeImageTemplate(true); // Remove template without history logging

    history.length = 0;
    historyPointer = -1;

    rebuildHelpers();
    resetCameraPosition();
    console.log('Project reset to default state.');
}


function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            const loadedVoxels = projectData.voxels;
            const loadedSettings = projectData.settings;

            // Clear current state and history before loading new project
            clearAllInternal(true); // Clear without adding to history

            // Remove existing template image if any
            removeImageTemplate(true); // true to prevent history logging for this internal operation

            // Load settings first to get the correct GRID size
            if (loadedSettings) {
                GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
                localStorage.setItem('voxelEditorGridSize', GRID); // Ensure it's saved back
                console.log("Loaded GRID size from JSON:", GRID);
            } else {
                console.warn("No settings found in JSON, using default GRID size.");
            }

            // Dispose old InstancedMesh if it exists and re-initialize
            if (instancedMesh) {
                scene.remove(instancedMesh);
                instancedMesh.geometry.dispose();
                instancedMesh.material.dispose();
                instancedMesh = null; // Ensure reference is cleared
            }

            // Re-initialize InstancedMesh with potentially new GRID size
            const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
            let meshMaterial = new THREE.MeshLambertMaterial();
            
            meshMaterial.onBeforeCompile = (shader) => {
                shader.vertexShader = `
                    varying vec3 vInstanceColor;
                    ${shader.vertexShader}
                `.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                );
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <color_vertex>',
                    `
                    #include <color_vertex>
                    #ifdef USE_INSTANCING_COLOR
                        vInstanceColor = instanceColor;
                    #else
                        vInstanceColor = vec3(1.0);
                    #endif
                    `
                );
                shader.fragmentShader = `
                    varying vec3 vInstanceColor;
                    ${shader.fragmentShader}
                `.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
                );
            };

            const maxVoxelsForLoadedGrid = GRID * GRID * GRID; // Max instances based on loaded GRID
            instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxVoxelsForLoadedGrid);
            
            if (!instancedMesh.instanceMatrix) {
                instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 16), 16);
                instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix);
            }
            const colBuf = new Uint8Array(maxVoxelsForLoadedGrid * 3);
            instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colBuf, 3, true);
            instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor);

            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            scene.add(instancedMesh);
            instancedMesh.count = 0; // Reset instance count


            // Load voxels into the map
            for (const k in loadedVoxels) {
                const colorValue = loadedVoxels[k];
                const parts = k.split(',').map(Number); 
                if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                    const gx = parts[0];
                    const gy = parts[1];
                    const gz = parts[2];

                    // Only add if within the bounds of the newly loaded GRID size
                    if (gx < GRID && gy < GRID && gz < GRID) {
                        voxels.set(key(gx, gy, gz), { color: colorValue }); // Store color in map
                    }
                }
            }

            // Continue loading other settings after GRID is set and InstancedMesh is re-initialized
            if (loadedSettings) {
                if (loadedSettings.cameraPosition) {
                    cam.position.fromArray(loadedSettings.cameraPosition);
                }
                if (loadedSettings.cameraQuaternion) {
                    cam.quaternion.fromArray(loadedSettings.cameraQuaternion);
                    euler.setFromQuaternion(cam.quaternion, 'YXZ');
                }
                if (loadedSettings.activeDrawingLevel) {
                    activeDrawingLevel = { ...loadedSettings.activeDrawingLevel };
                    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
                }
                if (loadedSettings.currentDrawingAxis) {
                    currentDrawingAxis = loadedSettings.currentDrawingAxis;
                    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
                }
                updateGridHelperPosition();

                currentColor = loadedSettings.currentColor || '#ffffff';
                document.getElementById('color-picker').value = currentColor;

                if (loadedSettings.presetColors) {
                    for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                        presetColors[i] = loadedSettings.presetColors[i];
                        // For input type="color", set the value
                        document.getElementById(`color-preset-${i + 1}`).value = presetColors[i];
                        localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                    }
                }
                setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);

                if (loadedSettings.moveSpeed !== undefined) {
                    moveSpeed = loadedSettings.moveSpeed;
                    document.getElementById('fly-speed-slider').value = moveSpeed;
                    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                    localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
                }

                if (loadedSettings.currentBlockSize !== undefined) {
                    setBlockSize(loadedSettings.currentBlockSize);
                    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
                }

                if (loadedSettings.templateImageData) {
                    templateImageData = loadedSettings.templateImageData;
                    console.log("Loading template image data:", templateImageData);
                    const loader = new THREE.TextureLoader();
                    loader.load(templateImageData.src, (texture) => {
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                        const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                        if (templateImageMesh) {
                            scene.remove(templateImageMesh);
                            templateImageMesh.geometry.dispose();
                            templateImageMesh.material.dispose();
                        }
                        templateImageMesh = new THREE.Mesh(geometry, material);
                        templateImageMesh.position.fromArray(templateImageData.position);
                        templateImageMesh.rotation.fromArray(templateImageData.rotation);
                        templateImageMesh.scale.fromArray(templateImageData.scale);
                        templateImageMesh.renderOrder = -1;
                        scene.add(templateImageMesh);
                        document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
                    }, undefined, (err) => {
                        console.error('Error loading template image texture:', err);
                        templateImageMesh = null;
                        templateImageData = null;
                        document.getElementById('removeImageTemplateBtn').style.display = 'none';
                    });
                }
            }

            history.length = 0;
            historyPointer = -1;

            console.log('Project loaded successfully.');
            resetCameraPosition();
        } catch (error) {
            console.error('Error loading JSON file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige Voxel-Projekt-JSON-Datei handelt. Fehler: ' + error.message);
            resetToDefaultProject(); // Reset to safe state on error
        }
    };
    reader.readAsText(file);
}


function exportSTL() {
    if (voxels.size === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const geometriesToMerge = [];
    const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    const tempMatrix = new THREE.Matrix4();
    const tempColorExport = new THREE.Color();

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        dummy.updateMatrix();
        tempMatrix.copy(dummy.matrix); // Use dummy for matrix calculation

        tempColorExport.set(data.color);

        const instanceGeometry = tempBoxGeometry.clone();
        instanceGeometry.applyMatrix4(tempMatrix);

        const vertexColorArray = [];
        for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
            vertexColorArray.push(tempColorExport.r, tempColorExport.g, tempColorExport.b);
        }
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColorArray, 3));
        geometriesToMerge.push(instanceGeometry);
    });

    let mergedGeometry;
    if (geometriesToMerge.length > 0) {
        mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true);
    } else {
        mergedGeometry = new THREE.BufferGeometry();
    }

    const tempMesh = new THREE.Mesh(mergedGeometry, instancedMesh.material);

    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh);

    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    tempBoxGeometry.dispose();
    if (mergedGeometry) mergedGeometry.dispose();
    showMessageModal('Export erfolgreich', 'STL-Modell erfolgreich exportiert!');
}

// NEW: Function to export OBJ
function exportOBJ() {
    if (voxels.size === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const voxelsToExport = [];
    let maxX = 0, maxY = 0, maxZ = 0;

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        voxelsToExport.push({ x, y, z, c: 1 }); // VoxelShaperIO.voxToOBJ doesn't use color index directly for OBJ
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    const objText = VoxelShaperIO.voxToOBJ(voxModel, VS); // Use VS (1) as cubeSize

    VoxelShaperIO.saveBlob(objText, 'voxel_model.obj');
    showMessageModal('Export erfolgreich', 'OBJ-Modell erfolgreich exportiert!');
}

// NEW: Generic message modal
function showMessageModal(title, message) {
    const modal = document.getElementById('messageModal');
    document.getElementById('messageModalTitle').textContent = title;
    document.getElementById('messageModalText').textContent = message;
    modal.style.display = 'flex';
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) {
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
    }
}

// NEW: Function to load image as template
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

// NEW: Handle image file selection
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;

        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set(
                (GRID * VS) / 2,
                (GRID * VS) / 2,
                -0.5 * VS
            );
            templateImageMesh.rotation.y = Math.PI;

            templateImageMesh.renderOrder = -1;
            scene.add(templateImageMesh);

            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1], 
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            console.log("Saving template image data:", templateImageData);

            document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
        };
        img.src = base64Image;
    };
    reader.readAsDataURL(file);
}

// NEW: Function to remove the image template
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh);
        templateImageMesh.geometry.dispose();
        templateImageMesh.material.dispose();
        templateImageMesh = null;
        templateImageData = null;
        document.getElementById('removeImageTemplateBtn').style.display = 'none';
        if (!fromLoad) {
            // No history command needed for removal, as it's part of the project state
            // and handled by save/load.
        }
    }
}

// NEW: Function to update the ground plane size based on current GRID
function updateGroundPlaneSize() {
    // Remove the ground plane if it exists
    if (groundPlane) {
        scene.remove(groundPlane);
        groundPlane.geometry.dispose();
        groundPlane.material.dispose();
        groundPlane = null;
    }
}


/* ---------- Initialisierung bei Fensterladung ---------- */
window.onload = function() {
    cvs = document.getElementById('voxelCanvas');
    containerDiv = document.getElementById('container');
    touchIndicator = document.getElementById('touch-indicator');

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);

    // Camera
    const aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    resetCameraPosition();
    euler = new THREE.Euler(0, 0, 0, 'YXZ');

    // Renderer
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    // NEW: Set pixel ratio based on device and mobile flag
    isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (isMobile) {
        ren.setPixelRatio(Math.min(1.5, window.devicePixelRatio)); // Cap pixel ratio for mobile performance
    } else {
        ren.setPixelRatio(window.devicePixelRatio);
    }
    ren.shadowMap.enabled = true;
    ren.shadowMap.type = THREE.PCFSoftShadowMap;
  
    // Lights
    const ambientLight = new THREE.AmbientLight(0x202020);
    scene.add(ambientLight);

    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    mainDirectionalLight.position.set(10, 20, 15);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 2048;
    mainDirectionalLight.shadow.mapSize.height = 2048;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    mainDirectionalLight.shadow.camera.left = -30;
    mainDirectionalLight.shadow.camera.right = 30;
    mainDirectionalLight.shadow.camera.top = 30;
    mainDirectionalLight.shadow.camera.bottom = -30;
    mainDirectionalLight.shadow.bias = -0.0005;
    mainDirectionalLight.shadow.normalBias = 0.02;
    scene.add(mainDirectionalLight);

    fillDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillDirectionalLight.position.set(-10, 10, -15);
    scene.add(fillDirectionalLight);

    hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemisphereLight);

    updateGroundPlaneSize();

    // Initialize InstancedMesh
    const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
    let meshMaterial = new THREE.MeshLambertMaterial();
    
    meshMaterial.onBeforeCompile = (shader) => {
        shader.vertexShader = `
            varying vec3 vInstanceColor;
            ${shader.vertexShader}
        `.replace(
            'void main() {',
            `
            void main() {
            `
        );
        shader.vertexShader = shader.vertexShader.replace(
            '#include <color_vertex>',
            `
            #include <color_vertex>
            #ifdef USE_INSTANCING_COLOR
                vInstanceColor = instanceColor;
            #else
                vInstanceColor = vec3(1.0);
            #endif
            `
        );
        shader.fragmentShader = `
            varying vec3 vInstanceColor;
            ${shader.fragmentShader}
        `.replace(
            'vec4 diffuseColor = vec4( diffuse, opacity );',
            'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
        );
    };

    const initialMaxVoxels = 90 * 90 * 90; 
    instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, initialMaxVoxels);
    
    if (!instancedMesh.instanceMatrix) {
        instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(initialMaxVoxels * 16), 16);
        instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix);
    }
    const colBuf = new Uint8Array(initialMaxVoxels * 3);
    instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colBuf, 3, true);
    instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor);


    instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
    instancedMesh.castShadow = true;
    instancedMesh.receiveShadow = true;
    scene.add(instancedMesh);
    instancedMesh.count = 0;

    scene.add(previewVoxelMesh);
    updatePreviewVoxel(0,0,0,false);

    // Helpers
    rebuildHelpers();

    // Event Listeners
    window.addEventListener('resize', onResize);
    containerDiv.addEventListener('pointerdown', onPointerDown);
    containerDiv.addEventListener('pointermove', onPointerMove);
    containerDiv.addEventListener('pointerup', onPointerUp);
    containerDiv.addEventListener('pointercancel', onPointerUp);
    containerDiv.addEventListener('pointerleave', onPointerLeave);
    containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
    // NEW: Prevent mobile scrolling on touchmove if pointers are active
    containerDiv.addEventListener('touchmove', (e) => {
        if (activePointers.size > 0) e.preventDefault();
    }, { passive: false });


    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('pointerlockchange', onPointerLockChange, false);


    // Prevent context menu on right click
    containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

    // UI event listeners
    document.getElementById('grid-size-slider').addEventListener('input', (e) => {
        const oldGrid = GRID;
        GRID = parseInt(e.target.value);
        document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        localStorage.setItem('voxelEditorGridSize', GRID);
        console.log("Grid size changed to:", GRID);
        console.log("Saving 'voxelEditorGridSize' to localStorage:", localStorage.getItem('voxelEditorGridSize'));

        const oldVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        // Clear voxels outside new bounds and update InstancedMesh
        const voxelsToKeep = new Map();
        voxels.forEach((data, k) => {
            const [gx, gy, gz] = parseKey(k);
            if (gx < GRID && gy < GRID && gz < GRID) {
                voxelsToKeep.set(k, data);
            }
        });

        // Rebuild voxels map with only kept voxels
        voxels.clear();
        voxelsToKeep.forEach((data, k) => {
            voxels.set(k, data);
        });
        
        const newVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        addCommand('resizeGrid', null, null, null, null, null, oldVoxelState, newVoxelState, { oldGrid: oldGrid, newGrid: GRID });

        rebuildHelpers();
        resetCameraPosition();
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    });

    presetBoxes = [
        document.getElementById('color-preset-1'),
        document.getElementById('color-preset-2'),
        document.getElementById('color-preset-3')
    ];
    presetColors.forEach((color, index) => {
            const box = presetBoxes[index];
            box.value = color; // Set initial value for input type="color"
            box.addEventListener('click', (e) => {
                // Clicking the preset box sets the main color picker to its color
                // No modifier key needed for saving anymore, as it's a direct input
                setActivePreset(index);
            });
            box.addEventListener('input', (e) => {
                // Changing the color via the preset's own color picker
                savePresetColor(index, e.target.value);
            });
        });
    if (activePresetIndex !== -1) {
        setActivePreset(activePresetIndex);
    } else {
        document.getElementById('color-picker').value = currentColor;
    }


    document.getElementById('modeToggle').addEventListener('click', cycleMode);
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'flex';
    });
    document.getElementById('saveAndClearBtn').addEventListener('click', () => {
        saveJSON();
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => {
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('cancelClearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'none';
    });

    document.getElementById('messageModalCloseBtn').addEventListener('click', () => {
        document.getElementById('messageModal').style.display = 'none';
    });


    document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
    document.getElementById('saveBtn').addEventListener('click', saveJSON);
    document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', loadJSON);
    document.getElementById('exportStlBtn').addEventListener('click', exportSTL);

    document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);

    document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
        moveSpeed = parseFloat(e.target.value);
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    });

    // Block Size buttons
    document.getElementById('block-size-1x1').addEventListener('click', () => setBlockSize(1));
    document.getElementById('block-size-4x4').addEventListener('click', () => setBlockSize(4));
    document.getElementById('block-size-8x8').addEventListener('click', () => setBlockSize(8));
    document.getElementById('block-size-10x10').addEventListener('click', () => setBlockSize(10));

    // Info Box (Help) Toggle Logic
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');
    let showInfoBox = localStorage.getItem('showInfoBox') === 'true';

    function updateInfoBoxVisibility() {
        infoBox.style.display = showInfoBox ? 'block' : 'none';
        helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
        localStorage.setItem('showInfoBox', showInfoBox);
    }
    helpToggleBtn.addEventListener('click', () => {
        showInfoBox = !showInfoBox;
        updateInfoBoxVisibility();
    });
    updateInfoBoxVisibility();

    document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);

    document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
    document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
    document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);


    // Hamburger menu toggle for mobile
    const menuToggle = document.getElementById('menuToggle');
    menuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        if (controlsPanel.style.display === 'none' || controlsPanel.style.display === '') {
            controlsPanel.style.display = 'flex';
        } else {
            controlsPanel.style.display = 'none';
        }
    });

    // Check media query on load and resize
    const mediaQuery = window.matchMedia('(max-width: 768px)');
    function handleMediaQueryChange(e) {
        isMobile = e.matches; // Update isMobile flag
        const controlsPanel = document.getElementById('controls');
        if (e.matches) {
            controlsPanel.style.display = 'none';
            menuToggle.style.display = 'block';
        } else {
            controlsPanel.style.display = 'flex';
            menuToggle.style.display = 'none';
        }
        onResize(); // Also call onResize to adjust pixel ratio
    }
    mediaQuery.addListener(handleMediaQueryChange);
    handleMediaQueryChange(mediaQuery);

    // NEW: Mobile controls event listeners
    document.getElementById('mobile-undo').addEventListener('click', undo);
    document.getElementById('mobile-redo').addEventListener('click', redo);
    document.getElementById('mobile-save').addEventListener('click', saveJSON);
    document.getElementById('mobile-camera').addEventListener('click', () => {
        // Toggle between camera modes or reset camera view
        resetCameraPosition(); // Simple reset for now
    });
    // NEW: Mobile Extrude Mode button listener
    document.getElementById('mobile-extrude-mode').addEventListener('click', () => {
        currentMode = Modes.EXTRUDE;
        document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
        fixedDragPlaneParams = { level: null, axis: null }; // Reset fixed plane
        // Optionally, provide visual feedback for active mode on mobile buttons
    });
    document.getElementById('mobile-assist').addEventListener('click', () => {
        touchAssistEnabled = !touchAssistEnabled;
        const assistButton = document.getElementById('mobile-assist');
        assistButton.style.borderColor = touchAssistEnabled ? '#90caf9' : 'white';
        showMessageModal('Touch Assist', `Magnetisches Zielen ist jetzt ${touchAssistEnabled ? 'aktiviert' : 'deaktiviert'}.`);
    });

    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    document.getElementById('color-picker').value = currentColor;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    setBlockSize(currentBlockSize);

    animate();
}; // END window.onload

/* ---------- Animations-Loop ---------- */
const frustum = new THREE.Frustum();
const tempCameraMatrix = new THREE.Matrix4();
const tempVoxelPosition = new THREE.Vector3(); // Re-use for performance

function animate() {
    requestAnimationFrame(animate);

    // Continuous keyboard movement when pointer is locked (fly mode)
    if (isPointerLocked) {
        const forward = cam.getWorldDirection(new THREE.Vector3());
        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();
        const up = new THREE.Vector3(0, 1, 0); // World up direction

        const currentMoveSpeed = moveSpeed * 5;

        if (keyboard['w']) cam.position.addScaledVector(forward, currentMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(forward, -currentMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(right, -currentMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(right, currentMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(up, -currentMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(up, currentMoveSpeed);
    }

    // Frustum Culling: Rebuild InstancedMesh buffers with visible voxels
    cam.updateMatrixWorld(); // Ensure camera matrices are up-to-date
    tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);

    let visibleInstanceIndex = 0;
    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        tempVoxelPosition.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);

        // Check if the voxel's bounding box is in the frustum
        if (frustum.containsPoint(tempVoxelPosition)) {
            // Set matrix for the visible instance
            dummy.position.copy(tempVoxelPosition);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(visibleInstanceIndex, dummy.matrix);

            // Set color for the visible instance
            setInstanceColor(visibleInstanceIndex, data.color);

            visibleInstanceIndex++;
        }
    });

    instancedMesh.count = visibleInstanceIndex; // Update total visible instances
    instancedMesh.instanceMatrix.needsUpdate = true; // Mark buffers for update
    instancedMesh.instanceColor.needsUpdate = true; // Mark buffers for update

    ren.render(scene, cam);
}

/* ---------- Mouse / Pointer Input ---------- */
let pointerIsDown = false;
let lastX, lastY;
let suppressNextTap = false; // NEW: To prevent tap after a drag gesture

function onPointerDown(e) {
    // Prevent context menu for all right-clicks
    if (e.button === 2) {
        e.preventDefault();
    }

    // --- Desktop: Right-click for Pointer Lock Camera ---
    if (e.pointerType === 'mouse' && e.button === 2) {
        // If RMB is pressed, we want camera control.
        // Immediately reset any active left-click drawing state.
        pointerIsDown = false;
        lastActionVoxelCoords = null;
        
        if (document.pointerLockElement !== cvs) {
            updatePreviewVoxel(0, 0, 0, false); // Hide preview
            cvs.requestPointerLock();
            cvs.focus(); // Ensure canvas has focus for keyboard input
        }
        return; // Important: Exit, as this pointer event is for camera control
    }

    // If pointer is locked (meaning RMB is already controlling camera), ignore other clicks.
    if (isPointerLocked) return;

    // --- Touch Input Handling ---
    if (e.pointerType === 'touch') {
        if (suppressNextTap) {
            suppressNextTap = false;
            return;
        }

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType });
        touchIndicator.style.display = 'block';
        touchIndicator.style.left = `${e.clientX}px`;
        touchIndicator.style.top = `${e.clientY}px`;

        const now = performance.now();
        // Check for double-tap-and-drag for drawing
        if (tapCandidate && (now - tapCandidate.time < DT_MS) && (Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH)) {
            doubleTapDragActive = true;
            tapCandidate = null;
            // Set fixed plane for touch double-tap-drag drawing ONLY IF IN ADD MODE
            if (currentMode === Modes.ADD) {
                setFixedDragPlane(e.clientX, e.clientY, currentMode);
            } else {
                fixedDragPlaneParams = { level: null, axis: null }; // Ensure it's reset
            }
        } else {
            // For single tap or start of multi-finger gesture
            tapCandidate = { x: e.clientX, y: e.clientY, time: now };
        }

        const pointers = [...activePointers.values()];
        gestureState.initialPointerCount = pointers.length;

        // NEW: Handle Extrude mode for touch
        if (currentMode === Modes.EXTRUDE && pointers.length === 1) {
            const hitVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, Modes.DELETE, false, false, 'touch');
            if (hitVoxel && voxels.has(key(hitVoxel.gx, hitVoxel.gy, hitVoxel.gz))) {
                initialExtrudeVoxel = { ...hitVoxel };
                initialExtrudeColor = voxels.get(key(hitVoxel.gx, hitVoxel.gy, hitVoxel.gz)).color;
                isExtruding = true;
                voxelsAtExtrudeStart = new Map(voxels); // Snapshot for undo
                lastActionVoxelCoords = { ...hitVoxel }; // For DDA start point
                gestureState.type = 'none'; // Prevent camera rotation in extrude mode
            } else {
                // Cannot extrude from empty space
                initialExtrudeVoxel = null;
                initialExtrudeColor = null;
                isExtruding = false;
                voxelsAtExtrudeStart = null;
                lastActionVoxelCoords = null;
                // If no voxel hit, allow camera rotation for single finger
                gestureState.type = 'rotate';
                gestureState.lastMid = { x: e.clientX, y: e.clientY };
            }
            updatePreviewVoxel(0, 0, 0, false); // Hide preview until drag starts
            return; // Exit to prevent other touch logic from interfering
        }


        if (pointers.length === 1) {
            gestureState.type = 'rotate'; // Single-finger drag for rotation
            gestureState.lastMid = { x: e.clientX, y: e.clientY };
        } else if (pointers.length >= 2) {
            // Multi-finger gestures (pan/pinch)
            const [p0, p1] = pointers;
            const midX = (p0.x + p1.x) * 0.5;
            const midY = (p0.y + p1.y) * 0.5;
            const dist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
            gestureState.type = 'none'; // Will be determined on first move
            gestureState.startMid = { x: midX, y: midY };
            gestureState.lastMid = { x: midX, y: midY };
            gestureState.startDist = dist;
            gestureState.lastDist = dist;
        }
        initialClickPos = { x: e.clientX, y: e.clientY }; // For tap/drag distinction
        return;
    }

    // --- Desktop: Left-click for Voxel Interaction ---
    if (e.pointerType === 'mouse' && e.button === 0) { // Ensure it's LMB
        pointerIsDown = true;
        lastX = e.clientX; // Store for preview updates
        lastY = e.clientY; // Store for preview updates
        initialClickPos = { x: e.clientX, y: e.clientY }; // For click vs. drag distinction

        // NEW: Handle Extrude mode for desktop
        if (currentMode === Modes.EXTRUDE) {
            const hitVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, Modes.DELETE, false, false, 'mouse'); // Use DELETE logic to hit existing voxel
            if (hitVoxel && voxels.has(key(hitVoxel.gx, hitVoxel.gy, hitVoxel.gz))) {
                initialExtrudeVoxel = { ...hitVoxel };
                initialExtrudeColor = voxels.get(key(hitVoxel.gx, hitVoxel.gy, hitVoxel.gz)).color;
                isExtruding = true;
                voxelsAtExtrudeStart = new Map(voxels); // Snapshot for undo
                lastActionVoxelCoords = { ...hitVoxel }; // For DDA start point
            } else {
                // Cannot extrude from empty space, reset state
                initialExtrudeVoxel = null;
                initialExtrudeColor = null;
                isExtruding = false;
                voxelsAtExtrudeStart = null;
                lastActionVoxelCoords = null;
            }
            updatePreviewVoxel(0, 0, 0, false); // Hide preview until drag starts
            return; // Prevent other modes from activating
        }

        // Determine the fixed drawing plane based on modifier keys (Shift/Control) ONLY IF IN ADD mode
        if (currentMode === Modes.ADD) {
            setFixedDragPlane(e.clientX, e.clientY, currentMode);
        } else {
            fixedDragPlaneParams = { level: null, axis: null }; // Ensure it's reset for other modes
        }
        

        // For single clicks (or start of a drag that doesn't immediately move beyond MOVE_PX),
        // perform the initial voxel action immediately on pointer down.
        const targetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, isControlDragging, 'mouse');
        if (targetVoxel) {
            performVoxelModification(targetVoxel.gx, targetVoxel.gy, targetVoxel.gz, currentMode, currentColor, currentBlockSize);
            lastActionVoxelCoords = { ...targetVoxel }; // Store for potential dragging
        }
    }
}


function onPointerMove(e) {
    e.preventDefault();

    // --- 1. Handle Pointer Lock Camera (RMB) ---
    if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            return;
        }
        const dx = e.movementX || 0;
        const dy = e.movementY || 0;
        euler.y -= dx * rotSpeed;
        euler.x -= dy * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        return; // IMPORTANT: Exit, as pointer is locked for camera control
    }

    // --- 2. Handle Touch Input (Gestures or Drag Drawing) ---
    if (e.pointerType === 'touch') {
        if (!activePointers.has(e.pointerId)) return; // Pointer not tracked

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType }); // Update pointer position
        touchIndicator.style.left = `${e.clientX}px`;
        touchIndicator.style.top = `${e.clientY}px`;

        // NEW: Handle Extrude mode drag for touch
        if (isExtruding && initialExtrudeVoxel) {
            const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, Modes.DELETE, true, false, e.pointerType);
            if (currentTargetVoxel && (
                !lastActionVoxelCoords ||
                currentTargetVoxel.gx !== lastActionVoxelCoords.gx ||
                currentTargetVoxel.gy !== lastActionVoxelCoords.gy ||
                currentTargetVoxel.gz !== lastActionVoxelCoords.gz
            )) {
                // Restore the state to `voxelsAtExtrudeStart`
                voxels.clear();
                voxelsAtExtrudeStart.forEach((data, k) => voxels.set(k, data));

                // Generate the new extrusion path and apply it to the `voxels` map
                const { gx: x1, gy: y1, gz: z1 } = initialExtrudeVoxel;
                const { gx: x2, gy: y2, gz: z2 } = currentTargetVoxel;

                const dx = x2 - x1;
                const dy = y2 - y1;
                const dz = z2 - z1;

                const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

                if (steps === 0) {
                    // Single voxel, only add if not already present or recolor if different
                    const k = key(x1, y1, z1);
                    if (!voxels.has(k)) {
                        voxels.set(k, { color: initialExtrudeColor });
                    } else if (voxels.get(k).color !== initialExtrudeColor) {
                        voxels.set(k, { color: initialExtrudeColor });
                    }
                } else {
                    const x_inc = dx / steps;
                    const y_inc = dy / steps;
                    const z_inc = dz / steps;

                    for (let i = 0; i <= steps; i++) {
                        const currentX = Math.round(x1 + i * x_inc);
                        const currentY = Math.round(y1 + i * y_inc);
                        const currentZ = Math.round(z1 + i * z_inc);
                        const k = key(currentX, currentY, currentZ);

                        // Check if within grid bounds
                        if (currentX >= 0 && currentX < GRID &&
                            currentY >= 0 && currentY < GRID &&
                            currentZ >= 0 && currentZ < GRID) {
                            
                            if (!voxels.has(k)) {
                                voxels.set(k, { color: initialExtrudeColor });
                            } else if (voxels.get(k).color !== initialExtrudeColor) {
                                voxels.set(k, { color: initialExtrudeColor });
                            }
                        }
                    }
                }
                lastActionVoxelCoords = { ...currentTargetVoxel };
            }
            updatePreviewVoxel(currentTargetVoxel ? currentTargetVoxel.gx : 0, currentTargetVoxel ? currentTargetVoxel.gy : 0, currentTargetVoxel ? currentTargetVoxel.gz : 0, currentTargetVoxel !== null);
            return; // Exit to prevent other touch logic from interfering
        }

        if (doubleTapDragActive) {
            // Touch-based drag drawing (for ADD/DELETE/DRAW modes)
            const targetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, true, false, 'touch');
            if (targetVoxel) {
                if (!lastActionVoxelCoords || key(targetVoxel.gx, targetVoxel.gy, targetVoxel.gz) !== key(lastActionVoxelCoords.gx, lastActionVoxelCoords.gy, lastActionVoxelCoords.gz)) {
                    if (lastActionVoxelCoords) {
                        drawLineOfVoxels(lastActionVoxelCoords, targetVoxel, currentMode, currentColor, currentBlockSize);
                    } else {
                        performVoxelModification(targetVoxel.gx, targetVoxel.gy, targetVoxel.gz, currentMode, currentColor, currentBlockSize);
                    }
                    lastActionVoxelCoords = { ...targetVoxel };
                }
            }
            updatePreviewVoxel(0, 0, 0, false); // Hide preview during active touch drag
            return;
        }

        // If not double-tap-drag, handle camera gestures. These should NOT draw cubes.
        handleGesture(); // Handles single-finger rotation, multi-finger pan/pinch
        updatePreviewVoxel(0, 0, 0, false); // Hide preview during gestures
        return;
    }

    // --- 3. Handle Desktop Mouse Hover and Left-Click Drag for Voxel Interaction ---
    // Update lastX, lastY for preview voxel calculation when not dragging.
    lastX = e.clientX;
    lastY = e.clientY;

    const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
    // isDraggingVoxelAction is true if LMB is down AND (mouse has moved beyond click threshold OR Shift/Ctrl is held OR long press is active)
    const isDraggingVoxelAction = pointerIsDown && (movedDistance > MOVE_PX || isShiftDragging || isControlDragging || isHoldDrawingActive);

    // NEW: Handle Extrude mode drag for desktop
    if (isExtruding && initialExtrudeVoxel) {
        const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, Modes.DELETE, true, false, e.pointerType);
        if (currentTargetVoxel && (
            !lastActionVoxelCoords ||
            currentTargetVoxel.gx !== lastActionVoxelCoords.gx ||
            currentTargetVoxel.gy !== lastActionVoxelCoords.gy ||
            currentTargetVoxel.gz !== lastActionVoxelCoords.gz
        )) {
            // Restore the state to `voxelsAtExtrudeStart`
            voxels.clear();
            voxelsAtExtrudeStart.forEach((data, k) => voxels.set(k, data));

            // Generate the new extrusion path and apply it to the `voxels` map
            const { gx: x1, gy: y1, gz: z1 } = initialExtrudeVoxel;
            const { gx: x2, gy: y2, gz: z2 } = currentTargetVoxel;

            const dx = x2 - x1;
            const dy = y2 - y1;
            const dz = z2 - z1;

            const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

            if (steps === 0) {
                // Single voxel, only add if not already present or recolor if different
                const k = key(x1, y1, z1);
                if (!voxels.has(k)) {
                    voxels.set(k, { color: initialExtrudeColor });
                } else if (voxels.get(k).color !== initialExtrudeColor) {
                    voxels.set(k, { color: initialExtrudeColor });
                }
            } else {
                const x_inc = dx / steps;
                const y_inc = dy / steps;
                const z_inc = dz / steps;

                for (let i = 0; i <= steps; i++) {
                    const currentX = Math.round(x1 + i * x_inc);
                    const currentY = Math.round(y1 + i * y_inc);
                    const currentZ = Math.round(z1 + i * z_inc);
                    const k = key(currentX, currentY, currentZ);

                    // Check if within grid bounds
                    if (currentX >= 0 && currentX < GRID &&
                        currentY >= 0 && currentY < GRID &&
                        currentZ >= 0 && currentZ < GRID) {
                        
                        if (!voxels.has(k)) {
                            voxels.set(k, { color: initialExtrudeColor });
                        } else if (voxels.get(k).color !== initialExtrudeColor) {
                            voxels.set(k, { color: initialExtrudeColor });
                        }
                    }
                }
            }
            lastActionVoxelCoords = { ...currentTargetVoxel };
        }
        updatePreviewVoxel(currentTargetVoxel ? currentTargetVoxel.gx : 0, currentTargetVoxel ? currentTargetVoxel.gy : 0, currentTargetVoxel ? currentTargetVoxel.gz : 0, currentTargetVoxel !== null);
        return; // Exit to prevent other modes from acting
    }

    const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, isDraggingVoxelAction, isControlDragging, 'mouse');

    if (currentTargetVoxel) {
        updatePreviewVoxel(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, true);
    } else {
        updatePreviewVoxel(0, 0, 0, false);
    }

    if (isDraggingVoxelAction) {
        if (currentTargetVoxel) {
            if (!lastActionVoxelCoords || key(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz) !== key(lastActionVoxelCoords.gx, lastActionVoxelCoords.gy, lastActionVoxelCoords.gz)) {
                if (lastActionVoxelCoords) {
                    drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor, currentBlockSize);
                } else {
                    performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
                }
                lastActionVoxelCoords = { ...currentTargetVoxel };
            }
        }
    }
}


function onPointerUp(e) {
    // --- Touch Input Release ---
    if (e.pointerType === 'touch') {
        if (suppressNextTap) {
            suppressNextTap = false;
        } else if (activePointers.size === 1 && !doubleTapDragActive && gestureState.type === 'rotate' && currentMode !== Modes.EXTRUDE) {
            // This block handles single-finger TAP for drawing, if it wasn't a drag for camera rotation
            const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
            if (movedDistance <= TAP_DIST_TH) { // It was a tap, not a drag
                 const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false, 'touch');
                 if (clickedVoxel) {
                     performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, currentMode, currentColor, currentBlockSize);
                 }
            }
        }
        // NEW: Handle Extrude mode release for touch
        if (isExtruding) {
            isExtruding = false;
            // Add the command to history
            addCommand('extrude', null, null, null, null, null, voxelsAtExtrudeStart, new Map(voxels));
            initialExtrudeVoxel = null;
            initialExtrudeColor = null;
            voxelsAtExtrudeStart = null;
        }
        releasePointer(e.pointerId, e);
        return;
    }

    // --- Desktop: Mouse Release ---
    if (e.pointerType === 'mouse') {
        if (e.button === 2) { // Right-click release
            document.exitPointerLock();
            return;
        }

        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleClick = movedDistance <= MOVE_PX;

        // NEW: Handle Extrude mode release for desktop
        if (isExtruding) {
            isExtruding = false;
            // Add the command to history
            addCommand('extrude', null, null, null, null, null, voxelsAtExtrudeStart, new Map(voxels));
            initialExtrudeVoxel = null;
            initialExtrudeColor = null;
            voxelsAtExtrudeStart = null;
        } else if (pointerIsDown && !isPointerLocked && wasSingleClick) {
            // For desktop, the initial voxel action is already performed on pointerDown.
            // This ensures that a simple click registers the voxel immediately.
            // No need to re-calculate and perform modification here unless it's a drag.
            // The `lastActionVoxelCoords` being set in onPointerDown handles the single click.
        }
    }

    // --- General Cleanup ---
    pointerIsDown = false;
    isControlDragging = false;
    isShiftDragging = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;
    fixedDragPlaneParams = { level: null, axis: null }; // Always reset on pointer up
    updatePreviewVoxel(0, 0, 0, false);
}


function onPointerLeave(e) {
    if (e.pointerType === 'mouse') {
        pointerIsDown = false;
        lastActionVoxelCoords = null;
        updatePreviewVoxel(0, 0, 0, false);
        // NEW: Reset extrude state on mouse leave
        if (isExtruding) {
            isExtruding = false;
            initialExtrudeVoxel = null;
            initialExtrudeColor = null;
            voxelsAtExtrudeStart = null;
        }
    }
}

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true;
        updatePreviewVoxel(0,0,0,false);
        euler.setFromQuaternion(cam.quaternion, 'YXZ');

    } else {
        isPointerLocked = false;
    }
}

function onMouseWheel(e) {
    e.preventDefault();

    const sensitivity = 0.005;
    let zoomAmount = e.deltaY * sensitivity;

    if (e.altKey) {
        // Only allow axis lock changes in ADD mode
        if (currentMode === Modes.ADD) {
            if (e.shiftKey) {
                activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
                currentDrawingAxis = 'z';
            } else if (e.ctrlKey) {
                activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
                currentDrawingAxis = 'x';
            } else {
                activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
                currentDrawingAxis = 'y';
            }
            updateGridHelperPosition();
        } else {
            // If not in ADD mode, just zoom
            cam.position.addScaledVector(
                cam.getWorldDirection(new THREE.Vector3()),
                zoomAmount * moveSpeed * 5
            );
        }
    } else {
        const speedChange = -Math.sign(e.deltaY) * 0.01;
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed + speedChange));
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

        cam.position.addScaledVector(
            cam.getWorldDirection(new THREE.Vector3()),
            zoomAmount * moveSpeed * 5
        );
    }
}

// Helper to get a point on a specific fixed plane
function getPointOnFixedPlane(clientX, clientY, axis, level) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    let planeNormal = new THREE.Vector3();
    if (axis === 'y') planeNormal.set(0, 1, 0);
    else if (axis === 'x') planeNormal.set(1, 0, 0);
    else if (axis === 'z') planeNormal.set(0, 0, 1);
    const drawingPlane = new THREE.Plane(planeNormal, -(level * VS));

    const intersectionPoint = new THREE.Vector3();
    const intersectResult = raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

    if (intersectResult) { // Check if intersection occurred
        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        if (axis === 'y') gy = level;
        else if (axis === 'x') gx = level;
        else if (axis === 'z') gz = level;

        gx = Math.max(0, Math.min(GRID - 1, gx));
        gy = Math.max(0, Math.min(GRID - 1, gy));
        gz = Math.max(0, Math.min(GRID - 1, gz));

        return { gx, gy, gz };
    }
    return null;
}

// Function to set the current block size
function setBlockSize(size) {
    currentBlockSize = size;
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
    document.querySelectorAll('.block-size-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`block-size-${size}x${size}`).classList.add('active');
    const rect = cvs.getBoundingClientRect();
    const mouseX = lastX - rect.left;
    const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: lastX,
            clientY: lastY,
            buttons: pointerIsDown ? 1 : 0
        });
        onPointerMove(mouseEvent);
    } else {
        updatePreviewVoxel(0,0,0,false);
    }
}


/* ---------- Keyboard Input ---------- */
const keyboard = {};
function onKeyDown(e) {
    keyboard[e.key] = true;

    if (e.key === 'Shift') {
        isShiftDragging = true;
    }
    if (e.key === 'Control' || e.key === 'Meta') {
        isControlDragging = true;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
    }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) {
        e.preventDefault();
        redo();
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
    }

    switch (e.key) {
        case 'Tab':
            e.preventDefault();
            cycleMode();
            break;
        case '1': setActivePreset(0); break;
        case '2': setActivePreset(1); break;
        case '3': setActivePreset(2); break;
    }
}

function onKeyUp(e) {
    keyboard[e.key] = false;

    if (e.key === 'Shift') {
        isShiftDragging = false;
    }
    if (e.key === 'Control' || e.key === 'Meta') {
        isControlDragging = false;
    }
}
</script>
</body>
</html>
