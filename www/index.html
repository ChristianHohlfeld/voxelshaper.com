<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper ‚Äì Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor ‚Äì made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper ‚Äì Voxel Editor & 3D Print Exporter</title>
<style>
/* CSS f√ºr den Body mit Safe-Area-Anpassungen */
body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;

    /* --- WICHTIG: ANPASSUNGEN F√úR SICHERE BEREICHE --- */
    /* Verschiebt den Inhalt nach unten, um Platz f√ºr die Statusleiste/Notch zu schaffen */
    padding-top: env(safe-area-inset-top);
    /* F√ºgt Polsterung f√ºr den unteren Bereich hinzu (z.B. f√ºr Home-Indikatoren auf iPhones) */
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Entscheidend: Stellt sicher, dass das Padding in der 100vh H√∂he enthalten ist */
    box-sizing: border-box;
    /* NEW: Prevent full page zoom on mobile */
    touch-action: pan-x pan-y;
    /* NEW: Prevent text selection */
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
}

/* verhindert, dass das OS den Canvas als Text selektiert */
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;    /* iOS Kontextmen√º */
}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode{
    font-weight:700;
    color:#81c784;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
    /* Prevent accidental zooming */
    touch-action: none;
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box; /* Ensure border (if added back) doesn't push content out */
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    display: none;
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Style for the new terrain controls panel */
#terrainControlsPanel {
    background: #3a3f47;
    padding: 14px;
    margin-top: 10px;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    align-items: center;
    border: 1px solid #4a4f57;
    transition: all 0.3s ease-in-out;
}
/* ---------------------------------------------------
    HAMBURGER-BUTTON
    --------------------------------------------------- */
#menuToggle{
    position: fixed;
    /* top: 10px; <-- DIESE ZEILE WIRD GE√ÑNDERT! */
    top: calc(10px + env(safe-area-inset-top)); /* <-- NEU: Verschiebt es um 10px + Safe-Area nach unten */
    right: 10px;
    z-index: 1500;             /* √ºber allen Panels */
    width: 42px; height: 42px;
    font-size: 1.4em;
    line-height: 42px;
    text-align: center;
    background:#555c66;
    color:#e0e0e0;
    border:none;
    border-radius:8px;
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.4);
}
#menuToggle:hover{background:#6a727f}

/* ---------------------------------------------------
    Responsive-Regel: Auf Viewports ‚â§ 768 px wird
    das Bedienfeld anfangs versteckt.
    --------------------------------------------------- */
@media (max-width:768px){
    #controls{display:none;}
    /* Mobile button sizing */
    button {
        min-width: 44px;
        min-height: 44px; /* Meet touch target guidelines */
    }
}
/* ---------------------------------------------------
    Gel√§nde-Button optisch hervorheben
    --------------------------------------------------- */
#generateTerrainBtn{
    padding: 12px 26px;
    font-size: 1.05em;
    font-weight: 600;
    letter-spacing: .3px;

    /* Farben im VoxelShaper-Gr√ºn */
    background: linear-gradient(180deg,#66bb6a 0%,#43a047 100%);
    color:#fff;

    border:none;
    border-radius:8px;
    cursor:pointer;

    /* leichter ‚Äûerhabener‚Äú Effekt */
    box-shadow:0 2px 6px rgba(0,0,0,.4);
    transition: transform .06s ease, box-shadow .06s ease;
}

/* Hover / Focus */
#generateTerrainBtn:hover,
#generateTerrainBtn:focus-visible{
    transform: translateY(-1px);
    box-shadow:0 4px 10px rgba(0,0,0,.45);
}

/* Aktiv (Button gedr√ºckt) */
#generateTerrainBtn:active{
    transform: translateY(0);
    box-shadow:0 2px 4px rgba(0,0,0,.35);
}
/* Canvas & Container: KEINE default-Gesten */
#container,
#voxelCanvas{
    touch-action: none;           /* iOS ‚â•13.4, Android, Desktop */
    -ms-touch-action: none;       /* altes Edge/IE */

    /* ‚Üê neu: sorge daf√ºr, dass die CSS-Border innen sitzt */
           box-sizing: border-box;
}

/* NEW: Accessibility - Screen Reader Only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0,0,0,0);
  border: 0;
}

/* NEW: Touch Indicator */
.touch-indicator {
    position: absolute;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(0, 150, 255, 0.3);
    transform: translate(-50%, -50%);
    pointer-events: none;
    animation: pulse 0.5s;}

@keyframes pulse {
    0% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.5); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

/* NEW: Mobile-specific controls */
.mobile-only {
    display: none; /* Hidden by default */
    position: absolute;
    bottom: calc(20px + env(safe-area-inset-bottom)); /* Adjust for safe area */
    right: calc(20px + env(safe-area-inset-right)); /* Adjust for safe area */
    flex-direction: column;
    gap: 12px;
    z-index: 1000;
}

@media (max-width: 768px) {
    .mobile-only {
        display: flex; /* Show on mobile */
    }
    
    .mobile-btn {
        width: 60px;
        height: 60px;
        font-size: 24px;
        border-radius: 50%;
        background: rgba(90, 90, 120, 0.8);
        color: white;
        border: 2px solid white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(0,0,0,.4);
    }
    .mobile-btn:hover {
        background: rgba(110, 110, 140, 0.9);
    }
}
</style>
</head>
<body>
<button id="menuToggle" aria-label="Men√º umschalten">‚ò∞</button>

<div id="controls">
    <label for="grid-size-slider">Gittergr√∂√üe:</label>
    <input type="range" id="grid-size-slider" min="5" max="90" value="10" aria-label="Gittergr√∂√üe anpassen">
    <span id="grid-size-display">10√ó10√ó10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff" aria-label="Aktuelle Farbe w√§hlen">
    <div id="color-preset-1" class="color-preset-box" role="button" tabindex="0" aria-label="Voreingestellte Farbe 1"></div>
    <div id="color-preset-2" class="color-preset-box" role="button" tabindex="0" aria-label="Voreingestellte Farbe 2"></div>
    <div id="color-preset-3" class="color-preset-box" role="button" tabindex="0" aria-label="Voreingestellte Farbe 3"></div>

    <button id="modeToggle" aria-label="Modus wechseln">Modus wechseln</button><span id="current-mode">Modus: Hinzuf√ºgen</span>
    <button id="clearBtn" aria-label="Alles l√∂schen">Alles l√∂schen</button>
    <button id="fillLevelBtn" aria-label="Ebene f√ºllen">Ebene f√ºllen</button>
    <button id="saveBtn" aria-label="Projekt speichern" aria-describedby="save-description">Projekt speichern</button>
    <div id="save-description" class="sr-only">Speichert das aktuelle Projekt als JSON-Datei</div>
    <button id="loadBtn" aria-label="Projekt laden">Projekt laden</button>
    <button id="exportStlBtn" aria-label="STL Export">STL Export</button>
    <button id="importStlBtn" aria-label="STL Import">STL Import</button> <!-- NEW: STL Import Button -->
    <button id="exportObjBtn" aria-label="OBJ Export">OBJ Export</button> <!-- NEW: OBJ Export Button -->
    <button id="importObjBtn" aria-label="OBJ Import">OBJ Import</button> <!-- NEW: OBJ Import Button -->
    <button id="exportVoxBtn" aria-label="VOX Export">VOX Export</button> <!-- NEW: VOX Export Button -->
    <button id="importVoxBtn" aria-label="VOX Import">VOX Import</button> <!-- NEW: VOX Import Button -->

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="1.0" step="0.01" value="0.1" aria-label="Fluggeschwindigkeit anpassen">
    <span id="fly-speed-display">0.10</span>

    <label for="block-size-selector">Blockgr√∂√üe:</label>
    <button id="block-size-1x1" class="block-size-btn active" aria-label="Blockgr√∂√üe 1x1">1x1</button>
    <button id="block-size-4x4" class="block-size-btn" aria-label="Blockgr√∂√üe 4x4">4x4</button>
    <button id="block-size-8x8" class="block-size-btn" aria-label="Blockgr√∂√üe 8x8">8x8</button>
    <button id="block-size-10x10" class="block-size-btn" aria-label="Blockgr√∂√üe 10x10">10x10</button> <!-- NEW: 10x10 Block Size Button -->

    <button id="toggleTerrainControlsBtn" aria-label="Gel√§nde-Optionen umschalten">Gel√§nde-Optionen</button>
    <button id="helpToggleBtn" aria-label="Hilfe umschalten">Hilfe</button>
    <button id="resetCameraBtn" aria-label="Kamera zur√ºcksetzen">Zur Szene zur√ºckkehren</button>

    <!-- NEW: Image Template Controls -->
    <button id="loadImageTemplateBtn" aria-label="Bild als Vorlage laden">Bild als Vorlage laden</button>
    <button id="removeImageTemplateBtn" style="display:none;" aria-label="Bildvorlage entfernen">Bildvorlage entfernen</button>
    <label for="lockImageTemplateCheckbox">Vorlage sperren:</label>
    <input type="checkbox" id="lockImageTemplateCheckbox" aria-label="Bildvorlage sperren">
    <input type="file" id="imageFileInput" accept="image/*" style="display:none;">
</div>

<div id="terrainControlsPanel" style="display:none;">
    <button id="generateTerrainBtn" aria-label="Gel√§nde generieren">Gel√§nde generieren</button>
    <label for="terrain-height-scale">H√∂he:</label>
    <input type="number" id="terrain-height-scale" value="10" min="1" step="1" aria-label="Gel√§ndeh√∂he anpassen">
    <label for="terrain-frequency">Frequenz:</label>
    <input type="number" id="terrain-frequency" value="0.05" min="0.001" max="0.5" step="0.001" aria-label="Gel√§ndefrequenz anpassen">
    <label for="terrain-octaves">Oktaven:</label>
    <input type="number" id="terrain-octaves" value="4" min="1" max="10" step="1" aria-label="Gel√§ndeoktaven anpassen">
    <label for="terrain-lacunarity">Lacunarity:</label>
    <input type="number" id="terrain-lacunarity" value="2.0" min="1.0" max="4.0" step="0.1" aria-label="Gel√§nde-Lacunarity anpassen">
    <label for="terrain-gain">Gain:</label>
    <input type="number" id="terrain-gain" value="0.5" min="0.1" max="1.0" step="0.01" aria-label="Gel√§nde-Gain anpassen">
    <label for="terrain-seed">Seed:</label>
    <input type="text" id="terrain-seed" placeholder="Zahl oder Text" aria-label="Gel√§nde-Seed eingeben">
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus ‚Üí Kamera drehen (Fly Mode)<br>
    WASD / E / Q ‚Üí bewegen<br>
    Linke MT ‚Üí Voxel hinzuf./l√∂schen/zeichnen<br>
    **Alt + Mausrad ‚Üí Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad ‚Üí Zeichenebene Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad ‚Üí Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel Aktion auf aktiver Ebene (Hinzuf√ºgen / L√∂schen / Zeichnen)**<br>
    **Control + Linke MT gedr√ºckt + Maus ziehen ‚Üí Voxel ziehen zum Hinzuf√ºgen (Stapeln, nur im Hinzuf√ºgen-Modus)**<br>
    Mausrad ‚Üí Kamera Geschwindigkeit anpassen<br>
    **Tab ‚Üí Modus wechseln (Hinzuf√ºgen / L√∂schen / Zeichnen)**<br>
    **1, 2, 3 ‚Üí Voreingestellte Farbe w√§hlen (Shift/Strg/Cmd + 1,2,3 zum Speichern)**<br>
    **Strg + Z ‚Üí R√ºckg√§ngig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z ‚Üí Wiederholen (Redo)**
    </div>
    <input type="file" id="fileInput" accept=".json">
    <input type="file" id="stlFileInput" accept=".stl" style="display:none;"> <!-- NEW: STL File Input -->
    <input type="file" id="objFileInput" accept=".obj" style="display:none;"> <!-- NEW: OBJ File Input -->
    <input type="file" id="voxFileInput" accept=".vox" style="display:none;"> <!-- NEW: VOX File Input -->
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt l√∂schen</h3>
        <p>M√∂chten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel l√∂schen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & L√∂schen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern l√∂schen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>

<div id="messageModal" class="modal">
    <div class="modal-content">
        <h3 id="messageModalTitle">Nachricht</h3>
        <p id="messageModalText"></p>
        <div class="modal-buttons">
            <button id="messageModalCloseBtn" class="cancel">Schlie√üen</button>
        </div>
    </div>
</div>

<!-- NEW: Mobile controls -->
<div id="mobile-controls" class="mobile-only">
    <button class="mobile-btn" id="mobile-undo" aria-label="R√ºckg√§ngig machen">‚Ü∫</button>
    <button class="mobile-btn" id="mobile-redo" aria-label="Wiederholen">‚Üª</button>
    <button class="mobile-btn" id="mobile-save" aria-label="Speichern">üíæ</button>
    <button class="mobile-btn" id="mobile-camera" aria-label="Kamera wechseln">üì∑</button>
    <button class="mobile-btn" id="mobile-assist" aria-label="Touch-Assist umschalten">üß≤</button>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/noisejs/2.1.0/perlin.js"></script>

<!-- VoxelShaperIO Library (embedded) -->
<script>
var VoxelShaperIO = (function() {
    // Helper to convert hex to RGBA for VOX palette
    function hexToRgba(hex) {
        if (!hex || hex.length !== 7) return 0x00000000; // Default to transparent black
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return (r << 24) | (g << 16) | (b << 8) | 0xFF; // RGBA
    }

    // Helper to convert RGBA to hex
    function rgbaToHex(rgba) {
        const r = (rgba >>> 24) & 0xFF;
        const g = (rgba >>> 16) & 0xFF;
        const b = (rgba >>> 8) & 0xFF;
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
    }

    class VoxModel {
        constructor(sizeX, sizeY, sizeZ, voxels = [], palette = new Uint32Array(256)) {
            this.sizeX = sizeX;
            this.sizeY = sizeY;
            this.sizeZ = sizeZ;
            this.voxels = voxels; // Array of {x, y, z, c} where c is palette index
            this.palette = palette; // Uint32Array of RGBA colors
            // Initialize default palette if not provided
            if (this.palette.every(val => val === 0)) {
                this.palette[1] = hexToRgba("#FF0000"); // Red
                this.palette[2] = hexToRgba("#00FF00"); // Green
                this.palette[3] = hexToRgba("#0000FF"); // Blue
                // ... add more default colors as needed
            }
        }
    }

    // Basic OBJ exporter (simplified, no materials)
    function voxToOBJ(voxModel, cubeSize = 1) {
        let obj = `# VoxelShaper OBJ Export\n`;
        let vertexCount = 0;

        voxModel.voxels.forEach(v => {
            const x = v.x * cubeSize;
            const y = v.y * cubeSize;
            const z = v.z * cubeSize;

            // Vertices for a cube
            obj += `v ${x} ${y} ${z}\n`;
            obj += `v ${x + cubeSize} ${y} ${z}\n`;
            obj += `v ${x + cubeSize} ${y + cubeSize} ${z}\n`;
            obj += `v ${x} ${y + cubeSize} ${z}\n`;
            obj += `v ${x} ${y} ${z + cubeSize}\n`;
            obj += `v ${x + cubeSize} ${y} ${z + cubeSize}\n`;
            obj += `v ${x + cubeSize} ${y + cubeSize} ${z + cubeSize}\n`;
            obj += `v ${x} ${y + cubeSize} ${z + cubeSize}\n`;

            // Faces (simplified, assuming no normals/texture coords for now)
            // Front face
            obj += `f ${vertexCount + 1} ${vertexCount + 2} ${vertexCount + 3} ${vertexCount + 4}\n`;
            // Back face
            obj += `f ${vertexCount + 5} ${vertexCount + 8} ${vertexCount + 7} ${vertexCount + 6}\n`;
            // Top face
            obj += `f ${vertexCount + 4} ${vertexCount + 3} ${vertexCount + 7} ${vertexCount + 8}\n`;
            // Bottom face
            obj += `f ${vertexCount + 1} ${vertexCount + 5} ${vertexCount + 6} ${vertexCount + 2}\n`;
            // Right face
            obj += `f ${vertexCount + 2} ${vertexCount + 6} ${vertexCount + 7} ${vertexCount + 3}\n`;
            // Left face
            obj += `f ${vertexCount + 5} ${vertexCount + 1} ${vertexCount + 4} ${vertexCount + 8}\n`;

            vertexCount += 8;
        });
        return obj;
    }

    // Basic OBJ importer (very simplified, only parses vertices and creates voxels at those points)
    function objToVox(objText, voxelSize = 1) {
        const lines = objText.split('\n');
        const vertices = [];
        const voxels = new Map(); // Use a map to avoid duplicate voxels
        let maxX = 0, maxY = 0, maxZ = 0;
        let minX = Infinity, minY = Infinity, minZ = Infinity;

        lines.forEach(line => {
            const parts = line.trim().split(/\s+/);
            if (parts[0] === 'v') {
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                const z = parseFloat(parts[3]);
                vertices.push({ x, y, z });

                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                minZ = Math.min(minZ, z);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
                maxZ = Math.max(maxZ, z);
            }
        });

        // Simple voxelization: place a voxel at the rounded grid coordinates of each vertex
        vertices.forEach(v => {
            const gx = Math.round(v.x / voxelSize);
            const gy = Math.round(v.y / voxelSize);
            const gz = Math.round(v.z / voxelSize);
            // Using a string key for the map
            voxels.set(`${gx},${gy},${gz}`, { x: gx, y: gy, z: gz, c: 1 }); // c:1 is a dummy palette index
        });

        const voxelArray = Array.from(voxels.values());

        // Calculate size based on min/max voxel coordinates
        const sizeX = (maxX === -Infinity) ? 0 : Math.ceil(maxX / voxelSize) - Math.floor(minX / voxelSize);
        const sizeY = (maxY === -Infinity) ? 0 : Math.ceil(maxY / voxelSize) - Math.floor(minY / voxelSize);
        const sizeZ = (maxZ === -Infinity) ? 0 : Math.ceil(maxZ / voxelSize) - Math.floor(minZ / voxelSize);

        return new VoxModel(sizeX, sizeY, sizeZ, voxelArray);
    }

    // Basic VOX builder (simplified, only supports SIZE and XYZI chunks)
    function buildVox(voxModel) {
        const writer = new DataViewWriter();

        // RIFF header
        writer.writeString('VOX ');
        writer.writeInt32(200); // Version

        // MAIN chunk
        writer.writeString('MAIN');
        writer.writeInt32(0); // Content size (will be updated)
        writer.writeInt32(0); // Children size (will be updated)
        const mainContentStart = writer.position;

        // SIZE chunk
        writer.writeString('SIZE');
        writer.writeInt32(12); // Content size (3 * 4 bytes for x, y, z)
        writer.writeInt32(0); // Children size
        writer.writeInt32(voxModel.sizeX);
        writer.writeInt32(voxModel.sizeY);
        writer.writeInt32(voxModel.sizeZ);

        // XYZI chunk
        writer.writeString('XYZI');
        writer.writeInt32(4 + voxModel.voxels.length * 4); // Content size (4 bytes for numVoxels + numVoxels * 4 bytes for x,y,z,c)
        writer.writeInt32(0); // Children size
        writer.writeInt32(voxModel.voxels.length);
        voxModel.voxels.forEach(v => {
            writer.writeUint8(v.x);
            writer.writeUint8(v.y);
            writer.writeUint8(v.z);
            writer.writeUint8(v.c); // Palette index
        });

        // RGBA chunk (palette)
        writer.writeString('RGBA');
        writer.writeInt32(256 * 4); // Content size (256 colors * 4 bytes/color)
        writer.writeInt32(0); // Children size
        for (let i = 0; i < 256; i++) {
            writer.writeUint32(voxModel.palette[i]);
        }

        // Update MAIN chunk sizes
        const mainContentEnd = writer.position;
        writer.position = mainContentStart - 8; // Go back to MAIN chunk content size
        writer.writeInt32(mainContentEnd - mainContentStart); // Actual content size
        writer.writeInt32(0); // No explicit children chunks for simplicity, included in main content

        return writer.getBuffer();
    }

    // Basic VOX parser (simplified, only extracts SIZE, XYZI, and RGBA chunks)
    function parseVox(arrayBuffer) {
        const reader = new DataViewReader(arrayBuffer);

        if (reader.readString(4) !== 'VOX ') {
            throw new Error('Not a valid VOX file');
        }
        reader.readInt32(); // Version (ignored)

        if (reader.readString(4) !== 'MAIN') {
            throw new Error('Invalid VOX MAIN chunk');
        }
        reader.readInt32(); // Content size (ignored)
        reader.readInt32(); // Children size (ignored)

        let sizeX = 0, sizeY = 0, sizeZ = 0;
        const voxels = [];
        const palette = new Uint32Array(256); // Default empty palette

        while (reader.position < reader.buffer.byteLength) {
            const chunkId = reader.readString(4);
            const contentSize = reader.readInt32();
            const childrenSize = reader.readInt32();
            const chunkEnd = reader.position + contentSize + childrenSize;

            switch (chunkId) {
                case 'SIZE':
                    sizeX = reader.readInt32();
                    sizeY = reader.readInt32();
                    sizeZ = reader.readInt32();
                    break;
                case 'XYZI':
                    const numVoxels = reader.readInt32();
                    for (let i = 0; i < numVoxels; i++) {
                        const x = reader.readUint8();
                        const y = reader.readUint8();
                        const z = reader.readUint8();
                        const c = reader.readUint8(); // Palette index
                        voxels.push({ x, y, z, c });
                    }
                    break;
                case 'RGBA':
                    for (let i = 0; i < 256; i++) {
                        palette[i] = reader.readUint32();
                    }
                    break;
                default:
                    // Skip unknown chunks
                    reader.position = chunkEnd;
                    break;
            }
            reader.position = chunkEnd; // Ensure we move to the end of the chunk
        }

        return new VoxModel(sizeX, sizeY, sizeZ, voxels, palette);
    }

    // Helper for writing binary data
    class DataViewWriter {
        constructor(initialCapacity = 1024) {
            this.buffer = new ArrayBuffer(initialCapacity);
            this.dataView = new DataView(this.buffer);
            this.position = 0;
        }

        _ensureCapacity(bytesNeeded) {
            if (this.position + bytesNeeded > this.buffer.byteLength) {
                const newCapacity = Math.max(this.buffer.byteLength * 2, this.position + bytesNeeded);
                const newBuffer = new ArrayBuffer(newCapacity);
                new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
                this.buffer = newBuffer;
                this.dataView = new DataView(this.buffer);
            }
        }

        writeString(str) {
            this._ensureCapacity(str.length);
            for (let i = 0; i < str.length; i++) {
                this.dataView.setUint8(this.position++, str.charCodeAt(i));
            }
        }

        writeInt32(value) {
            this._ensureCapacity(4);
            this.dataView.setInt32(this.position, value, true); // Little-endian
            this.position += 4;
        }

        writeUint32(value) {
            this._ensureCapacity(4);
            this.dataView.setUint32(this.position, value, true); // Little-endian
            this.position += 4;
        }

        writeUint8(value) {
            this._ensureCapacity(1);
            this.dataView.setUint8(this.position++, value);
        }

        getBuffer() {
            return this.buffer.slice(0, this.position);
        }
    }

    // Helper for reading binary data
    class DataViewReader {
        constructor(arrayBuffer) {
            this.buffer = arrayBuffer;
            this.dataView = new DataView(arrayBuffer);
            this.position = 0;
        }

        readString(length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(this.dataView.getUint8(this.position++));
            }
            return str;
        }

        readInt32() {
            const value = this.dataView.getInt32(this.position, true); // Little-endian
            this.position += 4;
            return value;
        }

        readUint32() {
            const value = this.dataView.getUint32(this.position, true); // Little-endian
            this.position += 4;
            return value;
        }

        readUint8() {
            return this.dataView.getUint8(this.position++);
        }
    }

    function saveBlob(data, filename) {
        const blob = new Blob([data], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    return {
        VoxModel,
        voxToOBJ,
        objToVox,
        buildVox,
        parseVox,
        saveBlob,
        rgbaToHex // Export rgbaToHex for debugging
    };
})();
</script>


<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;

/* ==============================================================
   FAST NUMERIC VOXEL-KEY  (max. GRID 0-1023 in jeder Achse)
   --------------------------------------------------------------
   ‚Äì 30-Bit-Packing:  x<<20 | y<<10 | z
   ‚Äì 100 % kollisionsfrei, >10√ó schneller als String-Hash,
     0 % GC-Druck
   ============================================================== */
// 10 Bit pro Achse  ‚Üí  0 ‚Ä¶ 1023
const VOX_BITS = 10;
const VOX_MASK = (1 << VOX_BITS) - 1;   // 0x3FF
const SHIFT_X  = VOX_BITS * 2;          // 20
const SHIFT_Y  = VOX_BITS;              // 10
// SHIFT_Z = 0

/**
 * Kombiniert (x,y,z) zu einem einzigen 30-Bit-Integer-Key.
 * - Alle Koordinaten m√ºssen 0 ‚â§ coord ‚â§ 1023 sein.
 */
function key(x, y, z) {
    // >>> 0 zwingt in den 32-Bit-Integer-Bereich
    return ((x << SHIFT_X) | (y << SHIFT_Y) | z) >>> 0;
}

/**
 * Invers zu `key()` ‚Äì liefert [x, y, z].
 */
function parseKey(k) {
    return [
        (k >>> SHIFT_X) & VOX_MASK,
        (k >>> SHIFT_Y) & VOX_MASK,
        k & VOX_MASK
    ];
}

/* ==============================================================
   LAZY INSTANCE-BUFFER UPDATE (Now handled by frustum culling in animate loop)
   --------------------------------------------------------------
   ‚Äì matrixDirty ‚Üí only relevant if not rebuilding every frame
   ‚Äì colorDirty ‚Üí only relevant if not rebuilding every frame
   ============================================================== */
// These flags are no longer strictly necessary as the InstancedMesh buffers
// are rebuilt every frame for frustum culling.
// Keeping them for now, but their usage for `needsUpdate` is moved.
let matrixDirty = false;
let colorDirty = false;

function markMatrixDirty() { matrixDirty = true; }
function markColorDirty () { colorDirty = true; }

/* ---------- globale Variablen ---------- */
let isHoldDrawingActive = false;   // NEW: Verfolgt, ob ein Long-Press-Zeichnen aktiv ist
const LONG_PRESS_DELAY_MS = 500;   // NEW: Wartezeit (in Millisekunden) f√ºr Long-Press-Erkennung

/* ----------------------------------------------
   GLOBAL ‚Äì neue Hilfs-Variablen
---------------------------------------------- */
const PINCH_ZOOM_MULT = 40;     // Zoom-Geschwindigkeit ‚Üë  (vorher 15, erh√∂ht f√ºr schnellere mobile Erfahrung)
const TAP_DIST_TH  = 10;     // max. Bewegung (px) f√ºr 'Tap'
const MOVE_PX     = 10;        // ab hier gilt es als Drag (erh√∂ht von 6)
const DT_MS       = 250;      // max. Abstand Taps (ms)

let tapCandidate   = null;   // {x,y,time}
let gestureMid   = null;   // {x,y}  ‚Äì letzte Mittel¬≠punkt¬≠position
let gestureDist  = null;   // vorheriger Zwei-Finger-Abstand
let longPressTimer = null; // Initialize longPressTimer to null

/* --- 2-Finger-Drag / Pinch ---------------------------------- */
const DRAG_BASE   = 0.1;   // Grund-faktor (wird mit moveSpeed multipliziert) (vorher 0.08)
const PAN_PIX_TH  = 10;      // ab 4 px Bewegung ‚Üí Pan
const PINCH_REL_TH = 0.08;  // ‚â•6 % Distanz√§nderung ‚Üí Pinch
let prevTouch = null;
let activePointers = new Map(); // Map to store active touch pointers
let touchStartPos = null; // merkt Position f√ºr Tap-Erkennung
let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;   // Globale Drehgeschwindigkeit    (NEU)

/* --- Touch State Machine (NEU) ---------------------------------------- */
const TouchState = {
    NONE: 0,
    TAP1: 1,
    TAP2_WAITMOVE: 2, // Second tap detected, waiting for move to initiate DRAW
    DRAW: 3,          // Double-tap-drag drawing is active
    SINGLE_TOUCH_CAMERA: 4, // Single finger moving camera
    MULTI_TOUCH_CAMERA: 5  // Multi-finger (pan/pinch) moving camera
};
let touchState = TouchState.NONE;
let suppressNextTap = false; // Global flag for pinch-zoom bug fix

let euler; // Declare euler globally
// voxels Map stores { color: hex_color } - instanceId is no longer needed here
// as InstancedMesh is rebuilt dynamically with frustum culling.
const voxels = new Map();   // Map<number,{color}>
let cvs;
let containerDiv; // Reference to the container div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt f√ºr aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse f√ºr Alt+Mausrad

// NEW: Global object to store fixed plane parameters for drag operations
let fixedDragPlaneParams = { level: null, axis: null };

// Lade die Farbe aus dem Local Storage oder nutze Wei√ü als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
// Lade die Gittergr√∂√üe aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;
console.log("Initial GRID size loaded:", GRID); // Debugging line for initial load

// Load other settings from local storage or set defaults
activeDrawingLevel.x = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelX') || '0');
activeDrawingLevel.y = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelY') || '0');
activeDrawingLevel.z = parseInt(localStorage.getItem('voxelEditorActiveDrawingLevelZ') || '0');
currentDrawingAxis = localStorage.getItem('voxelEditorCurrentDrawingAxis') || 'y';
let currentBlockSize = parseInt(localStorage.getItem('voxelEditorCurrentBlockSize') || '1'); // Declared here
let terrainHeightScale = parseInt(localStorage.getItem('voxelEditorTerrainHeightScale') || '10'); // Declared here
let terrainFrequency = parseFloat(localStorage.getItem('voxelEditorTerrainFrequency') || '0.05'); // Declared here
let terrainOctaves = parseInt(localStorage.getItem('voxelEditorTerrainOctaves') || '4'); // Declared here
let terrainLacunarity = parseFloat(localStorage.getItem('voxelEditorTerrainLacunarity') || '2.0'); // Declared here
let terrainGain = parseFloat(localStorage.getItem('voxelEditorTerrainGain') || '0.5'); // Declared here
let terrainSeed = localStorage.getItem('voxelEditorTerrainSeed') || ''; // Declared here
let hasUserTypedSeed = (terrainSeed !== '');


// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgr√ºn (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen f√ºr Lichter, die Schatten werfen, um sie sp√§ter anpassen zu k√∂nnen
let mainDirectionalLight;
let fillDirectionalLight; // NEW: Zweites gerichtetes Licht
let hemisphereLight;      // NEW: Hemisph√§renlicht
let groundPlane;          // NEW: Bodenplatte

// Globale Variablen f√ºr Dragging-Status
let isShiftDragging = false;   // physische Shift-Taste

function shiftActive(){        // true, wenn Shift an
    return isShiftDragging;
}
let isControlDragging = false;
// Removed 'rotate' global variable as it's redundant with pointer lock
let isPointerLocked = false; // NEW: Track pointer lock status
let lastActionVoxelCoords = null; // NEW: Tracks the last voxel acted upon for drag drawing
let initialClickPos = null; // To differentiate click from drag
let firstMoveAfterLock = true; // NEW: Flag to ignore first movement after pointer lock

// Performance optimization: InstancedMesh
let instancedMesh; // Replaces voxelMesh and voxelGeometry
const dummy = new THREE.Object3D(); // For setting instance matrices
const tempColor = new THREE.Color(); // For setting instance colors

// NEU: Globale Variable f√ºr den Vorschau-Voxel
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // depthTest: false, damit er immer sichtbar ist
// NEW: Z-Fighting fix for preview voxel
previewVoxelMaterial.polygonOffset = true;
previewVoxelMaterial.polygonOffsetFactor = -1;
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Initialize here
// ENDE NEU

// Modus-Enum
const Modes = {
    ADD: 'Hinzuf√ºgen',
    DELETE: 'L√∂schen',
    DRAW: 'Zeichnen',
};
let currentMode = Modes.ADD; // Standardmodus

// Undo/Redo History
let history = []; // Declared globally
let historyPointer = -1; // Declared globally
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// Global instance of the noise generator
let noise2D;

// NEW: Global variables for image template
let templateImageMesh = null;
// Updated templateImageData structure to store scaled dimensions
let templateImageData = null; // { src: base64, position: [], rotation: [], scale: [], locked: boolean, scaledWidth: number, scaledHeight: number }

// NEW: Mobile specific flags and variables
let isMobile = window.matchMedia('(max-width: 768px)').matches;
let touchAssistEnabled = false; // For magnetic targeting

// Custom ValueNoise2D as a function constructor to avoid lexical declaration issues
function ValueNoise2D(seed = '') {
    this.seed = seed;
    this.rng = new Math.seedrandom(seed);
    // Initialize Perlin noise. The 'noise' object should be available from perlin.js
    if (typeof noise === 'undefined') {
        console.warn("Perlin.js library (noise object) not found. ValueNoise2D will use basic Math.random.");
        this.noiseGenerator = null;
    } else {
        this.noiseGenerator = new noise.Perlin();
    }
}

ValueNoise2D.prototype._smoothstep = function(t) {
    return t * t * (3 - 2 * t);
};

ValueNoise2D.prototype._lerp = function(a, b, t) {
    return a + t * (b - a);
};

ValueNoise2D.prototype.fbm = function(x, z, octaves, lacunarity, gain) {
    let total = 0;
    let amplitude = 1;
    let maxAmplitude = 0;
    let frequency = terrainFrequency;

    for (let i = 0; i < octaves; i++) {
        const x0 = Math.floor(x * frequency);
        const z0 = Math.floor(z * frequency);
        const x1 = x0 + 1;
        const z1 = z0 + 1;

        const fx = (x * frequency) - x0;
        const fz = (z * frequency) - z0;

        // Use a temporary seeded RNG for each corner value to ensure determinism
        const val00 = new Math.seedrandom(`${this.seed}-${x0}-${z0}`)();
        const val10 = new Math.seedrandom(`${this.seed}-${x1}-${z0}`)();
        const val01 = new Math.seedrandom(`${this.seed}-${x0}-${z1}`)();
        const val11 = new Math.seedrandom(`${this.seed}-${x1}-${z1}`)();

        const ix0 = this._lerp(val00, val10, this._smoothstep(fx));
        const ix1 = this._lerp(val01, val11, this._smoothstep(fz));

        total += this._lerp(ix0, ix1, this._smoothstep(fz)) * amplitude;

        maxAmplitude += amplitude;

        frequency *= lacunarity;
        amplitude *= gain;
    }

    if (maxAmplitude === 0) return 0;
    return (total / maxAmplitude) * 2 - 1;
};


/* ---------- Hilfsfunktionen (alle vor window.onload verschoben) ---------- */

function onResize() {
    // Use containerDiv for sizing
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    // NEW: Adjust pixel ratio for mobile performance
    if (isMobile) {
        ren.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
    } else {
        ren.setPixelRatio(window.devicePixelRatio);
    }
}

function handleGesture () {
  const pts = [...activePointers.values()];
  if (pts.length === 0) return;

  // NEW: Ignore multi-finger gestures beyond 2 for now to prevent accidental behavior
  if (pts.length > 2) {
      touchState = TouchState.MULTI_TOUCH_CAMERA; // Assume camera control if many fingers
      return;
  }

  if (pts.length === 1){
    const p = pts[0];

    // If in DRAW state (double-tap-drag drawing)
    if (touchState === TouchState.DRAW){
      // In touch, DRAW state is like a shift-drag, so it should draw a line
      const currentTargetVoxel = calculateTargetVoxelCoords(p.x, p.y, currentMode, true, false, p.pointerType); // Pass pointerType
      if (currentTargetVoxel) {
          if (!lastActionVoxelCoords ||
              lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
              lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
              lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
              
              if (lastActionVoxelCoords) {
                  drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor, currentBlockSize);
              } else {
                  performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
              }
              lastActionVoxelCoords = { ...currentTargetVoxel };
          }
      }
      prevTouch = {x:p.x, y:p.y};
      return; // Exit, as we are in a drawing gesture
    }

    // Single-finger camera look
    // Only apply if in SINGLE_TOUCH_CAMERA state
    if (touchState === TouchState.SINGLE_TOUCH_CAMERA) {
        if (prevTouch === null){
            prevTouch = {x:p.x, y:p.y};
            return;
        }

        const dx = p.x - prevTouch.x;
        const dy = p.y - prevTouch.y;

        euler.y +=  dx * rotSpeed;
        euler.x +=  dy * rotSpeed;
        euler.x  =  Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
        cam.quaternion.setFromEuler(euler);

        prevTouch = {x:p.x, y:p.y};
        return;
    }
  }

  // Multi-touch gestures (pan/pinch)
  if (pts.length !== 2) return;

  const [p0, p1] = pts;
  const midX  = (p0.x + p1.x) * 0.5;
  const midY  = (p0.y + p1.y) * 0.5;
  const dist  = Math.hypot(p1.x - p0.x, p1.y - p0.y);

  if (gestureMid === null){
    gestureMid  = {x:midX, y:midY};
    gestureDist = dist;
    gestureMode = null; // This is the old gestureMode, not the new touchState
  }

  const dMid  = Math.hypot(midX - gestureMid.x, midY - gestureMid.y);
  const relŒî  = Math.abs(dist - gestureDist) / gestureDist;

  if (gestureMode === null){ // Still using old gestureMode for initial detection
    if (relŒî > PINCH_REL_TH)       gestureMode = 'pinch';
    else if (dMid > PAN_PIX_TH)    gestureMode = 'pan';
    else return;
  }

  if (gestureMode === 'pinch'){
    const scale     = dist / gestureDist;
    const zoomDelta = (scale - 1) * PINCH_ZOOM_MULT  * moveSpeed;
    cam.position.addScaledVector(
        cam.getWorldDirection(new THREE.Vector3()),
        zoomDelta
    );
    gestureDist = dist;
    suppressNextTap = true; // Quick-Fix: Suppress tap after pinch
    touchState = TouchState.MULTI_TOUCH_CAMERA; // Set new touchState
  } else { // Pan (strafe left/right, up/down)
    const panFactor = DRAG_BASE * (moveSpeed * 5);
    const dx = (midX - gestureMid.x) * panFactor;
    const dy = (midY - gestureMid.y) * panFactor;

    const dir   = cam.getWorldDirection(new THREE.Vector3());
    const right = new THREE.Vector3().crossVectors(dir, cam.up).normalize();
    const upVec = cam.up.clone().normalize(); // Use world up for vertical movement

    cam.position.addScaledVector(right, -dx); // Strafe left/right
    cam.position.addScaledVector(upVec, dy);   // Strafe up/down

    gestureMid = {x:midX, y:midY};
    touchState = TouchState.MULTI_TOUCH_CAMERA; // Set new touchState
  }

  prevTouch = null;
}

function releasePointer(id, eventType) { // Add eventType parameter
    activePointers.delete(id);

    // NEW: Handle three-finger swipe for undo/redo
    // Check if the event was a touch event before accessing e.clientX/Y
    if (activePointers.size === 0 && initialClickPos && eventType.pointerType === 'touch') { // Check pointerType
        const dx = eventType.clientX - initialClickPos.x; // Use eventType as the event object
        const dy = eventType.clientY - initialClickPos.y; // Use eventType as the event object
        const absDx = Math.abs(dx);
        const absDy = Math.abs(dy);

        if (absDx > 50 && absDx > absDy * 2) { // Horizontal swipe
            if (dx > 0) redo();
            else undo();
        }
    }

    if (activePointers.size === 1){
        const last = [...activePointers.values()][0];
        prevTouch   = { x:last.x, y:last.y };
        gestureMid  = gestureDist = null;
        gestureMode = null; // Reset old gestureMode
        touchState = TouchState.SINGLE_TOUCH_CAMERA; // Transition to single touch camera
        return;
    }

    if (activePointers.size === 0){
        tapCandidate   = null;
        
        gestureMid  = gestureDist = null;
        gestureMode = null; // Reset old gestureMode
        prevTouch   = null;
        lastActionVoxelCoords = null; // Reset for next touch interaction
        touchState = TouchState.NONE; // Reset to NONE when all fingers are up
    }
}

function rebuildHelpers() {
    if (typeof THREE === 'undefined') {
        console.error("THREE is not defined in rebuildHelpers. Cannot rebuild helpers.");
        return;
    }
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.z = Math.PI / 2;
        gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
}

function cycleMode() {
    switch (currentMode) {
        case Modes.ADD:
            currentMode = Modes.DELETE;
            break;
        case Modes.DELETE:
            currentMode = Modes.DRAW;
            break;
        case Modes.DRAW:
            currentMode = Modes.ADD; // Cycle back to ADD
            break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor); // Save as current selected color

        // Update active class for visual feedback
        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index; // Store which preset is active
    }
}

// New function to save current color to a preset slot
function saveCurrentColorToPreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = document.getElementById('color-picker').value; // Ensure we get the latest color from picker
        presetColors[index] = currentColor; // Update the array with the current color picker value
        localStorage.setItem(`voxelPresetColor${index + 1}`, currentColor); // Persist to local storage
        presetBoxes[index].style.backgroundColor = currentColor; // Update visual of the preset box
        setActivePreset(index); // Make the newly saved preset the active one
        console.log(`Saving preset color ${index + 1}: ${currentColor}`);
        console.log(`localStorage 'voxelPresetColor${index + 1}' after save:`, localStorage.getItem(`voxelPresetColor${index + 1}`));
    }
}

function addCommand(type, gx, gy, gz, oldColor = null, newColor = null, oldState = null, newState = null, commandData = null) {
    // Clear redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    history.push({ type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData });
    historyPointer++;

    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

function executeCommand(command, reverse = false) {
    const { type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData } = command;
    switch (type) {
        case 'add':
            if (reverse) {
                removeVoxel(gx, gy, gz, true); // true for fromHistory
            } else {
                addVoxel(gx, gy, gz, newColor, true); // true for fromHistory
            }
            break;
        case 'delete':
            if (reverse) {
                addVoxel(gx, gy, gz, oldColor, true); // Re-add with original color
            } else {
                removeVoxel(gx, gy, gz, true);
            }
            break;
        case 'recolor':
            if (reverse) {
                recolorVoxel(gx, gy, gz, oldColor, true);
            } else {
                recolorVoxel(gx, gy, gz, newColor, true);
            }
            break;
        case 'clearAll':
            if (reverse) {
                clearAllInternal(true); // Clear current state first without history
                // Restore old state by adding voxels back
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear directly without history
            }
            break;
        case 'fillLevel':
            if (reverse) {
                clearAllInternal(true); // Clear current state
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear current state
                newState.forEach(v => addVoxel(v.gx, gy, v.gz, v.color, true));
            }
            break;
        case 'terrainGenerate':
            if (reverse) {
                clearAllInternal(true); // Clear current state
                oldState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            } else {
                clearAllInternal(true); // Clear current state
                newState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            }
            break;
        case 'resizeGrid':
            const targetGridSize = reverse ? commandData.oldGrid : commandData.newGrid;
            GRID = targetGridSize;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            clearAllInternal(true); // Clear current state without history
            const targetState = reverse ? oldState : newState;
            targetState.forEach(v => addVoxel(v.gx, v.gy, v.gz, v.color, true));
            break;
    }
    // After executing a command, ensure the instancedMesh is updated
    // These calls are now handled by the lazy update system (frustum culling rebuilds every frame)
    // markMatrixDirty(); // Removed as animate loop rebuilds
    // markColorDirty(); // Removed as animate loop rebuilds
    rebuildHelpers(); // Ensure helpers reflect the new state
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // true for reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // false for forward
    }
}

/**
 * Helper function to set instance color using Uint8Array.
 * This function is now called only from the animate loop during frustum culling.
 * @param {number} id - The instance ID (index in the visible buffer).
 * @param {string} hex - The color in hexadecimal string format (e.g., "#RRGGBB").
 */
function setInstanceColor(id, hex){
    const c = new THREE.Color(hex);
    // Ensure the buffer is a Uint8Array before setting values
    if (instancedMesh.instanceColor.array instanceof Uint8Array) {
        instancedMesh.instanceColor.setXYZ(
            id,
            (c.r * 255) | 0,
            (c.g * 255) | 0,
            (c.b * 255) | 0
        );
    } else {
        // Fallback for Float32Array (should not happen after patch)
        instancedMesh.instanceColor.setXYZ(id, c.r, c.g, c.b);
    }
}


// Function to add a voxel (updates the voxels Map, InstancedMesh is rebuilt in animate)
function addVoxel(gx, gy, gz, colorHex, fromHistory = false) {
    // Clamp coordinates to grid boundaries
    gx = Math.max(0, Math.min(GRID - 1, gx));
    gy = Math.max(0, Math.min(GRID - 1, gy));
    gz = Math.max(0, Math.min(GRID - 1, gz));

    const k = key(gx, gy, gz);

    if (voxels.has(k)) {
        // Voxel already exists, check if color is different (recolor)
        const existingData = voxels.get(k);
        if (existingData.color !== colorHex) {
            if (!fromHistory) {
                addCommand('recolor', gx, gy, gz, existingData.color, colorHex);
            }
            voxels.set(k, { color: colorHex }); // Update color in map
        }
        // If color is the same, do nothing.
        return;
    } else {
        // New voxel, add to voxels map
        if (!fromHistory) {
            addCommand('add', gx, gy, gz, null, colorHex);
        }
        voxels.set(k, { color: colorHex }); // Store color in map
    }
}


// Function to remove a voxel (updates the voxels Map, InstancedMesh is rebuilt in animate)
function removeVoxel(gx, gy, gz, fromHistory = false) {
    const k = key(gx, gy, gz);
    if (!voxels.has(k)) {
        return; // Voxel does not exist
    }

    const removedVoxelData = voxels.get(k);

    if (!fromHistory) {
        addCommand('delete', gx, gy, gz, removedVoxelData.color, null);
    }

    voxels.delete(k); // Remove from map
}

// Function to recolor a voxel (updates the voxels Map, InstancedMesh is rebuilt in animate)
function recolorVoxel(gx, gy, gz, newColorHex, fromHistory = false) {
    const k = key(gx, gy, gz);
    if (!voxels.has(k)) {
        return; // Voxel does not exist
    }

    const existingData = voxels.get(k);
    if (existingData.color === newColorHex) {
        return; // Color is already the same
    }

    if (!fromHistory) {
        addCommand('recolor', gx, gy, gz, existingData.color, newColorHex);
    }

    voxels.set(k, { color: newColorHex }); // Update color in map
}

// NEW: Helper function to perform the actual voxel modification for a block
function performVoxelModification(baseX, baseY, baseZ, mode, color, blockSize = 1) {
    // Determine the two axes along which the block will extend
    let axis1, axis2;
    if (currentDrawingAxis === 'y') {
        axis1 = 'x';
        axis2 = 'z';
    } else if (currentDrawingAxis === 'x') {
        axis1 = 'y';
        axis2 = 'z';
    } else { // currentDrawingAxis === 'z'
        axis1 = 'x';
        axis2 = 'y';
    }

    for (let i = 0; i < blockSize; i++) {
        for (let j = 0; j < blockSize; j++) {
            let x = baseX, y = baseY, z = baseZ;

            // Adjust coordinates based on block size and current drawing axis
            if (axis1 === 'x') x = baseX + i;
            else if (axis1 === 'y') y = baseY + i;
            else if (axis1 === 'z') z = baseZ + i;

            if (axis2 === 'x') x = baseX + j;
            else if (axis2 === 'y') y = baseY + j;
            else if (axis2 === 'z') z = baseZ + j;

            // Ensure the fixed axis remains at its base coordinate
            if (currentDrawingAxis === 'x') x = baseX;
            else if (currentDrawingAxis === 'y') y = baseY;
            else if (currentDrawingAxis === 'z') z = baseZ;

            // Clamp coordinates to grid boundaries
            const clampedX = Math.max(0, Math.min(GRID - 1, x));
            const clampedY = Math.max(0, Math.min(GRID - 1, y));
            const clampedZ = Math.max(0, Math.min(GRID - 1, z));

            const voxelKey = key(clampedX, clampedY, clampedZ);
            const actualHasVoxel = voxels.has(voxelKey);

            switch (mode) {
                case Modes.ADD:
                    if (!actualHasVoxel) {
                        addVoxel(clampedX, clampedY, clampedZ, color);
                    }
                    break;
                case Modes.DELETE:
                    if (actualHasVoxel) {
                        removeVoxel(clampedX, clampedY, clampedZ);
                    }
                    break;
                case Modes.DRAW:
                    if (actualHasVoxel && voxels.get(voxelKey).color !== color) {
                        recolorVoxel(clampedX, clampedY, clampedZ, color);
                    }
                    break;
            }
        }
    }
}

// NEW: DDA (Digital Differential Analyzer) for 3D Line Drawing
function drawLineOfVoxels(start, end, mode, color, blockSize = 1) {
    let x = start.gx;
    let y = start.gy;
    let z = start.gz;
    const x2 = end.gx;
    const y2 = end.gy;
    const z2 = end.gz;

    const dx = x2 - x;
    const dy = y2 - y;
    const dz = z2 - z;

    const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

    if (steps === 0) {
        performVoxelModification(x, y, z, mode, color, blockSize);
        return;
    }

    const x_inc = dx / steps;
    const y_inc = dy / steps;
    const z_inc = dz / steps;

    for (let i = 0; i <= steps; i++) {
        // Apply modification for the base of the block
        performVoxelModification(Math.round(x), Math.round(y), Math.round(z), mode, color, blockSize);
        x += x_inc;
        y += y_inc;
        z += z_inc;
    }
}


// NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Voxels
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            // Dispose old geometry
            if (previewVoxelMesh.geometry) {
                previewVoxelMesh.geometry.dispose();
            }

            const blockDimX = (currentDrawingAxis === 'y' || currentDrawingAxis === 'z') ? currentBlockSize * VS : VS;
            const blockDimY = (currentDrawingAxis === 'x' || currentDrawingAxis === 'z') ? currentBlockSize * VS : VS;
            const blockDimZ = (currentDrawingAxis === 'x' || currentDrawingAxis === 'y') ? currentBlockSize * VS : VS;

            const tempGeometry = new THREE.BoxGeometry(blockDimX, blockDimY, blockDimZ);
            previewVoxelMesh.geometry = tempGeometry;

            // Calculate the center of the block relative to its (x,y,z) base corner
            const centerX = x * VS + blockDimX / 2;
            const centerY = y * VS + blockDimY / 2;
            const centerZ = z * VS + blockDimZ / 2;

            previewVoxelMesh.position.set(centerX, centerY, centerZ);

            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor); // Vorschau-Farbe an aktuelle Farbe anpassen
            // Optional: Passe die Opazit√§t basierend auf dem Modus an
            if (currentMode === Modes.DELETE) {
                previewVoxelMaterial.opacity = 0.2; // Weniger sichtbar beim L√∂schen
            } else {
                previewVoxelMaterial.opacity = 0.5; // Standard Opazit√§t
            }
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}
// ENDE NEU

// NEW helper function to set the fixed drag plane parameters
function setFixedDragPlane(clientX, clientY, mode) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);
    // Raycast against the instancedMesh for hit detection
    const intersects = raycaster.intersectObject(instancedMesh);

    if (intersects.length > 0) {
        const hit = intersects[0];
        // The face normal is in world coordinates for the hit face
        const hitNormal = hit.face.normal;
        // The instanceId is available on the hit object for InstancedMesh
        // const instanceId = hit.instanceId; // Not directly used for lookup anymore

        // Retrieve the matrix of the hit instance (need to iterate through voxels map to find it)
        // This is tricky with frustum culling. For simplicity, we'll assume the hit
        // voxel's position is sufficient to determine its grid coordinates.
        const hitWorldPosition = hit.point.clone().addScaledVector(hitNormal, -0.001); // Small offset to be inside the voxel

        // Convert world position to grid coordinates (assuming VS=1)
        const hitVoxelX = Math.floor(hitWorldPosition.x / VS);
        const hitVoxelY = Math.floor(hitWorldPosition.y / VS);
        const hitVoxelZ = Math.floor(hitWorldPosition.z / VS);


        let level, axis;

        const absNx = Math.abs(hitNormal.x);
        const absNy = Math.abs(hitNormal.y);
        const absNz = Math.abs(hitNormal.z);

        if (mode === Modes.ADD) {
            // When adding, we want to place on the *next* layer relative to the hit voxel
            // This means using the hit voxel's coordinate + the normal component for that axis
            if (absNy > absNx && absNy > absNz) { // Hit top/bottom face (Y-axis)
                axis = 'y';
                level = hitVoxelY + Math.round(hitNormal.y);
            } else if (absNx > absNy && absNx > absNz) { // Hit side face (X-axis)
                axis = 'x';
                level = hitVoxelX + Math.round(hitNormal.x);
            } else { // Hit side face (Z-axis)
                axis = 'z';
                level = hitVoxelZ + Math.round(hitNormal.z);
            }
        } else { // DELETE or DRAW mode: target the layer *of* the hit voxel
            // For delete/draw, the fixed plane should be at the level of the hit voxel
            if (absNy > absNx && absNy > absNz) {
                axis = 'y';
                level = hitVoxelY;
            } else if (absNx > absNy && absNx > absNz) {
                axis = 'x';
                level = hitVoxelX;
            } else {
                axis = 'z';
                level = hitVoxelZ;
            }
        }
        fixedDragPlaneParams.level = level;
        fixedDragPlaneParams.axis = axis;
    } else {
        // If no voxel is hit, default to the current active drawing level and axis
        // This is for drawing in empty space
        fixedDragPlaneParams.axis = currentDrawingAxis;
        fixedDragPlaneParams.level = activeDrawingLevel[currentDrawingAxis];
    }
}

// NEW: Magnetic targeting helper for touch assist
function getNearestVoxelCenter(intersectionPoint) {
    const gx = Math.floor(intersectionPoint.x / VS);
    const gy = Math.floor(intersectionPoint.y / VS);
    const gz = Math.floor(intersectionPoint.z / VS);

    // Calculate the center of the grid cell
    return new THREE.Vector3(
        gx * VS + HALF,
        gy * VS + HALF,
        gz * VS + HALF
    );
}


// Modified calculateTargetVoxelCoords to use fixedDragPlaneParams and touchAssist
function calculateTargetVoxelCoords(clientX, clientY, mode, isDragging, isStackingAdd, pointerType) { // Added pointerType
    if (isPointerLocked) return null;

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    // Exclude templateImageMesh from raycasting for voxel operations if it's locked
    const objectsToIntersect = [instancedMesh];
    if (templateImageMesh && !templateImageData.locked) {
        // If template is NOT locked, we still don't want to interact with it for VOXEL placement.
        // It's purely a visual guide. So, we never add it to objectsToIntersect for voxel ops.
    }

    let targetVoxelCoords = null;
    let intersectionPoint = new THREE.Vector3(); // Initialize here to prevent null errors

    // Special case: Ctrl-drag for stacking
    if (isStackingAdd) {
        const intersects = raycaster.intersectObjects(objectsToIntersect); // Use objectsToIntersect
        if (intersects.length > 0) {
            const hit = intersects[0];
            const hitWorldPosition = hit.point.clone().addScaledVector(hit.face.normal, -0.001); // Offset slightly into the voxel
            const gx = Math.floor(hitWorldPosition.x / VS);
            const gz = Math.floor(hitWorldPosition.z / VS);
            let highestY = -1;
            for (let y = 0; y < GRID; y++) {
                if (voxels.has(key(gx, y, gz))) {
                    highestY = y;
                }
            }
            targetVoxelCoords = { gx: gx, gy: highestY + 1, gz: gz };
            intersectionPoint.set(targetVoxelCoords.gx * VS + HALF, targetVoxelCoords.gy * VS + HALF, targetVoxelCoords.gz * VS + HALF); // Set intersectionPoint for touch assist

        } else {
            // If stacking and nothing hit, use the active drawing level as a fallback plane
            const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -(activeDrawingLevel.y * VS));
            const intersectResult = raycaster.ray.intersectPlane(plane, intersectionPoint);
            if(intersectResult){ // Check if intersection occurred
                targetVoxelCoords = {
                    gx: Math.floor(intersectionPoint.x / VS),
                    gy: activeDrawingLevel.y,
                    gz: Math.floor(intersectionPoint.z / VS)
                };
            } else {
                return null; // Cannot determine stacking target without intersection
            }
        }
    }
    // Fixed plane drawing for all other drags (Shift-drag, DblTap-drag, normal ADD/DELETE/DRAW drag)
    else if (isDragging && fixedDragPlaneParams.level !== null && fixedDragPlaneParams.axis !== null) {
        let planeNormal = new THREE.Vector3();
        if (fixedDragPlaneParams.axis === 'y') planeNormal.set(0, 1, 0);
        else if (fixedDragPlaneParams.axis === 'x') planeNormal.set(1, 0, 0);
        else if (fixedDragPlaneParams.axis === 'z') planeNormal.set(0, 0, 1);
        const drawingPlane = new THREE.Plane(planeNormal, -(fixedDragPlaneParams.level * VS));

        const intersectResult = raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);
        if (intersectResult) { // Check if intersection occurred
            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // Force the coordinate on the fixed axis to be the fixed level
            if (fixedDragPlaneParams.axis === 'y') gy = fixedDragPlaneParams.level;
            else if (fixedDragPlaneParams.axis === 'x') gx = fixedDragPlaneParams.level;
            else if (fixedDragPlaneParams.axis === 'z') gz = fixedDragPlaneParams.level;

            targetVoxelCoords = { gx, gy, gz };
        } else {
            return null; // No intersection with fixed plane
        }
    }
    // Single click or initial point of drag (non-stacking, non-fixed-plane drag)
    else {
        const intersects = raycaster.intersectObjects(objectsToIntersect); // Use objectsToIntersect
        if (intersects.length > 0) {
            const hit = intersects[0];
            const hitNormal = hit.face.normal;
            intersectionPoint.copy(hit.point); // Store the raw intersection point

            // Convert hit point to grid coordinates
            const hitVoxelX = Math.floor(hit.point.x / VS);
            const hitVoxelY = Math.floor(hit.point.y / VS);
            const hitVoxelZ = Math.floor(hit.point.z / VS);

            if (mode === Modes.ADD) {
                // For ADD, place on the face normal to the hit voxel
                targetVoxelCoords = {
                    gx: hitVoxelX + Math.round(hitNormal.x),
                    gy: hitVoxelY + Math.round(hitNormal.y),
                    gz: hitVoxelZ + Math.round(hitNormal.z)
                };
            } else { // DELETE or DRAW
                // For DELETE/DRAW, target the hit voxel itself
                targetVoxelCoords = {
                    gx: hitVoxelX,
                    gy: hitVoxelY,
                    gz: hitVoxelZ
                };
            }
        } else if (mode === Modes.ADD) {
            // Fallback for ADD when nothing is hit, use activeDrawingLevel
            let planeNormal = new THREE.Vector3();
            if (currentDrawingAxis === 'y') planeNormal.set(0, 1, 0);
            else if (currentDrawingAxis === 'x') planeNormal.set(1, 0, 0);
            else if (currentDrawingAxis === 'z') planeNormal.set(0, 0, 1);
            const drawingPlane = new THREE.Plane(planeNormal, -(activeDrawingLevel[currentDrawingAxis] * VS));

            const intersectResult = raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);
            if (intersectResult) { // Check if intersection occurred
                let gx = Math.floor(intersectionPoint.x / VS);
                let gy = Math.floor(intersectionPoint.y / VS);
                let gz = Math.floor(intersectionPoint.z / VS);

                if (currentDrawingAxis === 'y') gy = activeDrawingLevel.y;
                else if (currentDrawingAxis === 'x') gx = activeDrawingLevel.x;
                else if (currentDrawingAxis === 'z') gz = activeDrawingLevel.z;

                targetVoxelCoords = { gx, gy, gz };
            } else {
                return null; // No intersection with fallback plane
            }
        }
    }

    if (targetVoxelCoords) {
        // Apply touch assist (magnetic targeting) if enabled for touch devices
        if (pointerType === 'touch' && touchAssistEnabled && intersectionPoint) { // Use pointerType
            const snappedPos = getNearestVoxelCenter(intersectionPoint);
            targetVoxelCoords.gx = Math.round(snappedPos.x / VS - HALF);
            targetVoxelCoords.gy = Math.round(snappedPos.y / VS - HALF);
            targetVoxelCoords.gz = Math.round(snappedPos.z / VS - HALF);
        }

        // Clamp coordinates to grid boundaries
        targetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gx));
        targetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gy));
        targetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gz));
        return targetVoxelCoords;
    }
    return null;
}

function clearAllInternal(fromHistory = false) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        addCommand('clearAll', null, null, null, null, null, oldState, []);
    }
    voxels.clear();
    instancedMesh.count = 0; // Reset count for frustum culling rebuild
    // markMatrixDirty(); // Removed
    // markColorDirty(); // Removed
    rebuildHelpers(); // Ensure helpers are reset or updated appropriately
}

function clearAll() {
    clearAllInternal(false); // User initiated clear, adds to history
}


function fillActiveLevel() {
    // Capture the current state before the fill for undo/redo
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    // Clear existing voxels on the plane for fill, without adding to history
    const voxelsToRemove = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x; // Use x as y-coordinate for horizontal plane
                gz = z; // Use z as z-coordinate
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z; // Use z as y-coordinate for horizontal plane
                gz = activeDrawingLevel.z;
            }
            const k = key(gx, gy, gz);
            if (voxels.has(k)) {
                voxelsToRemove.push(k);
            }
        }
    }
    // Remove all existing voxels on the plane
    voxelsToRemove.forEach(k => {
        const [gx, gy, gz] = parseKey(k);
        removeVoxel(gx, gy, gz, true); // true for fromHistory, to avoid adding individual delete commands
    });


    // Add new voxels for the fill
    const newState = [];
    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x;
                gz = z;
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z;
                gz = activeDrawingLevel.z;
            }
            addVoxel(gx, gy, gz, currentColor, true); // true for fromHistory, to avoid adding individual add commands
            newState.push({ gx, gy, gz, color: currentColor });
        }
    }
    
    // Update InstancedMesh once after all operations
    // markMatrixDirty(); // Removed
    // markColorDirty(); // Removed

    // Add a single command for the entire fill operation
    addCommand('fillLevel', null, null, null, null, null, oldState, newState);
}


// With InstancedMesh, this function primarily signals updates.
// The actual matrix and color updates happen in addVoxel, removeVoxel, recolorVoxel.
// With frustum culling, this function is less relevant as animate loop rebuilds.
function updateVoxelGeometry() {
    // These flags are set in addVoxel, removeVoxel, recolorVoxel.
    // Calling them here ensures they are set if any batch operation (like loadJSON)
    // bypasses individual updates.
    // markMatrixDirty(); // Removed
    // markColorDirty(); // Removed
}


function saveJSON() {
    const data = {};
    voxels.forEach((value, k) => { // k is now a number
        const [gx,gy,gz] = parseKey(k); // Parse the numeric key back to coords
        data[`${gx},${gy},${gz}`] = value.color; // Save as string key
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        terrainHeightScale: terrainHeightScale,
        terrainFrequency: terrainFrequency,
        terrainOctaves: terrainOctaves,
        terrainLacunarity: terrainLacunarity,
        terrainGain: terrainGain,
        terrainSeed: terrainSeed,
        moveSpeed: moveSpeed, // Save fly speed
        currentBlockSize: currentBlockSize, // Save current block size
        templateImageData: templateImageData // NEW: Save template image data
    };

    const projectData = {
        voxels: data,
        settings: settings
    };

    const json = JSON.stringify(projectData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function resetToDefaultProject() {
    clearAllInternal(true); // Clear everything without adding to history
    GRID = 10;
    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    localStorage.setItem('voxelEditorGridSize', GRID);

    currentColor = '#ffffff';
    document.getElementById('color-picker').value = currentColor;
    localStorage.setItem('voxelEditorColor', currentColor);

    activeDrawingLevel = { x: 0, y: 0, z: 0 };
    currentDrawingAxis = 'y';
    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);

    moveSpeed = 0.1;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

    currentBlockSize = 1;
    setBlockSize(currentBlockSize);
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);

    // Reset terrain settings
    terrainHeightScale = 10;
    terrainFrequency = 0.05;
    terrainOctaves = 4;
    terrainLacunarity = 2.0;
    terrainGain = 0.5;
    terrainSeed = '';
    hasUserTypedSeed = (terrainSeed !== '');
    document.getElementById('terrain-height-scale').value = terrainHeightScale;
    document.getElementById('terrain-frequency').value = terrainFrequency;
    document.getElementById('terrain-octaves').value = terrainOctaves;
    document.getElementById('terrain-lacunarity').value = terrainLacunarity;
    document.getElementById('terrain-gain').value = terrainGain;
    document.getElementById('terrain-seed').value = terrainSeed;
    localStorage.setItem('voxelEditorTerrainHeightScale', terrainHeightScale);
    localStorage.setItem('voxelEditorTerrainFrequency', terrainFrequency);
    localStorage.setItem('voxelEditorTerrainOctaves', terrainOctaves);
    localStorage.setItem('voxelEditorTerrainLacunarity', terrainLacunarity);
    localStorage.setItem('voxelEditorTerrainGain', terrainGain);
    localStorage.setItem('voxelEditorTerrainSeed', terrainSeed);

    // Reset preset colors to defaults
    presetColors[0] = '#8B4513';
    presetColors[1] = '#708237';
    presetColors[2] = '#6495ED';
    localStorage.setItem('voxelPresetColor1', presetColors[0]);
    localStorage.setItem('voxelPresetColor2', presetColors[1]);
    localStorage.setItem('voxelPresetColor3', presetColors[2]);
    presetBoxes.forEach((box, i) => {
        box.style.backgroundColor = presetColors[i];
        box.classList.remove('active');
    });
    activePresetIndex = -1;

    removeImageTemplate(true); // Remove template without history logging

    history.length = 0;
    historyPointer = -1;

    rebuildHelpers();
    resetCameraPosition();
    console.log('Project reset to default state.');
}


function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            const loadedVoxels = projectData.voxels;
            const loadedSettings = projectData.settings;

            // Clear current state and history before loading new project
            clearAllInternal(true); // Clear without adding to history

            // Remove existing template image if any
            removeImageTemplate(true); // true to prevent history logging for this internal operation

            // Load settings first to get the correct GRID size
            if (loadedSettings) {
                GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
                localStorage.setItem('voxelEditorGridSize', GRID); // Ensure it's saved back
                console.log("Loaded GRID size from JSON:", GRID);
            } else {
                console.warn("No settings found in JSON, using default GRID size.");
            }

            // Dispose old InstancedMesh if it exists and re-initialize
            if (instancedMesh) {
                scene.remove(instancedMesh);
                instancedMesh.geometry.dispose();
                instancedMesh.material.dispose();
                instancedMesh = null; // Ensure reference is cleared
            }

            // Re-initialize InstancedMesh with potentially new GRID size
            const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
            let meshMaterial = new THREE.MeshLambertMaterial();
            
            meshMaterial.onBeforeCompile = (shader) => {
                shader.vertexShader = `
                    varying vec3 vInstanceColor;
                    ${shader.vertexShader}
                `.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                );
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <color_vertex>',
                    `
                    #include <color_vertex>
                    #ifdef USE_INSTANCING_COLOR
                        vInstanceColor = instanceColor;
                    #else
                        vInstanceColor = vec3(1.0);
                    #endif
                    `
                );
                shader.fragmentShader = `
                    varying vec3 vInstanceColor;
                    ${shader.fragmentShader}
                `.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
                );
            };

            const maxVoxelsForLoadedGrid = GRID * GRID * GRID; // Max instances based on loaded GRID
            instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxVoxelsForLoadedGrid);
            
            if (!instancedMesh.instanceMatrix) {
                instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 16), 16);
                instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix);
            }
            const colBuf = new Uint8Array(maxVoxelsForLoadedGrid * 3);
            instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colBuf, 3, true);
            instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor);

            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            scene.add(instancedMesh);
            instancedMesh.count = 0; // Reset instance count


            // Load voxels into the map
            for (const k in loadedVoxels) {
                const colorValue = loadedVoxels[k];
                const parts = k.split(',').map(Number); 
                if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                    const gx = parts[0];
                    const gy = parts[1];
                    const gz = parts[2];

                    // Only add if within the bounds of the newly loaded GRID size
                    if (gx < GRID && gy < GRID && gz < GRID) {
                        voxels.set(key(gx, gy, gz), { color: colorValue }); // Store color in map
                    }
                }
            }
            // The instancedMesh.count will be set in the animate loop due to frustum culling.
            // No need to set it here.

            // Continue loading other settings after GRID is set and InstancedMesh is re-initialized
            if (loadedSettings) {
                if (loadedSettings.cameraPosition) {
                    cam.position.fromArray(loadedSettings.cameraPosition);
                }
                if (loadedSettings.cameraQuaternion) {
                    cam.quaternion.fromArray(loadedSettings.cameraQuaternion);
                    euler.setFromQuaternion(cam.quaternion, 'YXZ');
                }
                if (loadedSettings.activeDrawingLevel) {
                    activeDrawingLevel = { ...loadedSettings.activeDrawingLevel };
                    localStorage.setItem('voxelEditorActiveDrawingLevelX', activeDrawingLevel.x);
                    localStorage.setItem('voxelEditorActiveDrawingLevelY', activeDrawingLevel.y);
                    localStorage.setItem('voxelEditorActiveDrawingLevelZ', activeDrawingLevel.z);
                }
                if (loadedSettings.currentDrawingAxis) {
                    currentDrawingAxis = loadedSettings.currentDrawingAxis;
                    localStorage.setItem('voxelEditorCurrentDrawingAxis', currentDrawingAxis);
                }
                updateGridHelperPosition();

                currentColor = loadedSettings.currentColor || '#ffffff';
                document.getElementById('color-picker').value = currentColor;

                if (loadedSettings.presetColors) {
                    for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                        presetColors[i] = loadedSettings.presetColors[i];
                        document.getElementById(`color-preset-${i + 1}`).style.backgroundColor = presetColors[i];
                        localStorage.setItem(`voxelPresetColor${i + 1}`, presetColors[i]);
                    }
                }
                setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);

                terrainHeightScale = loadedSettings.terrainHeightScale !== undefined ? loadedSettings.terrainHeightScale : 10;
                terrainFrequency = loadedSettings.terrainFrequency !== undefined ? loadedSettings.terrainFrequency : 0.05;
                terrainOctaves = loadedSettings.terrainOctaves !== undefined  ? loadedSettings.octaves : 4;
                terrainLacunarity = loadedSettings.lacunarity !== undefined ? loadedSettings.lacunarity : 2.0;
                terrainGain = loadedSettings.gain !== undefined ? loadedSettings.gain : 0.5;
                terrainSeed = loadedSettings.terrainSeed !== undefined ? loadedSettings.terrainSeed : '';

                document.getElementById('terrain-height-scale').value = terrainHeightScale;
                document.getElementById('terrain-frequency').value = terrainFrequency;
                document.getElementById('terrain-octaves').value = terrainOctaves;
                document.getElementById('terrain-lacunarity').value = terrainLacunarity;
                document.getElementById('terrain-gain').value = terrainGain;
                document.getElementById('terrain-seed').value = terrainSeed;
                hasUserTypedSeed = (terrainSeed !== '');
                localStorage.setItem('voxelEditorTerrainHeightScale', terrainHeightScale);
                localStorage.setItem('voxelEditorTerrainFrequency', terrainFrequency);
                localStorage.setItem('voxelEditorTerrainOctaves', terrainOctaves);
                localStorage.setItem('voxelEditorTerrainLacunarity', terrainLacunarity);
                localStorage.setItem('voxelEditorTerrainGain', terrainGain);
                localStorage.setItem('voxelEditorTerrainSeed', terrainSeed);

                if (loadedSettings.moveSpeed !== undefined) {
                    moveSpeed = loadedSettings.moveSpeed;
                    document.getElementById('fly-speed-slider').value = moveSpeed;
                    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                    localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
                }

                if (loadedSettings.currentBlockSize !== undefined) {
                    setBlockSize(loadedSettings.currentBlockSize);
                    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
                }

                if (loadedSettings.templateImageData) {
                    templateImageData = loadedSettings.templateImageData;
                    console.log("Loading template image data:", templateImageData);
                    const loader = new THREE.TextureLoader();
                    loader.load(templateImageData.src, (texture) => {
                        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
                        const geometry = new THREE.PlaneGeometry(templateImageData.scaledWidth, templateImageData.scaledHeight);
                        if (templateImageMesh) {
                            scene.remove(templateImageMesh);
                            templateImageMesh.geometry.dispose();
                            templateImageMesh.material.dispose();
                        }
                        templateImageMesh = new THREE.Mesh(geometry, material);
                        templateImageMesh.position.fromArray(templateImageData.position);
                        templateImageMesh.rotation.fromArray(templateImageData.rotation);
                        templateImageMesh.scale.fromArray(templateImageData.scale);
                        templateImageMesh.renderOrder = -1;
                        scene.add(templateImageMesh);
                        document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
                        document.getElementById('lockImageTemplateCheckbox').checked = templateImageData.locked;
                        toggleLockImageTemplate(true);
                    }, undefined, (err) => {
                        console.error('Error loading template image texture:', err);
                        templateImageMesh = null;
                        templateImageData = null;
                        document.getElementById('removeImageTemplateBtn').style.display = 'none';
                        document.getElementById('lockImageTemplateCheckbox').checked = false;
                    });
                }

                noise2D = new ValueNoise2D(terrainSeed);
            }

            history.length = 0;
            historyPointer = -1;

            console.log('Project loaded successfully.');
            resetCameraPosition();
        } catch (error) {
            console.error('Error loading JSON file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine g√ºltige Voxel-Projekt-JSON-Datei handelt. Fehler: ' + error.message);
            resetToDefaultProject(); // Reset to safe state on error
        }
    };
    reader.readAsText(file);
}


function exportSTL() {
    if (voxels.size === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const geometriesToMerge = [];
    const tempBoxGeometry = new THREE.BoxGeometry(VS, VS, VS);
    const tempMatrix = new THREE.Matrix4();
    const tempColorExport = new THREE.Color();

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        
        dummy.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        dummy.updateMatrix();
        tempMatrix.copy(dummy.matrix); // Use dummy for matrix calculation

        tempColorExport.set(data.color);

        const instanceGeometry = tempBoxGeometry.clone();
        instanceGeometry.applyMatrix4(tempMatrix);

        const vertexColorArray = [];
        for (let j = 0; j < instanceGeometry.attributes.position.count; j++) {
            vertexColorArray.push(tempColorExport.r, tempColorExport.g, tempColorExport.b);
        }
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColorArray, 3));
        geometriesToMerge.push(instanceGeometry);
    });

    let mergedGeometry;
    if (geometriesToMerge.length > 0) {
        mergedGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometriesToMerge, true);
    } else {
        mergedGeometry = new THREE.BufferGeometry();
    }

    const tempMesh = new THREE.Mesh(mergedGeometry, instancedMesh.material);

    const exporter = new THREE.STLExporter();
    const result = exporter.parse(tempMesh);

    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    tempBoxGeometry.dispose();
    if (mergedGeometry) mergedGeometry.dispose();
    showMessageModal('Export erfolgreich', 'STL-Modell erfolgreich exportiert!');
}

// NEW: Function to import STL
function importSTL(event) {
    const file = event.target.files[0];
    if (!file) {
        console.log("No STL file selected.");
        return;
    }

    console.log(`Attempting to import STL file: ${file.name}, size: ${file.size} bytes`);

    const reader = new FileReader();
    reader.onload = (e) => {
        console.log("STL file read successfully.");
        const loader = new THREE.STLLoader();
        try {
            const geometry = loader.parse(e.target.result);
            console.log("STL geometry parsed successfully.");
            console.log("STL geometry vertex count:", geometry.attributes.position.count);

            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const size = new THREE.Vector3();
            bbox.getSize(size);
            console.log("STL geometry bounding box:", bbox);
            console.log("STL geometry size (width, height, depth):", size.x, size.y, size.z);


            // Clear current voxels before importing
            clearAllInternal(true);
            console.log("Cleared current scene for STL import.");

            const oldState = [...voxels.entries()].map(([id, data]) => {
                const parts = parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            const maxDim = Math.max(size.x, size.y, size.z);
            const scaleFactor = (maxDim > 0) ? (GRID * VS) / maxDim : 1;
            
            const offset = new THREE.Vector3(
                -bbox.min.x * scaleFactor + (GRID * VS - size.x * scaleFactor) / 2,
                -bbox.min.y * scaleFactor + (GRID * VS - size.y * scaleFactor) / 2,
                -bbox.min.z * scaleFactor + (GRID * VS - size.z * scaleFactor) / 2
            );
            console.log('Calculated scaleFactor:', scaleFactor, 'offset:', offset);

            const tempMesh = new THREE.Mesh(geometry);
            tempMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            tempMesh.position.copy(offset);
            tempMesh.updateMatrixWorld(true);

            const newVoxels = [];
            const color = new THREE.Color(currentColor);

            let addedVoxelCount = 0;
            // Iterate through grid cells and check if center is inside mesh
            // This is a basic approach and might not capture all details or handle complex meshes perfectly.
            const tempVoxelPosition = new THREE.Vector3();
            for (let x = 0; x < GRID; x++) {
                for (let y = 0; y < GRID; y++) {
                    for (let z = 0; z < GRID; z++) {
                        tempVoxelPosition.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
                        // Convert point to local space of the imported mesh for bounding box check
                        const localPoint = tempVoxelPosition.clone().applyMatrix4(tempMesh.matrixWorld.clone().invert());

                        if (geometry.boundingBox.containsPoint(localPoint)) {
                            addVoxel(x, y, z, color.getHex(), true);
                            newVoxels.push({ gx: x, gy: y, gz: z, color: color.getHex() });
                            addedVoxelCount++;
                        }
                    }
                }
            }
            console.log('Number of newVoxels after STL voxelization:', newVoxels.length);
            console.log('Total voxels added to scene from STL:', addedVoxelCount);

            // updateVoxelGeometry(); // No longer needed for frustum culling
            rebuildHelpers();
            resetCameraPosition();

            addCommand('importSTL', null, null, null, null, null, oldState, newVoxels);
            showMessageModal('Import erfolgreich', `STL-Modell erfolgreich importiert und in ${addedVoxelCount} Voxel umgewandelt. Beachten Sie, dass die Voxelisierung eine Ann√§herung ist und bei komplexen Modellen zu Detailverlust f√ºhren kann.`);

        } catch (error) {
            console.error('Error loading STL file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der STL-Datei. Stellen Sie sicher, dass es sich um eine g√ºltige STL-Datei handelt. Fehler: ' + error.message);
            resetToDefaultProject(); // Reset to safe state on error
        }
    };
    reader.readAsArrayBuffer(file);
}

// NEW: Function to export OBJ
function exportOBJ() {
    if (voxels.size === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const voxelsToExport = [];
    let maxX = 0, maxY = 0, maxZ = 0;

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        voxelsToExport.push({ x, y, z, c: 1 }); // VoxelShaperIO.voxToOBJ doesn't use color index directly for OBJ
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport);
    const objText = VoxelShaperIO.voxToOBJ(voxModel, VS); // Use VS (1) as cubeSize

    VoxelShaperIO.saveBlob(objText, 'voxel_model.obj');
    showMessageModal('Export erfolgreich', 'OBJ-Modell erfolgreich exportiert!');
}

// NEW: Function to import OBJ
function importOBJ(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const objText = e.target.result;
            const voxModel = VoxelShaperIO.objToVox(objText, VS); // Use VS (1) as voxelSize

            // Clear current voxels before importing
            clearAllInternal(true);

            const oldState = [...voxels.entries()].map(([id, data]) => {
                const parts = parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            // Update GRID size based on imported model
            GRID = Math.max(voxModel.sizeX, voxModel.sizeY, voxModel.sizeZ, 10); // Ensure minimum GRID size
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            const newVoxels = [];
            // Use current color for imported voxels as OBJ has no inherent palette in this context
            const importColor = currentColor;

            voxModel.voxels.forEach(v => {
                // Ensure imported voxels are within new GRID bounds
                if (v.x >= 0 && v.x < GRID && v.y >= 0 && v.y < GRID && v.z >= 0 && v.z < GRID) {
                    addVoxel(v.x, v.y, v.z, importColor, true);
                    newVoxels.push({ gx: v.x, gy: v.y, gz: v.z, color: importColor });
                }
            });

            // updateVoxelGeometry(); // No longer needed for frustum culling
            rebuildHelpers();
            resetCameraPosition();

            addCommand('importOBJ', null, null, null, null, null, oldState, newVoxels);
            showMessageModal('Import erfolgreich', 'OBJ-Modell erfolgreich importiert und in Voxel umgewandelt. Beachten Sie, dass die Voxelisierung eine Ann√§herung ist und bei komplexen Modellen zu Detailverlust f√ºhren kann.');

        } catch (error) {
            console.error('Error loading OBJ file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der OBJ-Datei. Stellen Sie sicher, dass es sich um eine g√ºltige OBJ-Datei handelt. Fehler: ' + error.message);
            resetToDefaultProject(); // Reset to safe state on error
        }
    };
    reader.readAsText(file);
}

// NEW: Function to export VOX
function exportVOX() {
    if (voxels.size === 0) {
        showMessageModal('Export fehlgeschlagen', 'Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const voxelsToExport = [];
    const uniqueColors = new Map(); // Map<hexColor, paletteIndex>
    let paletteIndexCounter = 1; // MagicaVoxel palette indices are 1-based (0 is empty)
    const palette = new Uint32Array(256);
    palette[0] = 0x00000000; // Transparent black for index 0

    let maxX = 0, maxY = 0, maxZ = 0;

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        // Assign palette index
        let paletteIndex = uniqueColors.get(data.color);
        if (paletteIndex === undefined) {
            if (paletteIndexCounter < 256) {
                paletteIndex = paletteIndexCounter;
                uniqueColors.set(data.color, paletteIndex);
                // Convert hex to RGBA for palette, ensure alpha is FF
                palette[paletteIndex] = (parseInt(data.color.substring(1), 16) << 8) | 0xFF;
                paletteIndexCounter++;
            } else {
                // Fallback if palette is full, use a default color (e.g., index 1)
                paletteIndex = 1;
                console.warn(`Palette full. Color ${data.color} will be mapped to palette index 1.`);
            }
        }
        voxelsToExport.push({ x, y, z, c: paletteIndex });
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
        maxZ = Math.max(maxZ, z);
    });

    const voxModel = new VoxelShaperIO.VoxModel(maxX + 1, maxY + 1, maxZ + 1, voxelsToExport, palette);
    const arrayBuffer = VoxelShaperIO.buildVox(voxModel);

    VoxelShaperIO.saveBlob(arrayBuffer, 'voxel_model.vox');
    showMessageModal('Export erfolgreich', 'VOX-Modell erfolgreich exportiert!');
}

// NEW: Function to import VOX
function importVOX(event) {
    const file = event.target.files[0];
    if (!file) {
        console.log("No VOX file selected.");
        return;
    }

    console.log(`Attempting to import VOX file: ${file.name}, size: ${file.size} bytes`);

    const reader = new FileReader();
    reader.onload = (e) => {
        console.log("VOX file read successfully.");
        try {
            const arrayBuffer = e.target.result;
            const voxModel = VoxelShaperIO.parseVox(arrayBuffer);

            console.log("VOX Model parsed:", voxModel);
            console.log("VOX Model dimensions (sizeX, sizeY, sizeZ):", voxModel ? voxModel.sizeX : 'N/A', voxModel ? voxModel.sizeY : 'N/A', voxModel ? voxModel.sizeZ : 'N/A');
            console.log("Number of voxels in VOX Model:", voxModel && Array.isArray(voxModel.voxels) ? voxModel.voxels.length : 'voxels property missing or not an array');
            if (voxModel && voxModel.palette) {
                console.log('VOX palette (first 5):', Array.from(voxModel.palette.slice(0, 5)).map(rgba => VoxelShaperIO.rgbaToHex(rgba)));
            }


            // --- NEU: Umfassendere Validierung des geparsten Modells ---
            // Check for fundamental structural validity first
            if (!voxModel || !Array.isArray(voxModel.voxels)) {
                console.warn("Invalid VOX model structure received from parser.");
                showMessageModal('Import fehlgeschlagen', 'Die geladene VOX-Datei hat eine ung√ºltige Struktur, die von der Bibliothek nicht verarbeitet werden kann. √úberpr√ºfen Sie die Konsole f√ºr weitere Details.');
                resetToDefaultProject(); // Reset to safe state on error
                return;
            }

            // Handle empty model gracefully
            if (voxModel.voxels.length === 0) {
                clearAllInternal(true); // Clear current scene
                GRID = 10; // Set a default grid size
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
                localStorage.setItem('voxelEditorGridSize', GRID);
                rebuildHelpers();
                resetCameraPosition();
                showMessageModal('Import abgeschlossen', 'Die VOX-Datei wurde erfolgreich importiert, enthielt jedoch keine Voxel. Die Szene wurde auf eine leere Standardgr√∂√üe zur√ºckgesetzt.');
                return;
            }
            // --- ENDE NEU ---

            let offsetX = 0, offsetY = 0, offsetZ = 0;
            
            // Calculate min coordinates only if voxels exist
            const minX = Math.min(...voxModel.voxels.map(v => v.x));
            const minY = Math.min(...voxModel.voxels.map(v => v.y));
            const minZ = Math.min(...voxModel.voxels.map(v => v.z));
            console.log(`Original Min Voxel Coords: X=${minX}, Y=${minY}, Z=${minZ}`);

            // Calculate offsets to make all coordinates non-negative
            if (minX < 0) offsetX = -minX;
            if (minY < 0) offsetY = -minY;
            if (minZ < 0) offsetZ = -minZ;

            if (offsetX > 0 || offsetY > 0 || offsetZ > 0) {
                console.log(`Applying offset: X+${offsetX}, Y+${offsetY}, Z+${offsetZ}`);
            }
            

            // Clear current voxels before importing
            clearAllInternal(true);
            console.log("Cleared current scene for VOX import.");


            const oldState = [...voxels.entries()].map(([id, data]) => {
                const parts = parseKey(id);
                return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
            });

            // Update GRID size based on imported model, considering the new max dimensions after offset
            const newMaxX = (voxModel.sizeX || 0) + offsetX;
            const newMaxY = (voxModel.sizeY || 0) + offsetY;
            const newMaxZ = (voxModel.sizeZ || 0) + offsetZ;
            GRID = Math.max(newMaxX, newMaxY, newMaxZ, 10); // Ensure minimum GRID size
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);
            console.log("Updated GRID size to:", GRID);


            // Dispose old InstancedMesh if it exists and re-initialize
            if (instancedMesh) {
                scene.remove(instancedMesh);
                instancedMesh.geometry.dispose();
                instancedMesh.material.dispose();
                instancedMesh = null; // Ensure reference is cleared
            }

            // Re-initialize InstancedMesh with potentially new GRID size
            const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
            let meshMaterial = new THREE.MeshLambertMaterial();
            meshMaterial.onBeforeCompile = (shader) => {
                shader.vertexShader = `
                    varying vec3 vInstanceColor;
                    ${shader.vertexShader}
                `.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                );
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <color_vertex>',
                    `
                    #include <color_vertex>
                    #ifdef USE_INSTANCING_COLOR
                        vInstanceColor = instanceColor;
                    #else
                        vInstanceColor = vec3(1.0);
                    #endif
                    `
                );
                shader.fragmentShader = `
                    varying vec3 vInstanceColor;
                    ${shader.fragmentShader}
                `.replace(
                    'vec4 diffuseColor = vec4( diffuse, opacity );',
                    'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
                );
            };

            const maxVoxelsForLoadedGrid = GRID * GRID * GRID;
            instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, maxVoxelsForLoadedGrid);
            const colBufLoaded = new Uint8Array(maxVoxelsForLoadedGrid * 3);
            instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colBufLoaded, 3, true);

            if (!instancedMesh.instanceMatrix) {
                instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(maxVoxelsForLoadedGrid * 16), 16);
                instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix);
            }
            instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor);


            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            scene.add(instancedMesh);
            instancedMesh.count = 0; // Reset instance count


            const newVoxels = [];
            let addedVoxelCount = 0;
            voxModel.voxels.forEach(v => {
                let colorHex = '#ffffff'; // Default fallback color
                if (v.c > 0 && v.c <= 256 && voxModel.palette) {
                    const rgba = voxModel.palette[v.c];
                    const r = (rgba >> 24) & 0xFF;
                    const g = (rgba >> 16) & 0xFF;
                    const b = (rgba >> 8) & 0xFF;
                    colorHex = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
                    console.log(`Voxel (${v.x},${v.y},${v.z}) palette index ${v.c}, RGBA: ${rgba.toString(16)}, Hex: ${colorHex}`);
                } else {
                    console.warn(`Voxel at (${v.x},${v.y},${v.z}) has invalid palette index ${v.c} or missing palette. Using default color.`);
                }

                // Apply offset
                const gx = v.x + offsetX;
                const gy = v.y + offsetY;
                const gz = v.z + offsetZ;

                // Ensure imported voxels are within new GRID bounds
                if (gx >= 0 && gx < GRID && gy >= 0 && gy < GRID && gz >= 0 && gz < GRID) {
                    addVoxel(gx, gy, gz, colorHex, true);
                    newVoxels.push({ gx, gy, gz, color: colorHex });
                    addedVoxelCount++;
                } else {
                    console.warn(`Voxel at (${v.x}, ${v.y}, ${v.z}) (offsetted to ${gx},${gy},${gz}) is out of new grid bounds [0, ${GRID-1}]. Skipping.`);
                }
            });
            console.log("Total voxels added to scene from VOX:", addedVoxelCount);

            // updateVoxelGeometry(); // No longer needed for frustum culling
            rebuildHelpers();
            resetCameraPosition();

            addCommand('importVOX', null, null, null, null, null, oldState, newVoxels);
            showMessageModal('Import erfolgreich', `VOX-Modell erfolgreich importiert und ${addedVoxelCount} Voxel hinzugef√ºgt!`);

        } catch (error) {
            console.error('Error loading VOX file:', error);
            showMessageModal('Fehler', 'Fehler beim Laden der VOX-Datei. Stellen Sie sicher, dass es sich um eine g√ºltige MagicaVoxel (.vox) Datei handelt. Fehler: ' + error.message);
            resetToDefaultProject(); // Reset to safe state on error
        }
    };
    reader.readAsArrayBuffer(file);
}

// NEW: Generic message modal
function showMessageModal(title, message) {
    const modal = document.getElementById('messageModal');
    document.getElementById('messageModalTitle').textContent = title;
    document.getElementById('messageModalText').textContent = message;
    modal.style.display = 'flex';
}


function generateTerrain() {
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    clearAllInternal(true); // Clear existing voxels without history

    // Re-initialize noise generator with current seed
    noise2D = new ValueNoise2D(terrainSeed);

    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            const noiseVal = (noise2D.fbm(x, z, terrainOctaves, terrainLacunarity, terrainGain) + 1) * 0.5;
            let terrainHeight = Math.floor(noiseVal * terrainHeightScale);

            terrainHeight = Math.max(1, Math.min(GRID, terrainHeight));

            for (let y = 0; y < terrainHeight; y++) {
                let voxelColor;
                if (y < terrainHeightScale * 0.2) {
                    voxelColor = '#6495ED';
                } else if (y < terrainHeightScale * 0.6) {
                    voxelColor = '#8B4513';
                } else {
                    voxelColor = '#708237';
                }
                addVoxel(x, y, z, voxelColor, true);
            }
        }
    }
    // updateVoxelGeometry(); // No longer needed for frustum culling
    rebuildHelpers();
    resetCameraPosition();

    const newState = [...voxels.entries()].map(([id, data]) => {
        const parts = parseKey(id);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });
    addCommand('terrainGenerate', null, null, null, null, null, oldState, newState);

    localStorage.setItem('voxelEditorTerrainHeightScale', terrainHeightScale);
    localStorage.setItem('voxelEditorTerrainFrequency', terrainFrequency);
    localStorage.setItem('voxelEditorTerrainOctaves', terrainOctaves);
    localStorage.setItem('voxelEditorTerrainLacunarity', terrainLacunarity);
    localStorage.setItem('voxelEditorTerrainGain', terrainGain);
    localStorage.setItem('voxelEditorTerrainSeed', terrainSeed);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    if (euler) {
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
    }
}

// NEW: Function to load image as template
function loadImageTemplate() {
    document.getElementById('imageFileInput').click();
}

// NEW: Handle image file selection
function handleImageFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const base64Image = e.target.result;

        const img = new Image();
        img.onload = () => {
            const aspectRatio = img.width / img.height;
            const planeWidth = GRID * VS;
            const planeHeight = planeWidth / aspectRatio;

            if (templateImageMesh) {
                scene.remove(templateImageMesh);
                templateImageMesh.geometry.dispose();
                templateImageMesh.material.dispose();
            }

            const texture = new THREE.TextureLoader().load(base64Image);
            const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, depthWrite: false });
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            templateImageMesh = new THREE.Mesh(geometry, material);

            templateImageMesh.position.set(
                (GRID * VS) / 2,
                (GRID * VS) / 2,
                -0.5 * VS
            );
            templateImageMesh.rotation.y = Math.PI;

            templateImageMesh.renderOrder = -1;
            scene.add(templateImageMesh);

            templateImageData = {
                src: base64Image,
                position: templateImageMesh.position.toArray(),
                rotation: templateImageMesh.rotation.toArray(),
                scale: [1, 1, 1], 
                locked: false,
                scaledWidth: planeWidth,
                scaledHeight: planeHeight
            };
            console.log("Saving template image data:", templateImageData);

            document.getElementById('removeImageTemplateBtn').style.display = 'inline-block';
            document.getElementById('lockImageTemplateCheckbox').checked = false;
            toggleLockImageTemplate(false);
        };
        img.src = base64Image;
    };
    reader.readAsDataURL(file);
}

// NEW: Function to remove the image template
function removeImageTemplate(fromLoad = false) {
    if (templateImageMesh) {
        scene.remove(templateImageMesh);
        templateImageMesh.geometry.dispose();
        templateImageMesh.material.dispose();
        templateImageMesh = null;
        templateImageData = null;
        document.getElementById('removeImageTemplateBtn').style.display = 'none';
        document.getElementById('lockImageTemplateCheckbox').checked = false;
        if (!fromLoad) {
            // No history command needed for removal, as it's part of the project state
            // and handled by save/load.
        }
    }
}

// NEW: Function to toggle image template lock
function toggleLockImageTemplate(initialLoad = false) {
    const isLocked = document.getElementById('lockImageTemplateCheckbox').checked;
    if (templateImageData) {
        templateImageData.locked = isLocked;
    }

    if (templateImageMesh) {
        if (isLocked) {
            templateImageMesh.raycast = function() {};
        } else {
            delete templateImageMesh.raycast;
        }
    }
    if (!initialLoad) {
        // No history command needed for lock state, as it's part of the project state
        // and handled by save/load.
    }
}

// NEW: Function to update the ground plane size based on current GRID
function updateGroundPlaneSize() {
    // Remove the ground plane if it exists
    if (groundPlane) {
        scene.remove(groundPlane);
        groundPlane.geometry.dispose();
        groundPlane.material.dispose();
        groundPlane = null;
    }
}


/* ---------- Initialisierung bei Fensterladung ---------- */
window.onload = function() {
    cvs = document.getElementById('voxelCanvas');
    containerDiv = document.getElementById('container');

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);

    // Camera
    const aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    resetCameraPosition();
    euler = new THREE.Euler(0, 0, 0, 'YXZ');

    // Renderer
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    // NEW: Set pixel ratio based on device and mobile flag
    isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (isMobile) {
        ren.setPixelRatio(Math.min(1.5, window.devicePixelRatio)); // Cap pixel ratio for mobile performance
    } else {
        ren.setPixelRatio(window.devicePixelRatio);
    }
    ren.shadowMap.enabled = true;
    ren.shadowMap.type = THREE.PCFSoftShadowMap;
  
    // Lights
    const ambientLight = new THREE.AmbientLight(0x202020);
    scene.add(ambientLight);

    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    mainDirectionalLight.position.set(10, 20, 15);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 2048;
    mainDirectionalLight.shadow.mapSize.height = 2048;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    mainDirectionalLight.shadow.camera.left = -30;
    mainDirectionalLight.shadow.camera.right = 30;
    mainDirectionalLight.shadow.camera.top = 30;
    mainDirectionalLight.shadow.camera.bottom = -30;
    mainDirectionalLight.shadow.bias = -0.0005;
    mainDirectionalLight.shadow.normalBias = 0.02;
    scene.add(mainDirectionalLight);

    fillDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
    fillDirectionalLight.position.set(-10, 10, -15);
    scene.add(fillDirectionalLight);

    hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemisphereLight);

    updateGroundPlaneSize();

    // Initialize InstancedMesh
    const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS);
    let meshMaterial = new THREE.MeshLambertMaterial();
    
    meshMaterial.onBeforeCompile = (shader) => {
        shader.vertexShader = `
            varying vec3 vInstanceColor;
            ${shader.vertexShader}
        `.replace(
            'void main() {',
            `
            void main() {
            `
        );
        shader.vertexShader = shader.vertexShader.replace(
            '#include <color_vertex>',
            `
            #include <color_vertex>
            #ifdef USE_INSTANCING_COLOR
                vInstanceColor = instanceColor;
            #else
                vInstanceColor = vec3(1.0);
            #endif
            `
        );
        shader.fragmentShader = `
            varying vec3 vInstanceColor;
            ${shader.fragmentShader}
        `.replace(
            'vec4 diffuseColor = vec4( diffuse, opacity );',
            'vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );'
        );
    };

    const initialMaxVoxels = 90 * 90 * 90; 
    instancedMesh = new THREE.InstancedMesh(voxelBaseGeometry, meshMaterial, initialMaxVoxels);
    
    if (!instancedMesh.instanceMatrix) {
        instancedMesh.instanceMatrix = new THREE.InstancedBufferAttribute(new Float32Array(initialMaxVoxels * 16), 16);
        instancedMesh.geometry.setAttribute('instanceMatrix', instancedMesh.instanceMatrix);
    }
    const colBuf = new Uint8Array(initialMaxVoxels * 3);
    instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(colBuf, 3, true);
    instancedMesh.geometry.setAttribute('instanceColor', instancedMesh.instanceColor);


    instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    instancedMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
    instancedMesh.castShadow = true;
    instancedMesh.receiveShadow = true;
    scene.add(instancedMesh);
    instancedMesh.count = 0;

    scene.add(previewVoxelMesh);
    updatePreviewVoxel(0,0,0,false);

    // Helpers
    rebuildHelpers();

    // Event Listeners
    window.addEventListener('resize', onResize);
    containerDiv.addEventListener('pointerdown', onPointerDown);
    containerDiv.addEventListener('pointermove', onPointerMove);
    containerDiv.addEventListener('pointerup', onPointerUp);
    containerDiv.addEventListener('pointercancel', onPointerUp);
    containerDiv.addEventListener('pointerleave', onPointerLeave);
    containerDiv.addEventListener('wheel', onMouseWheel, { passive: false });
    // NEW: Prevent mobile scrolling on touchmove if pointers are active
    containerDiv.addEventListener('touchmove', (e) => {
        if (activePointers.size > 0) e.preventDefault();
    }, { passive: false });


    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    document.addEventListener('pointerlockchange', onPointerLockChange, false);


    // Prevent context menu on right click
    containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

    // UI event listeners
    document.getElementById('grid-size-slider').addEventListener('input', (e) => {
        const oldGrid = GRID;
        GRID = parseInt(e.target.value);
        document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
        localStorage.setItem('voxelEditorGridSize', GRID);
        console.log("Grid size changed to:", GRID);
        console.log("Saving 'voxelEditorGridSize' to localStorage:", localStorage.getItem('voxelEditorGridSize'));

        const oldVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        // Clear voxels outside new bounds and update InstancedMesh
        const voxelsToKeep = new Map();
        voxels.forEach((data, k) => {
            const [gx, gy, gz] = parseKey(k);
            if (gx < GRID && gy < GRID && gz < GRID) {
                voxelsToKeep.set(k, data);
            }
        });

        // Rebuild voxels map with only kept voxels
        voxels.clear();
        voxelsToKeep.forEach((data, k) => {
            voxels.set(k, data);
        });
        
        // The instancedMesh.count will be set in the animate loop due to frustum culling.
        // No need to set it here.

        const newVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = parseKey(id);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        addCommand('resizeGrid', null, null, null, null, null, oldVoxelState, newVoxelState, { oldGrid: oldGrid, newGrid: GRID });

        rebuildHelpers();
        resetCameraPosition();
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    });

    presetBoxes = [
        document.getElementById('color-preset-1'),
        document.getElementById('color-preset-2'),
        document.getElementById('color-preset-3')
    ];
    presetColors.forEach((color, index) => {
            const box = presetBoxes[index];
            box.style.backgroundColor = color;
            box.addEventListener('click', (e) => {
                if (e.shiftKey || e.ctrlKey || e.metaKey) {
                    saveCurrentColorToPreset(index);
                } else {
                    setActivePreset(index);
                }
            });
        });
    if (activePresetIndex !== -1) {
        setActivePreset(activePresetIndex);
    } else {
        document.getElementById('color-picker').value = currentColor;
    }


    document.getElementById('modeToggle').addEventListener('click', cycleMode);
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;

    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'flex';
    });
    document.getElementById('saveAndClearBtn').addEventListener('click', () => {
        saveJSON();
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => {
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('cancelClearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'none';
    });

    document.getElementById('messageModalCloseBtn').addEventListener('click', () => {
        document.getElementById('messageModal').style.display = 'none';
    });


    document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
    document.getElementById('saveBtn').addEventListener('click', saveJSON);
    document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', loadJSON);
    document.getElementById('exportStlBtn').addEventListener('click', exportSTL);
    document.getElementById('importStlBtn').addEventListener('click', () => {
        document.getElementById('stlFileInput').click();
    });
    document.getElementById('stlFileInput').addEventListener('change', importSTL);

    document.getElementById('exportObjBtn').addEventListener('click', exportOBJ);
    document.getElementById('importObjBtn').addEventListener('click', () => {
        document.getElementById('objFileInput').click();
    });
    document.getElementById('objFileInput').addEventListener('change', importOBJ);

    document.getElementById('exportVoxBtn').addEventListener('click', exportVOX);
    document.getElementById('importVoxBtn').addEventListener('click', () => {
        document.getElementById('voxFileInput').click();
    });
    document.getElementById('voxFileInput').addEventListener('change', importVOX);


    document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
        moveSpeed = parseFloat(e.target.value);
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    });

    // Block Size buttons
    document.getElementById('block-size-1x1').addEventListener('click', () => setBlockSize(1));
    document.getElementById('block-size-4x4').addEventListener('click', () => setBlockSize(4));
    document.getElementById('block-size-8x8').addEventListener('click', () => setBlockSize(8));
    document.getElementById('block-size-10x10').addEventListener('click', () => setBlockSize(10));

    // Info Box (Help) Toggle Logic
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');
    let showInfoBox = localStorage.getItem('showInfoBox') === 'true';

    function updateInfoBoxVisibility() {
        infoBox.style.display = showInfoBox ? 'block' : 'none';
        helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
        localStorage.setItem('showInfoBox', showInfoBox);
    }
    helpToggleBtn.addEventListener('click', () => {
        showInfoBox = !showInfoBox;
        updateInfoBoxVisibility();
    });
    updateInfoBoxVisibility();

    // Terrain Controls Toggle Logic
    const terrainControlsPanel = document.getElementById('terrainControlsPanel');
    const toggleTerrainControlsBtn = document.getElementById('toggleTerrainControlsBtn');
    let showTerrainControls = localStorage.getItem('showTerrainControls') === 'true';

    function updateTerrainControlsVisibility() {
        terrainControlsPanel.style.display = showTerrainControls ? 'flex' : 'none';
        toggleTerrainControlsBtn.textContent = showTerrainControls ? 'Gel√§nde-Optionen ausblenden' : 'Gel√§nde-Optionen anzeigen';
        localStorage.setItem('showTerrainControls', showTerrainControls);
    }
    toggleTerrainControlsBtn.addEventListener('click', () => {
        showTerrainControls = !showTerrainControls;
        updateTerrainControlsVisibility();
    });
    updateTerrainControlsVisibility();

    // Terrain parameter input event listeners
    document.getElementById('terrain-height-scale').addEventListener('input', (e) => {
        terrainHeightScale = parseInt(e.target.value);
        localStorage.setItem('voxelEditorTerrainHeightScale', terrainHeightScale);
    });
    document.getElementById('terrain-frequency').addEventListener('input', (e) => {
        terrainFrequency = parseFloat(e.target.value);
        localStorage.setItem('voxelEditorTerrainFrequency', terrainFrequency);
    });
    document.getElementById('terrain-octaves').addEventListener('input', (e) => {
        terrainOctaves = parseInt(e.target.value);
        localStorage.setItem('voxelEditorTerrainOctaves', terrainOctaves);
    });
    document.getElementById('terrain-lacunarity').addEventListener('input', (e) => {
        terrainLacunarity = parseFloat(e.target.value);
        localStorage.setItem('voxelEditorTerrainLacunarity', terrainLacunarity);
    });
    document.getElementById('terrain-gain').addEventListener('input', (e) => {
        terrainGain = parseFloat(e.target.value);
        localStorage.setItem('voxelEditorTerrainGain', terrainGain);
    });
    document.getElementById('terrain-seed').addEventListener('input', (e) => {
        terrainSeed = e.target.value;
        hasUserTypedSeed = (terrainSeed !== '');
        localStorage.setItem('voxelEditorTerrainSeed', terrainSeed);
    });

    document.getElementById('generateTerrainBtn').addEventListener('click', generateTerrain);

    document.getElementById('resetCameraBtn').addEventListener('click', resetCameraPosition);

    document.getElementById('loadImageTemplateBtn').addEventListener('click', loadImageTemplate);
    document.getElementById('imageFileInput').addEventListener('change', handleImageFileSelect);
    document.getElementById('removeImageTemplateBtn').addEventListener('click', removeImageTemplate);
    document.getElementById('lockImageTemplateCheckbox').addEventListener('click', toggleLockImageTemplate);


    // Hamburger menu toggle for mobile
    const menuToggle = document.getElementById('menuToggle');
    menuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        if (controlsPanel.style.display === 'none' || controlsPanel.style.display === '') {
            controlsPanel.style.display = 'flex';
        } else {
            controlsPanel.style.display = 'none';
        }
    });

    // Check media query on load and resize
    const mediaQuery = window.matchMedia('(max-width: 768px)');
    function handleMediaQueryChange(e) {
        isMobile = e.matches; // Update isMobile flag
        const controlsPanel = document.getElementById('controls');
        if (e.matches) {
            controlsPanel.style.display = 'none';
            menuToggle.style.display = 'block';
        } else {
            controlsPanel.style.display = 'flex';
            menuToggle.style.display = 'none';
        }
        onResize(); // Also call onResize to adjust pixel ratio
    }
    mediaQuery.addListener(handleMediaQueryChange);
    handleMediaQueryChange(mediaQuery);

    // NEW: Mobile controls event listeners
    document.getElementById('mobile-undo').addEventListener('click', undo);
    document.getElementById('mobile-redo').addEventListener('click', redo);
    document.getElementById('mobile-save').addEventListener('click', saveJSON);
    document.getElementById('mobile-camera').addEventListener('click', () => {
        // Toggle between camera modes or reset camera view
        resetCameraPosition(); // Simple reset for now
    });
    document.getElementById('mobile-assist').addEventListener('click', () => {
        touchAssistEnabled = !touchAssistEnabled;
        showMessageModal('Touch Assist', `Touch Assist ist jetzt ${touchAssistEnabled ? 'aktiviert' : 'deaktiviert'}.`);
    });


    noise2D = new ValueNoise2D(terrainSeed);

    document.getElementById('grid-size-slider').value = GRID;
    document.getElementById('grid-size-display').textContent = `${GRID}√ó${GRID}√ó${GRID}`;
    document.getElementById('color-picker').value = currentColor;
    document.getElementById('fly-speed-slider').value = moveSpeed;
    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
    setBlockSize(currentBlockSize);
    document.getElementById('terrain-height-scale').value = terrainHeightScale;
    document.getElementById('terrain-frequency').value = terrainFrequency;
    document.getElementById('terrain-octaves').value = terrainOctaves;
    document.getElementById('terrain-lacunarity').value = terrainLacunarity;
    document.getElementById('terrain-gain').value = terrainGain;
    document.getElementById('terrain-seed').value = terrainSeed;


    animate();
}; // END window.onload

/* ---------- Animations-Loop ---------- */
const frustum = new THREE.Frustum();
const tempCameraMatrix = new THREE.Matrix4();
const tempVoxelPosition = new THREE.Vector3(); // Re-use for performance

function animate() {
    requestAnimationFrame(animate);

    // Frustum Culling: Rebuild InstancedMesh buffers every frame with visible voxels
    tempCameraMatrix.multiplyMatrices(cam.projectionMatrix, cam.matrixWorldInverse);
    frustum.setFromProjectionMatrix(tempCameraMatrix);

    let currentInstanceIndex = 0;
    const voxelBaseGeometry = new THREE.BoxGeometry(VS, VS, VS); // Re-use this

    voxels.forEach((data, k) => {
        const [x, y, z] = parseKey(k);
        tempVoxelPosition.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);

        if (frustum.containsPoint(tempVoxelPosition)) {
            // Set matrix for the visible instance
            dummy.position.copy(tempVoxelPosition);
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(currentInstanceIndex, dummy.matrix);

            // Set color for the visible instance
            setInstanceColor(currentInstanceIndex, data.color);

            currentInstanceIndex++;
        }
    });

    instancedMesh.count = currentInstanceIndex; // Update total visible instances
    instancedMesh.instanceMatrix.needsUpdate = true; // Mark buffers for update
    instancedMesh.instanceColor.needsUpdate = true; // Mark buffers for update

    // Continuous keyboard movement when pointer is locked (fly mode)
    if (isPointerLocked) {
        const forward = cam.getWorldDirection(new THREE.Vector3());
        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();
        const up = new THREE.Vector3(0, 1, 0); // World up direction

        const currentMoveSpeed = moveSpeed * 5;

        if (keyboard['w']) cam.position.addScaledVector(forward, currentMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(forward, -currentMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(right, -currentMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(right, currentMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(up, -currentMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(up, currentMoveSpeed);
    }

    ren.render(scene, cam);
}

/* ---------- Mouse / Pointer Input ---------- */
let pointerIsDown = false;
let lastX, lastY;
let currentHoveredVoxel = null; // Store {x, y, z} of the voxel currently hovered by the mouse


function onPointerDown(e) {
    // Prevent context menu for all right-clicks
    if (e.button === 2) {
        e.preventDefault();
    }

    // Handle Right-click (Mouse only) for camera control (Pointer Lock)
    if (e.pointerType === 'mouse' && e.button === 2) {
        if (document.pointerLockElement !== cvs) {
            cvs.requestPointerLock();
            cvs.focus();
        }
        return;
    }

    // If we reach here, it's a Left-click (Mouse) or any Touch event.
    if (isPointerLocked) {
        return;
    }

    // Quick-Fix: Suppress tap immediately after a pinch gesture (only for touch)
    if (suppressNextTap && e.pointerType === 'touch') {
        suppressNextTap = false;
    }

    // General setup for drawing/interaction (Left-click or Touch, when not in fly mode)
    pointerIsDown = true;
    lastX = e.clientX;
    lastY = e.clientY;
    lastActionVoxelCoords = null;
    initialClickPos = { x: e.clientX, y: e.clientY };

    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
    isHoldDrawingActive = false;

    // NEW: Long press for precision mode (for touch)
    if (e.pointerType === 'touch') {
        longPressTimer = setTimeout(() => {
            isHoldDrawingActive = true; // This can also trigger precision mode if desired
            // showMessageModal('Precision Mode', 'Long press detected! Precision mode is active.');
        }, LONG_PRESS_DELAY_MS);

        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType }); // Store pointerType
        
        if (activePointers.size === 1) {
            prevTouch = { x: e.clientX, y: e.clientY };
            const now = performance.now();
            if (tapCandidate && (now - tapCandidate.time < DT_MS) && (Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH)) {
                touchState = TouchState.TAP2_WAITMOVE;
                isShiftDragging = true;
            } else {
                touchState = TouchState.SINGLE_TOUCH_CAMERA;
                tapCandidate = { x: e.clientX, y: e.clientY, time: now };
            }
        } else if (activePointers.size === 2) { // NEW: Two-finger tap for context menu (simple example)
            // showMobileContextMenu(e.clientX, e.clientY); // Placeholder for context menu
            touchState = TouchState.MULTI_TOUCH_CAMERA; // Assume multi-touch camera for 2+ fingers
            tapCandidate = null;
            isShiftDragging = false;
        } else if (activePointers.size >= 3) { // NEW: Three-finger swipe setup
            // This is just to prevent other actions, actual swipe detection is onPointerUp
            touchState = TouchState.MULTI_TOUCH_CAMERA; // Assume camera control
            tapCandidate = null;
            isShiftDragging = false;
        }
    } else { // Mouse Left-click
        const isShiftOrNormalDrag = (shiftActive() || (e.buttons === 1 && !e.ctrlKey));
        if (isShiftOrNormalDrag) {
            setFixedDragPlane(e.clientX, e.clientY, currentMode);
        }
    }
}

function onPointerMove(e) {
    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, pointerType: e.pointerType }); // Store pointerType
        handleGesture();

        if (touchState === TouchState.SINGLE_TOUCH_CAMERA || touchState === TouchState.MULTI_TOUCH_CAMERA) {
            updatePreviewVoxel(0, 0, 0, false);
            return;
        }

        if (touchState === TouchState.TAP2_WAITMOVE) {
            const p = activePointers.get(e.pointerId);
            const moved = initialClickPos ? Math.hypot(p.x - initialClickPos.x, p.y - initialClickPos.y) : 0;
            if (moved > MOVE_PX) {
                touchState = TouchState.DRAW;
                setFixedDragPlane(initialClickPos.x, initialClickPos.y, currentMode);
            } else {
                updatePreviewVoxel(0, 0, 0, false);
                return;
            }
        }
    } else if (isPointerLocked) {
        if (firstMoveAfterLock) {
            firstMoveAfterLock = false;
            return;
        }

        const dx = e.movementX || 0;
        const dy = e.movementY || 0;

        euler.y -= dx * rotSpeed;
        euler.x -= dy * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
        cam.quaternion.setFromEuler(euler);
        return;
    }

    const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, pointerIsDown, isControlDragging, e.pointerType); // Pass e.pointerType

    // Update preview voxel
    if (currentTargetVoxel && !isPointerLocked && (e.pointerType === 'mouse' || touchState === TouchState.DRAW)) {
        // NEW: Apply magnetic targeting for preview voxel if touchAssistEnabled
        if (e.pointerType === 'touch' && touchAssistEnabled) {
            const snappedPos = getNearestVoxelCenter(new THREE.Vector3(
                currentTargetVoxel.gx * VS + HALF,
                currentTargetVoxel.gy * VS + HALF,
                currentTargetVoxel.gz * VS + HALF
            ));
            updatePreviewVoxel(
                Math.round(snappedPos.x / VS - HALF),
                Math.round(snappedPos.y / VS - HALF),
                Math.round(snappedPos.z / VS - HALF),
                true
            );
        } else {
            updatePreviewVoxel(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, true);
        }
    } else {
        updatePreviewVoxel(0, 0, 0, false);
    }

    if (pointerIsDown || touchState === TouchState.DRAW) {
        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const isActualDrag = movedDistance > MOVE_PX;

        if (isActualDrag || isHoldDrawingActive || touchState === TouchState.DRAW) {
            if (currentTargetVoxel) {
                if (isShiftDragging || isControlDragging || touchState === TouchState.DRAW || (fixedDragPlaneParams.level !== null && fixedDragPlaneParams.axis !== null)) {
                    if (!lastActionVoxelCoords ||
                        lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                        lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                        lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                        if (lastActionVoxelCoords) {
                            drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor, currentBlockSize);
                        } else {
                            performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
                        }
                        lastActionVoxelCoords = { ...currentTargetVoxel };
                    }
                } else {
                    if (!lastActionVoxelCoords ||
                        lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                        lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                        lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                        if (lastActionVoxelCoords) {
                            drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor, currentBlockSize);
                        } else {
                            performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor, currentBlockSize);
                        }
                        lastActionVoxelCoords = { ...currentTargetVoxel };
                    }
                }
            }
        }
    }
}

function onPointerUp(e) {
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
    isHoldDrawingActive = false;

    if (suppressNextTap && e.pointerType === 'touch') {
        suppressNextTap = false;
        releasePointer(e.pointerId, e); // Pass the event object for swipe detection
        return;
    }

    if (e.pointerType === 'mouse') {
        if (e.button === 2) {
            document.exitPointerLock();
            return;
        }

        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleClick = movedDistance <= MOVE_PX;

        if (pointerIsDown && !isPointerLocked) {
            if (wasSingleClick) {
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false, e.pointerType); // Pass e.pointerType
                if (clickedVoxel) {
                    performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, currentMode, currentColor, currentBlockSize);
                }
            }
        }
        pointerIsDown = false;
    } else if (e.pointerType === 'touch') {
        releasePointer(e.pointerId, e); // Pass the event object for swipe detection

        if (activePointers.size === 0) {
            const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
            const wasSingleTap = movedDistance <= TAP_DIST_TH;

            if (wasSingleTap && (touchState === TouchState.SINGLE_TOUCH_CAMERA || touchState === TouchState.TAP2_WAITMOVE)) {
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false, e.pointerType); // Pass e.pointerType
                if (clickedVoxel) {
                    performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, currentMode, currentColor, currentBlockSize);
                }
            }
            touchState = TouchState.NONE;
            tapCandidate = null;
            prevTouch = null;
        }
    }

    updatePreviewVoxel(0, 0, 0, false);
    isControlDragging = false;
    isShiftDragging = false;
    lastActionVoxelCoords = null;
    initialClickPos = null;

    fixedDragPlaneParams.level = null;
    fixedDragPlaneParams.axis = null;
}

function onPointerLeave(e) {
    if (e.pointerType === 'mouse') {
        pointerIsDown = false;
        lastActionVoxelCoords = null;
        updatePreviewVoxel(0, 0, 0, false);
    }
}

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        firstMoveAfterLock = true;
        updatePreviewVoxel(0,0,0,false);
        euler.setFromQuaternion(cam.quaternion, 'YXZ');

    } else {
        isPointerLocked = false;
    }
}

function onMouseWheel(e) {
    e.preventDefault();

    const sensitivity = 0.005;
    let zoomAmount = e.deltaY * sensitivity;

    if (e.altKey) {
        if (e.shiftKey) {
            activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
            currentDrawingAxis = 'z';
        } else if (e.ctrlKey) {
            activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
            currentDrawingAxis = 'x';
        } else {
            activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
            currentDrawingAxis = 'y';
        }
        updateGridHelperPosition();
    } else {
        const speedChange = -Math.sign(e.deltaY) * 0.01;
        moveSpeed = Math.max(0.01, Math.min(1.0, moveSpeed + speedChange));
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

        cam.position.addScaledVector(
            cam.getWorldDirection(new THREE.Vector3()),
            zoomAmount * moveSpeed * 5
        );
    }
}

// Helper to get a point on a specific fixed plane
function getPointOnFixedPlane(clientX, clientY, axis, level) {
    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
                                    -((clientY - rect.top) / rect.height) * 2 + 1);
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    let planeNormal = new THREE.Vector3();
    if (axis === 'y') planeNormal.set(0, 1, 0);
    else if (axis === 'x') planeNormal.set(1, 0, 0);
    else if (axis === 'z') planeNormal.set(0, 0, 1);
    const drawingPlane = new THREE.Plane(planeNormal, -(level * VS));

    const intersectionPoint = new THREE.Vector3();
    const intersectResult = raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

    if (intersectResult) { // Check if intersection occurred
        let gx = Math.floor(intersectionPoint.x / VS);
        let gy = Math.floor(intersectionPoint.y / VS);
        let gz = Math.floor(intersectionPoint.z / VS);

        if (axis === 'y') gy = level;
        else if (axis === 'x') gx = level;
        else if (axis === 'z') gz = level;

        gx = Math.max(0, Math.min(GRID - 1, gx));
        gy = Math.max(0, Math.min(GRID - 1, gy));
        gz = Math.max(0, Math.min(GRID - 1, gz));

        return { gx, gy, gz };
    }
    return null;
}

// Function to set the current block size
function setBlockSize(size) {
    currentBlockSize = size;
    localStorage.setItem('voxelEditorCurrentBlockSize', currentBlockSize);
    document.querySelectorAll('.block-size-btn').forEach(btn => btn.classList.remove('active'));
    document.getElementById(`block-size-${size}x${size}`).classList.add('active');
    const rect = cvs.getBoundingClientRect();
    const mouseX = lastX - rect.left;
    const mouseY = lastY - rect.top;
    if (mouseX >= 0 && mouseX <= rect.width && mouseY >= 0 && mouseY <= rect.height) {
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: lastX,
            clientY: lastY,
            buttons: pointerIsDown ? 1 : 0
        });
        onPointerMove(mouseEvent);
    } else {
        updatePreviewVoxel(0,0,0,false);
    }
}


/* ---------- Keyboard Input ---------- */
const keyboard = {};
function onKeyDown(e) {
    keyboard[e.key] = true;

    if (e.key === 'Shift') {
        isShiftDragging = true;
    }
    if (e.key === 'Control' || e.key === 'Meta') {
        isControlDragging = true;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
    }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) {
        e.preventDefault();
        redo();
    }
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        e.preventDefault();
    }

    switch (e.key) {
        case 'Tab':
            e.preventDefault();
            cycleMode();
            break;
        case '1': setActivePreset(0); break;
        case '2': setActivePreset(1); break;
        case '3': setActivePreset(2); break;
    }
}

function onKeyUp(e) {
    keyboard[e.key] = false;

    if (e.key === 'Shift') {
        isShiftDragging = false;
    }
    if (e.key === 'Control' || e.key === 'Meta') {
        isControlDragging = false;
    }
}
</script>
</body>
</html>
