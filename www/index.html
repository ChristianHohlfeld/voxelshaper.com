<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta property="og:title" content="VoxelShaper – Create in 3D, Effortlessly" />
<meta property="og:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders." />
<meta property="og:image" content="https://voxelshaper.com/preview.png" />
<meta property="og:url" content="https://voxelshaper.com/" />
<meta property="og:type" content="website" />
<meta name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANl..."/>

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="VoxelShaper – Create in 3D, Effortlessly">
<meta name="twitter:description" content="A powerful, intuitive voxel-based 3D editor – made for makers, artists, and coders.">
<meta name="twitter:image" content="https://voxelshaper.com/preview.png">
<title>VoxelShaper – Voxel Editor & 3D Print Exporter</title>
<style>
/* CSS für den Body mit Safe-Area-Anpassungen */
body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: #282c34;
    color: #e0e0e0;

    /* --- WICHTIG: ANPASSUNGEN FÜR SICHERE BEREICHE --- */
    /* Verschiebt den Inhalt nach unten, um Platz für die Statusleiste/Notch zu schaffen */
    padding-top: env(safe-area-inset-top);
    /* Fügt Polsterung für den unteren Bereich hinzu (z.B. für Home-Indikatoren auf iPhones) */
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
    /* Entscheidend: Stellt sicher, dass das Padding in der 100vh Höhe enthalten ist */
    box-sizing: border-box;
    /* --- ENDE ANPASSUNGEN FÜR SICHERE BEREICHE --- */
}

/* verhindert, dass das OS den Canvas als Text selektiert */
canvas, body, #container{
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;    /* iOS Kontextmenü */
}
#controls{padding:14px;background:#3a3f47;border-bottom:1px solid #4a4f57;display:flex;flex-wrap:wrap;gap:12px;justify-content:center;align-items:center}
#controls button,#controls label{padding:8px 18px;border:none;border-radius:5px;font-size:1em;background:#555c66;color:#e0e0e0;cursor:pointer}
#controls button:hover{background:#6a727f}
#grid-size-display{font-weight:700;color:#90caf9}
#current-mode{
    font-weight:700;
    color:#81c784;
    min-width: 160px; /* Fixed width */
    max-width: 160px; /* Fixed width */
    text-align: center; /* Center the text */
}
#container{
    flex:1;
    position:relative;
    border: 2px solid transparent; /* Default border for the container */
    box-sizing: border-box; /* Ensure border doesn't push content out */
    overflow: hidden; /* Prevent canvas border from overflowing if issues persist */
}
canvas{
    width:100%;
    height:100%;
    display: block; /* Ensure canvas behaves as a block element */
    box-sizing: border-box; /* Ensure border (if added back) doesn't push content out */
}
.info-box{
    position:absolute;
    bottom:18px;
    left:18px;
    padding:12px;
    border-radius:8px;
    font-size:.85em;
    background:rgba(0,0,0,.6);
    pointer-events:none;
    /* Default to hidden, will be controlled by JS based on local storage */
    display: none;
}
.info-box strong{color:#90caf9}
#fileInput{display:none}

/* Slider-Stil */
input[type="range"] {
    -webkit-appearance: none;
    width: 150px;
    height: 8px;
    background: #4a4f57;
    border-radius: 5px;
    outline: none;
    opacity: 0.8;
    transition: opacity .2s;
    margin-left: 10px;
    margin-right: 10px;
}
input[type="range"]:hover {
    opacity: 1;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #90caf9;
    cursor: pointer;
}
/* Color Picker Styling - MADE ROUND */
input[type="color"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 38px;
    height: 38px;
    border: none;
    border-radius: 50%; /* Made round */
    background-color: transparent;
    cursor: pointer;
    padding: 0;
    vertical-align: middle;
}
input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-webkit-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%; /* Made round */
}
input[type="color"]::-moz-color-swatch-wrapper {
    padding: 0;
}
input[type="color"]::-moz-color-swatch {
    border: 1px solid #555c66;
    border-radius: 50%;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #3a3f47;
    margin: auto;
    padding: 30px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    max-width: 400px;
    color: #e0e0e0;
}

.modal-content h3 {
    margin-top: 0;
    color: #90caf9;
}

.modal-buttons {
    margin-top: 25px;
    display: flex;
    justify-content: space-around;
    gap: 10px;
}

.modal-buttons button {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    flex-grow: 1;
}

.modal-buttons button.confirm-save {
    background-color: #4CAF50; /* Green */
    color: white;
}

.modal-buttons button.confirm-no-save {
    background-color: #f44336; /* Red */
    color: white;
}

.modal-buttons button.cancel {
    background-color: #555c66; /* Grey */
    color: #e0e0e0;
}

.modal-buttons button:hover {
    opacity: 0.9;
}

/* Style for the preset color boxes - KEPT RECTANGULAR */
.color-preset-box {
    width: 38px;
    height: 38px;
    border-radius: 5px; /* Kept rectangular */
    border: 2px solid #555c66;
    cursor: pointer;
    display: inline-block;
    vertical-align: middle;
    box-sizing: border-box;
    transition: transform 0.1s ease-in-out, border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.color-preset-box:hover {
    transform: scale(1.1);
}
.color-preset-box.active {
    border-color: #90caf9;
    box-shadow: 0 0 8px rgba(144, 202, 249, 0.7);
}

/* Style for the new terrain controls panel */
#terrainControlsPanel {
    background: #3a3f47;
    padding: 14px;
    margin-top: 10px;
    border-radius: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: center;
    align-items: center;
    border: 1px solid #4a4f57;
    transition: all 0.3s ease-in-out;
}
/* ---------------------------------------------------
    HAMBURGER-BUTTON
    --------------------------------------------------- */
#menuToggle{
    position: fixed;
    /* top: 10px; <-- DIESE ZEILE WIRD GEÄNDERT! */
    top: calc(10px + env(safe-area-inset-top)); /* <-- NEU: Verschiebt es um 10px + Safe-Area nach unten */
    right: 10px;
    z-index: 1500;             /* über allen Panels */
    width: 42px; height: 42px;
    font-size: 1.4em;
    line-height: 42px;
    text-align: center;
    background:#555c66;
    color:#e0e0e0;
    border:none;
    border-radius:8px;
    cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,.4);
}
#menuToggle:hover{background:#6a727f}

/* ---------------------------------------------------
    Responsive-Regel: Auf Viewports ≤ 768 px wird
    das Bedienfeld anfangs versteckt.
    --------------------------------------------------- */
@media (max-width:768px){
    #controls{display:none;}
}
/* ---------------------------------------------------
    Gelände-Button optisch hervorheben
    --------------------------------------------------- */
#generateTerrainBtn{
    padding: 12px 26px;
    font-size: 1.05em;
    font-weight: 600;
    letter-spacing: .3px;

    /* Farben im VoxelShaper-Grün */
    background: linear-gradient(180deg,#66bb6a 0%,#43a047 100%);
    color:#fff;

    border:none;
    border-radius:8px;
    cursor:pointer;

    /* leichter „erhabener“ Effekt */
    box-shadow:0 2px 6px rgba(0,0,0,.4);
    transition: transform .06s ease, box-shadow .06s ease;
}

/* Hover / Focus */
#generateTerrainBtn:hover,
#generateTerrainBtn:focus-visible{
    transform: translateY(-1px);
    box-shadow:0 4px 10px rgba(0,0,0,.45);
}

/* Aktiv (Button gedrückt) */
#generateTerrainBtn:active{
    transform: translateY(0);
    box-shadow:0 2px 4px rgba(0,0,0,.35);
}
/* Canvas & Container: KEINE default-Gesten */
#container,
#voxelCanvas{
    touch-action: none;           /* iOS ≥13.4, Android, Desktop */
    -ms-touch-action: none;       /* altes Edge/IE */

    /* ← neu: sorge dafür, dass die CSS-Border innen sitzt */
           box-sizing: border-box;
}
/* Shift-Lock: aktiv leuchtend */
#shiftLockBtn.active{
    background:#ffa726;    /* Orange – passe gern an */
    color:#fff;
}
canvas, body { -webkit-tap-highlight-color: transparent; }
</style>
</head>
<body>
<button id="menuToggle" aria-label="Menü umschalten">☰</button>

<div id="controls">
    <label for="grid-size-slider">Gittergröße:</label>
    <input type="range" id="grid-size-slider" min="5" max="90" value="10">
    <span id="grid-size-display">10×10×10</span>
    <label for="color-picker">Farbe:</label>
    <input type="color" id="color-picker" value="#ffffff">
    <div id="color-preset-1" class="color-preset-box"></div>
    <div id="color-preset-2" class="color-preset-box"></div>
    <div id="color-preset-3" class="color-preset-box"></div>

    <button id="modeToggle">Modus wechseln</button><span id="current-mode">Modus: Hinzufügen</span>
    <button id="clearBtn">Alles löschen</button>
    <button id="fillLevelBtn">Ebene füllen</button>
    <button id="saveBtn">Projekt speichern</button>
    <button id="loadBtn">Projekt laden</button>
    <button id="exportStlBtn">STL Export</button>

    <label for="fly-speed-slider">Fluggeschwindigkeit:</label>
    <input type="range" id="fly-speed-slider" min="0.01" max="2.0" step="0.01" value="0.1">
    <span id="fly-speed-display">0.10</span>

    <button id="toggleTerrainControlsBtn">Gelände-Optionen</button>
    <button id="helpToggleBtn">Hilfe</button>
    <button id="shiftLockBtn">Shift-Lock ✱ aus</button>
</div>

<div id="terrainControlsPanel" style="display:none;">
    <button id="generateTerrainBtn">Gelände generieren</button>
    <label for="terrain-height-scale">Höhe:</label>
    <input type="number" id="terrain-height-scale" value="10" min="1" step="1">
    <label for="terrain-frequency">Frequenz:</label>
    <input type="number" id="terrain-frequency" value="0.05" min="0.001" max="0.5" step="0.001">
    <label for="terrain-octaves">Oktaven:</label>
    <input type="number" id="terrain-octaves" value="4" min="1" max="10" step="1">
    <label for="terrain-lacunarity">Lacunarity:</label>
    <input type="number" id="terrain-lacunarity" value="2.0" min="1.0" max="4.0" step="0.1">
    <label for="terrain-gain">Gain:</label>
    <input type="number" id="terrain-gain" value="0.5" min="0.1" max="1.0" step="0.01">
    <label for="terrain-seed">Seed:</label>
    <input type="text" id="terrain-seed" placeholder="Zahl oder Text">
</div>

<div id="container">
    <canvas id="voxelCanvas"></canvas>
    <div class="info-box" id="infoBox"> <strong>Steuerung</strong><br>
    Rechte MT gehalten + Maus → Kamera drehen (Fly Mode)<br>
    WASD / E / Q → bewegen<br>
    Linke MT → Voxel hinzuf./löschen/zeichnen<br>
    **Alt + Mausrad → Zeichenebene Y hoch/runter (Gitter folgt)**<br>
    **Alt + Shift + Mausrad → Zeichenebene Z hoch/runter (Gitter folgt)**<br>
    **Alt + Control + Mausrad → Zeichenebene X hoch/runter (Gitter folgt)**<br>
    **Shift + Linke MT gedrückt + Maus ziehen → Voxel Aktion auf aktiver Ebene (Hinzufügen / Löschen / Zeichnen)**<br>
    **Control + Linke MT gedrückt + Maus ziehen → Voxel ziehen zum Hinzufügen (Stapeln, nur im Hinzufügen-Modus)**<br>
    Mausrad → Kamera Geschwindigkeit anpassen<br>
    **Tab → Modus wechseln (Hinzufügen / Löschen / Zeichnen / Rechteck hinzufügen)**<br>
    **1, 2, 3 → Voreingestellte Farbe wählen**<br>
    **Strg + Z → Rückgängig (Undo)**<br>
    **Strg + Y oder Strg + Shift + Z → Wiederholen (Redo)**
    </div>
    <input type="file" id="fileInput" accept=".json">
</div>

<div id="clearConfirmationModal" class="modal">
    <div class="modal-content">
        <h3>Projekt löschen</h3>
        <p>Möchten Sie das aktuelle Projekt speichern, bevor Sie alle Voxel löschen?</p>
        <div class="modal-buttons">
            <button id="saveAndClearBtn" class="confirm-save">Speichern & Löschen</button>
            <button id="clearWithoutSaveBtn" class="confirm-no-save">Ohne Speichern löschen</button>
            <button id="cancelClearBtn" class="cancel">Abbrechen</button>
        </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/noisejs/2.1.0/perlin.js"></script>



<script>
/* ---------- Konstanten ---------- */
const VS = 1, HALF = VS * 0.5;

/* ---------- globale Variablen ---------- */
let dblTapShiftLock = false;
let isDblTapDragActive= false; // Controls if a double-tap-drag should activate drawing
let activeGestureMode = 'none'; // NEU: Verfolgt den aktuell aktiven Gestenmodus
let initialDblTapDragLevelY = null; // Speichert die Y-Ebene für Double-Tap-Drag
let isHoldDrawingActive = false;   // NEU: Verfolgt, ob ein Long-Press-Zeichnen aktiv ist
let initialHoldDrawPos = null;     // NEU: Speichert die Startposition für Long-Press-Bewegungserkennung
const LONG_PRESS_DELAY_MS = 500;   // NEU: Wartezeit (in Millisekunden) für Long-Press-Erkennung

/* ----------------------------------------------
   GLOBAL – neue Hilfs-Variablen
---------------------------------------------- */
let initialTouchDrawingLevelY = null; // Speichert die Y-Ebene für den Beginn eines Touch-Drag-Zeichnens

const PINCH_ZOOM_MULT = 12;     // Zoom-Geschwindigkeit ↑  (vorher 3-5)
/* ---------- Double-Tap-State ---------- */
let tapCandidate   = null;   // {x,y,time}
const TAP_DIST_TH  = 10;     // max. Bewegung (px) für 'Tap'
let gestureMode  = null;   // null | 'pan' | 'pinch'
let gestureMid   = null;   // {x,y}  – letzte Mittel­punkt­position
let gestureDist  = null;   // vorheriger Zwei-Finger-Abstand
let longPressTimer = null; // Initialize longPressTimer to null

/* --- 2-Finger-Drag / Pinch ---------------------------------- */
const DRAG_BASE   = 0.08;   // Grund-faktor (wird mit moveSpeed multipliziert)
const PAN_PIX_TH  = 10;      // ab 4 px Bewegung → Pan
const PINCH_REL_TH = 0.08;  // ≥6 % Distanzänderung → Pinch
let prevTouch = null;
let touchStartPos = null; // merkt Position für Tap-Erkennung
let scene, cam, ren, gridHelper, boxHelper;
let rotSpeed = 0.004;   // Globale Drehgeschwindigkeit    (NEU)
/* --- Double-Tap Gesten ---------------------------------------- */
let lastTap       = 0;        // Zeitstempel des letzten pointerup
let dblTapActive  = false;    // true während des 2. Taps
let dblTapDrag    = false;    // wird true, sobald Finger > MOVE_PX zieht
const DT_MS       = 250;      // max. Abstand Taps (ms)
const MOVE_PX     = 6;        // ab hier gilt es als Drag
/* ---------- Touch-Gesten (NEU) ---------- */
const activePointers = new Map();   // id → {x,y}

let euler; // Declare euler globally
const voxels = new Map(); // Stores { color: hex_color } for each voxel, not the mesh
let cvs;
let containerDiv; // Reference to the container div
let activeDrawingLevel = { x: 0, y: 0, z: 0 }; // Objekt für aktive Ebenen
let currentDrawingAxis = 'y'; // Aktuelle Achse für Alt+Mausrad
let currentShiftDragLevel = null; // Speichert die Ebene für den aktuellen Shift-Drag-Vorgang
// Lade die Farbe aus dem Local Storage oder nutze Weiß als Standard
let currentColor = localStorage.getItem('voxelEditorColor') || '#ffffff';
let moveSpeed = parseFloat(localStorage.getItem('voxelEditorFlySpeed')) || 0.1;
// Lade die Gittergröße aus dem Local Storage oder nutze 10 als Standard
let GRID = parseInt(localStorage.getItem('voxelEditorGridSize')) || 10;

// Preset colors - NEW, more natural colors
const presetColors = [
    localStorage.getItem('voxelPresetColor1') || '#8B4513', // Erdton (SaddleBrown)
    localStorage.getItem('voxelPresetColor2') || '#708237', // Grasgrün (OliveDrab)
    localStorage.getItem('voxelPresetColor3') || '#6495ED'  // Wasserblau (CornflowerBlue)
];
let activePresetIndex = -1; // -1 means no preset is "active" initially, 0 for the first preset, etc.
let presetBoxes = []; // Global array to store references to preset color boxes

// Referenzen für Lichter, die Schatten werfen, um sie später anpassen zu können
let mainDirectionalLight;

// Globale Variablen für Dragging-Status
let isShiftDragging = false;   // physische Shift-Taste
let shiftLock       = false;   // permanenter Shift (per Button)

function shiftActive(){        // true, wenn Shift ODER Shift-Lock an
    return isShiftDragging || shiftLock;
}
let isControlDragging = false;
let rotate = false; // Moved to global as it's used across handlers
let isPointerLocked = false; // NEW: Track pointer lock status
let lastActionVoxelCoords = null; // NEW: Tracks the last voxel acted upon for drag drawing
let initialClickPos = null; // To differentiate click from drag


// Performance optimization: Single mesh for all voxels
let voxelGeometry;
let voxelMesh;
let meshMaterial; // Material for the combined mesh

// NEU: Globale Variable für den Vorschau-Voxel
const previewVoxelGeometry = new THREE.BoxGeometry(VS, VS, VS);
const previewVoxelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5, depthTest: false }); // depthTest: false, damit er immer sichtbar ist
let previewVoxelMesh = new THREE.Mesh(previewVoxelGeometry, previewVoxelMaterial); // Initialize here
// ENDE NEU

// Modus-Enum
const Modes = {
    ADD: 'Hinzufügen',
    DELETE: 'Löschen',
    DRAW: 'Zeichnen',
    RECTANGLE_ADD: 'Rechteck hinzufügen' // New mode for rectangle fill
};
let currentMode = Modes.ADD; // Standardmodus

// Undo/Redo History
const history = [];
let historyPointer = -1;
const MAX_HISTORY_SIZE = 100; // Limit history to prevent excessive memory usage

// Global terrain parameters (can be adjusted by UI)
let terrainHeightScale = 10;
let terrainFrequency = 0.05;
let terrainOctaves = 4;
let terrainLacunarity = 2.0;
let terrainGain = 0.5;
let terrainSeed = ''; // Empty string means random seed
let hasUserTypedSeed = false; // Flag to track if user has manually set the seed
// Global instance of the noise generator
let noise2D;

// Custom ValueNoise2D as a function constructor to avoid lexical declaration issues
function ValueNoise2D(seed = '') {
    this.seed = seed;
    this.rng = new Math.seedrandom(seed);
    // Initialize Perlin noise. The 'noise' object should be available from perlin.js
    if (typeof noise === 'undefined') {
        console.warn("Perlin.js library (noise object) not found. ValueNoise2D will use basic Math.random.");
        this.noiseGenerator = null;
    } else {
        this.noiseGenerator = new noise.Perlin();
    }
}

ValueNoise2D.prototype._smoothstep = function(t) {
    return t * t * (3 - 2 * t);
};

ValueNoise2D.prototype._lerp = function(a, b, t) {
    return a + t * (b - a);
};

ValueNoise2D.prototype.fbm = function(x, z, octaves, lacunarity, gain) {
    let total = 0;
    let amplitude = 1;
    let maxAmplitude = 0;
    let frequency = terrainFrequency;

    for (let i = 0; i < octaves; i++) {
        const x0 = Math.floor(x * frequency);
        const z0 = Math.floor(z * frequency);
        const x1 = x0 + 1;
        const z1 = z0 + 1;

        const fx = (x * frequency) - x0;
        const fz = (z * frequency) - z0;

        // Use a temporary seeded RNG for each corner value to ensure determinism
        const val00 = new Math.seedrandom(`${this.seed}-${x0}-${z0}`)();
        const val10 = new Math.seedrandom(`${this.seed}-${x1}-${z0}`)();
        const val01 = new Math.seedrandom(`${this.seed}-${x0}-${z1}`)();
        const val11 = new Math.seedrandom(`${this.seed}-${x1}-${z1}`)();

        const ix0 = this._lerp(val00, val10, this._smoothstep(fx));
        const ix1 = this._lerp(val01, val11, this._smoothstep(fz));

        total += this._lerp(ix0, ix1, this._smoothstep(fz)) * amplitude;

        maxAmplitude += amplitude;

        frequency *= lacunarity;
        amplitude *= gain;
    }

    if (maxAmplitude === 0) return 0;
    return (total / maxAmplitude) * 2 - 1;
};


/* ---------- Hilfsfunktionen (alle vor window.onload verschoben) ---------- */

function onResize() {
    // Use containerDiv for sizing
    cam.aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam.updateProjectionMatrix();
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
}

function handleGesture () {
  const pts = [...activePointers.values()];
  if (pts.length === 0) return;

  if (pts.length === 1){
    const p = pts[0];

    if (dblTapActive){
      if (!dblTapDrag){
        const moved = Math.hypot(p.x - touchStartPos.x,
                                 p.y - touchStartPos.y);
        if (moved > MOVE_PX){
          dblTapDrag      = true;
          isShiftDragging = true;

          if (currentMode === Modes.ADD){
            const rect  = cvs.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                 ((p.x - rect.left) / rect.width)  * 2 - 1,
                -((p.y - rect.top ) / rect.height) * 2 + 1);
            const raycaster   = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cam);
            const intersects  = raycaster.intersectObject(voxelMesh);

            currentDrawingAxis    = 'y';
            currentShiftDragLevel = intersects.length
                 ? Math.floor(intersects[0].point.y / VS)
                 : activeDrawingLevel.y;
          }
        }
      }

      if (dblTapDrag){
        // In touch, dblTapDrag is like a shift-drag, so it should draw a line
        const currentTargetVoxel = calculateTargetVoxelCoords(p.x, p.y, currentMode, true, false, currentShiftDragLevel, currentDrawingAxis);
        if (currentTargetVoxel) {
            if (!lastActionVoxelCoords ||
                lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                
                if (lastActionVoxelCoords) {
                    drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor);
                } else {
                    performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor);
                }
                lastActionVoxelCoords = { ...currentTargetVoxel };
            }
        }
      }

      prevTouch = {x:p.x, y:p.y};
      return;
    }

    if (prevTouch === null){
        prevTouch = {x:p.x, y:p.y};
        return;
    }

    const dx = p.x - prevTouch.x;
    const dy = p.y - prevTouch.y;

    euler.y +=  dx * rotSpeed;
    euler.x +=  dy * rotSpeed;
    euler.x  =  Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
    cam.quaternion.setFromEuler(euler);

    prevTouch = {x:p.x, y:p.y};
    return;
  }

  if (pts.length !== 2) return;

  const [p0, p1] = pts;
  const midX  = (p0.x + p1.x) * 0.5;
  const midY  = (p0.y + p1.y) * 0.5;
  const dist  = Math.hypot(p1.x - p0.x, p1.y - p0.y);

  if (gestureMid === null){
    gestureMid  = {x:midX, y:midY};
    gestureDist = dist;
    gestureMode = null;
  }

  const dMid  = Math.hypot(midX - gestureMid.x, midY - gestureMid.y);
  const relΔ  = Math.abs(dist - gestureDist) / gestureDist;

  if (gestureMode === null){
    if (relΔ > PINCH_REL_TH)       gestureMode = 'pinch';
    else if (dMid > PAN_PIX_TH)    gestureMode = 'pan';
    else return;
  }

  if (gestureMode === 'pinch'){
    const scale     = dist / gestureDist;
    const zoomDelta = (scale - 1) * PINCH_ZOOM_MULT  * moveSpeed;
    cam.position.addScaledVector(
        cam.getWorldDirection(new THREE.Vector3()),
        zoomDelta
    );
    gestureDist = dist;
  } else {
    const panFactor = DRAG_BASE * (moveSpeed * 5);
    const dx = (midX - gestureMid.x) * panFactor;
    const dy = (midY - gestureMidy) * panFactor;

    const dir   = cam.getWorldDirection(new THREE.Vector3());
    const right = new THREE.Vector3().crossVectors(dir, cam.up).normalize();
    const upVec = cam.up.clone().normalize();

    cam.position.addScaledVector(right, -dx);
    cam.position.addScaledVector(upVec,    dy);

    gestureMid = {x:midX, y:midY};
  }

  prevTouch = null;
}

function releasePointer(id){
    activePointers.delete(id);

    if (activePointers.size === 1){
        const last = [...activePointers.values()][0];
        prevTouch   = { x:last.x, y:last.y };
        gestureMid  = gestureDist = null;
        gestureMode = null;
        return;
    }

    if (activePointers.size === 0){
        tapCandidate   = null;
        dblTapActive   = false;
        dblTapDrag     = false;
        isShiftDragging = false;
        isDblTapDragActive= false;
        gestureMid  = gestureDist = null;
        gestureMode = null;
        prevTouch   = null;
        lastActionVoxelCoords = null; // Reset for next touch interaction
    }
}

function rebuildHelpers() {
    if (typeof THREE === 'undefined') {
        console.error("THREE is not defined in rebuildHelpers. Cannot rebuild helpers.");
        return;
    }
    if (gridHelper) scene.remove(gridHelper);
    if (boxHelper) scene.remove(boxHelper);

    const size = GRID * VS;

    if (currentDrawingAxis === 'y') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444 );
        gridHelper.position.set(size / 2, activeDrawingLevel.y * VS, size / 2);
    } else if (currentDrawingAxis === 'x') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.z = Math.PI / 2;
        gridHelper.position.set(activeDrawingLevel.x * VS, size / 2, size / 2);
    } else if (currentDrawingAxis === 'z') {
        gridHelper = new THREE.GridHelper(size, GRID, 0x444444, 0x444444);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.set(size / 2, size / 2, activeDrawingLevel.z * VS);
    }
    scene.add(gridHelper);

    const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(size, size, size));
    boxHelper = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
    boxHelper.position.set(size / 2, size / 2, size / 2);
    scene.add(boxHelper);
}

function updateGridHelperPosition() {
    rebuildHelpers();
}

function key(cx, cy, cz) {
    return `${cx},${cy},${cz}`;
}

function cycleMode() {
    switch (currentMode) {
        case Modes.ADD:
            currentMode = Modes.DELETE;
            break;
        case Modes.DELETE:
            currentMode = Modes.DRAW;
            break;
        case Modes.DRAW:
            currentMode = Modes.RECTANGLE_ADD; // Cycle to new mode
            break;
        case Modes.RECTANGLE_ADD: // Cycle back to ADD
            currentMode = Modes.ADD;
            break;
    }
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`;
}

function setActivePreset(index) {
    if (index >= 0 && index < presetColors.length) {
        currentColor = presetColors[index];
        document.getElementById('color-picker').value = currentColor;
        localStorage.setItem('voxelEditorColor', currentColor); // Save as current selected color

        // Update active class for visual feedback
        presetBoxes.forEach((box, i) => {
            if (i === index) {
                box.classList.add('active');
            } else {
                box.classList.remove('active');
            }
        });
        activePresetIndex = index; // Store which preset is active
    }
}

function addCommand(type, gx, gy, gz, oldColor = null, newColor = null, oldState = null, newState = null, commandData = null) {
    // Clear redo history
    if (historyPointer < history.length - 1) {
        history.splice(historyPointer + 1);
    }

    history.push({ type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData });
    historyPointer++;

    // Limit history size
    if (history.length > MAX_HISTORY_SIZE) {
        history.shift();
        historyPointer--;
    }
}

function executeCommand(command, reverse = false) {
    const { type, gx, gy, gz, oldColor, newColor, oldState, newState, commandData } = command;
    switch (type) {
        case 'add':
            if (reverse) {
                removeVoxel(gx, gy, gz, true, false); // true for fromHistory, false to not update geometry immediately
            } else {
                addVoxel(gx, gy, gz, newColor, true, false); // true for fromHistory, false to not update geometry immediately
            }
            break;
        case 'delete':
            if (reverse) {
                addVoxel(gx, gy, gz, oldColor, true, false); // Re-add with original color
            } else {
                removeVoxel(gx, gy, gz, true, false);
            }
            break;
        case 'recolor':
            if (reverse) {
                recolorVoxel(gx, gy, gz, oldColor, true, false);
            } else {
                recolorVoxel(gx, gy, gz, newColor, true, false);
            }
            break;
        case 'clearAll':
            if (reverse) {
                // Restore old state from command's oldState
                clearAllInternal(true, false); // Clear current state first without history and no geometry update
                oldState.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color })); // Directly add to map
            } else {
                clearAllInternal(true, false); // Clear directly without history and no geometry update
            }
            break;
        case 'fillLevel':
            // For fillLevel, 'oldState' contains an array of voxels before fill, 'newState' after
            if (reverse) {
                // Restore state before the fill operation
                // To restore the state, we first remove all voxels that are in the newState
                // and then add back all voxels that were in the oldState.
                newState.forEach(v => {
                    voxels.delete(key(v.gx, v.gy, v.gz)); // Remove directly from map
                });
                oldState.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color })); // Add directly to map
            } else {
                // Apply the fill operation (forward)
                // To apply the forward state, we clear current voxels that are not in newState
                // and then add/recolor according to newState.
                const currentVoxelKeys = new Set([...voxels.keys()]); // Use .keys() for direct keys
                const newStateKeys = new Set(newState.map(v => key(v.gx, v.gy, v.gz)));

                currentVoxelKeys.forEach(k => {
                    if (!newStateKeys.has(k)) {
                        voxels.delete(k); // Remove directly from map
                    }
                });
                newState.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color })); // Add directly to map
            }
            break;
        case 'terrainGenerate':
            if (reverse) {
                // Revert to oldState: clear current voxels, then add oldState voxels
                clearAllInternal(true, false); // Clear without history and no geometry update
                oldState.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color })); // Directly add to map
            } else {
                // Apply newState: clear current voxels, then add newState voxels
                clearAllInternal(true, false); // Clear without history and no geometry update
                newState.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color })); // Directly add to map
            }
            break;
        case 'resizeGrid':
            const targetGridSize = reverse ? commandData.oldGrid : commandData.newGrid;
            GRID = targetGridSize;
            document.getElementById('grid-size-slider').value = GRID;
            document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
            localStorage.setItem('voxelEditorGridSize', GRID);

            clearAllInternal(true, false); // Clear current state without history (as we're reverting/applying)
            const targetState = reverse ? oldState : newState;
            targetState.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color }));
            break;
        case 'fillRectangle': // Handle the new rectangle fill command
            clearAllInternal(true, false); // Clear current state without history
            const rectTargetVoxels = reverse ? oldState : newState;
            rectTargetVoxels.forEach(v => voxels.set(key(v.gx, v.gy, v.gz), { color: v.color }));
            break;
    }
    updateVoxelGeometry(); // Update geometry once after the command is fully processed
    rebuildHelpers(); // Ensure helpers reflect the new state (especially for fillLevel, terrainGenerate)
    // resetCameraPosition(); // Reset camera only for large structural changes like clearAll/terrainGenerate. Or perhaps not.
}

function undo() {
    if (historyPointer >= 0) {
        executeCommand(history[historyPointer], true); // true for reverse
        historyPointer--;
    }
}

function redo() {
    if (historyPointer < history.length - 1) {
        historyPointer++;
        executeCommand(history[historyPointer], false); // false for forward
    }
}

// Function to add a voxel (mesh creation handled by updateVoxelGeometry)
function addVoxel(x, y, z, colorHex, fromHistory = false, triggerGeometryUpdate = true) {
    const k = key(x, y, z);
    if (!voxels.has(k)) {
        if (!fromHistory) {
            addCommand('add', x, y, z, null, colorHex);
        }
    } else if (voxels.get(k).color !== colorHex) {
        // Voxel exists but color is different, treat as recolor
        const oldColor = voxels.get(k).color;
        if (!fromHistory) {
            addCommand('recolor', x, y, z, oldColor, colorHex);
        }
    } else {
        // Voxel exists and color is same, nothing to do unless from history (then just update map)
        voxels.set(k, { color: colorHex }); // Ensure the map is correctly updated even if no change for history
        return; // No change needed, prevent geometry update if color is identical
    }
    voxels.set(k, { color: colorHex });
    if (triggerGeometryUpdate) {
        updateVoxelGeometry();
    }
}


// Function to remove a voxel
function removeVoxel(x, y, z, fromHistory = false, triggerGeometryUpdate = true) {
    const k = key(x, y, z);
    if (voxels.has(k)) {
        const oldColor = voxels.get(k).color;
        if (!fromHistory) {
            addCommand('delete', x, y, z, oldColor, null);
        }
        voxels.delete(k);
        if (triggerGeometryUpdate) {
            updateVoxelGeometry();
        }
    }
}

// Function to recolor a voxel (used internally for history commands)
function recolorVoxel(x, y, z, newColorHex, fromHistory = false, triggerGeometryUpdate = true) {
    const k = key(x, y, z);
    if (voxels.has(k)) {
        const oldColor = voxels.get(k).color;
        if (!fromHistory) {
            addCommand('recolor', x, y, z, oldColor, newColorHex);
        }
        voxels.set(k, { color: newColorHex });
        if (triggerGeometryUpdate) {
            updateVoxelGeometry();
        }
    }
}

// NEW: Helper function to perform the actual voxel modification
function performVoxelModification(x, y, z, mode, color) {
    const voxelKey = key(x, y, z);
    const actualHasVoxel = voxels.has(voxelKey);

    // Clamp coordinates to grid boundaries before performing modification
    x = Math.max(0, Math.min(GRID - 1, x));
    y = Math.max(0, Math.min(GRID - 1, y));
    z = Math.max(0, Math.min(GRID - 1, z));

    switch (mode) {
        case Modes.ADD:
            if (!actualHasVoxel) {
                addVoxel(x, y, z, color);
            }
            break;
        case Modes.DELETE:
            if (actualHasVoxel) {
                removeVoxel(x, y, z);
            }
            break;
        case Modes.DRAW:
            if (actualHasVoxel && voxels.get(voxelKey).color !== color) {
                recolorVoxel(x, y, z, color);
            }
            break;
    }
}

// NEW: DDA (Digital Differential Analyzer) for 3D Line Drawing
function drawLineOfVoxels(start, end, mode, color) {
    let x = start.gx;
    let y = start.gy;
    let z = start.gz;
    const x2 = end.gx;
    const y2 = end.gy;
    const z2 = end.gz;

    const dx = x2 - x;
    const dy = y2 - y;
    const dz = z2 - z;

    const steps = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));

    // Handle the case where start and end are the same (single point)
    if (steps === 0) {
        performVoxelModification(x, y, z, mode, color);
        return;
    }

    const x_inc = dx / steps;
    const y_inc = dy / steps;
    const z_inc = dz / steps;

    for (let i = 0; i <= steps; i++) {
        performVoxelModification(Math.round(x), Math.round(y), Math.round(z), mode, color);
        x += x_inc;
        y += y_inc;
        z += z_inc;
    }
}


// NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Voxels
function updatePreviewVoxel(x, y, z, visible) {
    if (previewVoxelMesh) {
        if (visible) {
            previewVoxelMesh.position.set(x * VS + HALF, y * VS + HALF, z * VS + HALF);
            previewVoxelMesh.visible = true;
            previewVoxelMaterial.color.set(currentColor); // Vorschau-Farbe an aktuelle Farbe anpassen
            // Optional: Passe die Opazität basierend auf dem Modus an
            if (currentMode === Modes.DELETE) {
                previewVoxelMaterial.opacity = 0.2; // Weniger sichtbar beim Löschen
            } else {
                previewVoxelMaterial.opacity = 0.5; // Standard Opazität
            }
        } else {
            previewVoxelMesh.visible = false;
        }
    }
}
// ENDE NEU

// Modified handleVoxelAction to only calculate and return target coords
function calculateTargetVoxelCoords(clientX, clientY, mode, isDragging, isStackingAdd, fixedLevel = null, fixedAxis = null) {
    // If pointer is locked (fly mode), no target voxel can be calculated for actions
    if (isPointerLocked) {
        return null;
    }

    const rect = cvs.getBoundingClientRect();
    const mouse = new THREE.Vector2(((clientX - rect.left) / rect.width) * 2 - 1,
        -((clientY - rect.top) / rect.height) * 2 + 1);

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, cam);

    let targetVoxelCoords = null;
    const intersects = raycaster.intersectObject(voxelMesh);

    // Determine the plane for drawing based on currentDrawingAxis and activeDrawingLevel
    let drawingPlane = null;
    let planeNormal = new THREE.Vector3();
    let planeConstant = 0;

    // Use the dynamically set fixedLevel if available, otherwise fallback to activeDrawingLevel
    const currentLevelForPlane = (fixedLevel !== null) ? fixedLevel : activeDrawingLevel[currentDrawingAxis];

    if (currentDrawingAxis === 'y') {
        planeNormal.set(0, 1, 0);
        planeConstant = -( currentLevelForPlane * VS ); // Plane at the bottom edge of the voxel row
    } else if (currentDrawingAxis === 'x') {
        planeNormal.set(1, 0, 0);
        planeConstant = -( currentLevelForPlane * VS ); // Plane at the left edge of the voxel column
    } else if (currentDrawingAxis === 'z') {
        planeNormal.set(0, 0, 1);
        planeConstant = -( currentLevelForPlane * VS ); // Plane at the front edge of the voxel depth
    }
    drawingPlane = new THREE.Plane(planeNormal, planeConstant);

    // --- LOGIC FOR MODES.ADD, DELETE, DRAW, RECTANGLE_ADD ---
    if (shiftActive() || isDblTapDragActive) { // This block handles all "fixed plane" drawing (Shift-drag, Double-tap-drag)
        // For drawing on a fixed plane, we intersect the ray with that plane
        const intersectionPoint = new THREE.Vector3();
        raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);

        if (intersectionPoint) {
            // Use Math.floor for all coordinates initially
            let gx = Math.floor(intersectionPoint.x / VS);
            let gy = Math.floor(intersectionPoint.y / VS);
            let gz = Math.floor(intersectionPoint.z / VS);

            // Explicitly set the coordinate on the fixed axis to fixedLevel
            if (currentDrawingAxis === 'y') {
                gy = fixedLevel;
            } else if (currentDrawingAxis === 'x') {
                gx = fixedLevel;
            } else if (currentDrawingAxis === 'z') {
                gz = fixedLevel;
            }

            targetVoxelCoords = { gx, gy, gz };
        }
    }
    else if (mode === Modes.ADD || mode === Modes.RECTANGLE_ADD) {
        if (isStackingAdd) { // Ctrl-Drag for stacking
            if (intersects.length > 0) {
                const hit = intersects[0];
                const gx = Math.floor(hit.point.x / VS);
                const gz = Math.floor(hit.point.z / VS);
                let highestY = -1;
                for (let y = 0; y < GRID; y++) {
                    if (voxels.has(key(gx, y, gz))) {
                        highestY = y;
                    }
                }
                targetVoxelCoords = { gx: gx, gy: highestY + 1, gz: gz };
            } else {
                // If no voxel hit, use the active drawing plane for stacking base
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);
                if (intersectionPoint) {
                    targetVoxelCoords = {
                        gx: Math.floor(intersectionPoint.x / VS),
                        gy: activeDrawingLevel.y, // Use the active drawing level for the base
                        gz: Math.floor(intersectionPoint.z / VS)
                    };
                }
            }
        } else { // Normal click or drag in ADD mode (No Shift/Ctrl) or RECTANGLE_ADD
            if (intersects.length > 0) {
                const hit = intersects[0];
                // Nudge the hit point slightly inwards along the normal to ensure we're inside the hit voxel
                const hitPointInVoxel = hit.point.clone().sub(hit.face.normal.clone().multiplyScalar(0.001));
                const hitVoxelX = Math.floor(hitPointInVoxel.x / VS);
                const hitVoxelY = Math.floor(hitPointInVoxel.y / VS);
                const hitVoxelZ = Math.floor(hitPointInVoxel.z / VS);

                // Then, add the normal components to get the adjacent voxel
                targetVoxelCoords = {
                    gx: hitVoxelX + hit.face.normal.x,
                    gy: hitVoxelY + hit.face.normal.y,
                    gz: hitVoxelZ + hit.face.normal.z
                };
            } else {
                // If no voxel is hit, use the active drawing plane
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(drawingPlane, intersectionPoint);
                if (intersectionPoint) {
                    targetVoxelCoords = {
                        gx: Math.floor(intersectionPoint.x / VS),
                        gy: activeDrawingLevel.y,
                        gz: Math.floor(intersectionPoint.z / VS)
                    };
                }
            }
        }
    }
    else { // mode === Modes.DELETE or mode === Modes.DRAW (normal click/drag, not fixed plane)
        if (intersects.length > 0) {
            const hit = intersects[0];
            const p = hit.point.clone();
            const n = hit.face.normal;
            p.sub(n.clone().multiplyScalar(0.01)); // Nudge slightly inwards to get the hit voxel

            targetVoxelCoords = {
                gx: Math.floor(p.x / VS),
                gy: Math.floor(p.y / VS),
                gz: Math.floor(p.z / VS)
            };
        }
        // If no intersection, and not a fixed-plane drag, then no target voxel.
    }

    if (targetVoxelCoords) {
        // Clamp coordinates to grid boundaries
        targetVoxelCoords.gx = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gx));
        targetVoxelCoords.gy = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gy));
        targetVoxelCoords.gz = Math.max(0, Math.min(GRID - 1, targetVoxelCoords.gz));
        return targetVoxelCoords;
    }
    return null;
}

function clearAllInternal(fromHistory = false, triggerGeometryUpdate = true) {
    if (!fromHistory) {
        const oldState = [...voxels.entries()].map(([id, data]) => {
            const parts = id.split(',').map(Number);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });
        addCommand('clearAll', null, null, null, null, null, oldState, []);
    }
    voxels.clear();
    if (triggerGeometryUpdate) {
        updateVoxelGeometry();
    }
    rebuildHelpers(); // Ensure helpers are reset or updated appropriately
}

function clearAll() {
    clearAllInternal(false, true); // User initiated clear, adds to history and updates geometry
}


function fillActiveLevel() {
    // Capture the current state before the fill for undo/redo
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            let gx, gy, gz;
            if (currentDrawingAxis === 'y') {
                gx = x;
                gy = activeDrawingLevel.y;
                gz = z;
            } else if (currentDrawingAxis === 'x') {
                gx = activeDrawingLevel.x;
                gy = x; // Use x as y-coordinate for horizontal plane
                gz = z; // Use z as z-coordinate
            }
            else if (currentDrawingAxis === 'z') {
                gx = x;
                gy = z; // Use z as y-coordinate for horizontal plane
                gz = activeDrawingLevel.z;
            }
            // Use direct map manipulation to avoid repeated geometry updates
            voxels.set(key(gx, gy, gz), { color: currentColor });
        }
    }
    updateVoxelGeometry(); // Update geometry once after all voxels are added/modified

    // Capture the new state after the fill for undo/redo
    const newState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });
    addCommand('fillLevel', null, null, null, null, null, oldState, newState);
}


// Performance critical function: combines all individual voxel geometries into one
function updateVoxelGeometry() {
    const geometries = [];
    const tempBox = new THREE.BoxGeometry(VS, VS, VS); // Re-use geometry object

    voxels.forEach((dataValue, k) => { // Corrected: value first, then key
        const [x, y, z] = k.split(',').map(Number);
        const color = new THREE.Color(dataValue.color); // Access color from the dataValue object

        const instanceGeometry = tempBox.clone();
        instanceGeometry.translate(x * VS + HALF, y * VS + HALF, z * VS + HALF);
        geometries.push(instanceGeometry);

        // Assign color to each vertex of the instance
        const colorArray = [];
        for (let i = 0; i < instanceGeometry.attributes.position.count; i++) {
            colorArray.push(color.r, color.g, color.b);
        }
        instanceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colorArray, 3));
    });

    if (voxelMesh) {
        scene.remove(voxelMesh); // Remove old mesh
        voxelMesh.geometry.dispose(); // Dispose old geometry to free memory
    }

    if (geometries.length > 0) {
        voxelGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries, true); // Merge geometries, keep colors
        // The material should have vertexColors: true
        voxelMesh = new THREE.Mesh(voxelGeometry, meshMaterial);
        voxelMesh.castShadow = true;
        voxelMesh.receiveShadow = true;
        scene.add(voxelMesh);
    } else {
        // If no voxels, create an empty geometry to avoid errors
        voxelGeometry = new THREE.BufferGeometry();
        voxelMesh = new THREE.Mesh(voxelGeometry, meshMaterial);
        voxelMesh.castShadow = true;
        voxelMesh.receiveShadow = true;
        scene.add(voxelMesh);
    }
}


function saveJSON() {
    const data = {};
    voxels.forEach((value, key) => {
        data[key] = value.color; // Save color value directly
    });

    const settings = {
        gridSize: GRID,
        cameraPosition: cam.position.toArray(),
        cameraQuaternion: cam.quaternion.toArray(),
        activeDrawingLevel: activeDrawingLevel,
        currentDrawingAxis: currentDrawingAxis,
        currentColor: currentColor,
        presetColors: presetColors,
        activePresetIndex: activePresetIndex,
        terrainHeightScale: terrainHeightScale,
        terrainFrequency: terrainFrequency,
        terrainOctaves: terrainOctaves,
        terrainLacunarity: terrainLacunarity,
        terrainGain: terrainGain,
        terrainSeed: terrainSeed,
        moveSpeed: moveSpeed // Save fly speed
    };

    const projectData = {
        voxels: data,
        settings: settings
    };

    const json = JSON.stringify(projectData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_project.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function loadJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const projectData = JSON.parse(e.target.result);
            const loadedVoxels = projectData.voxels;
            const loadedSettings = projectData.settings;

            // Clear current state and history before loading new project
            clearAllInternal(true, false); // Clear without adding to history and no geometry update

            // Load voxels
            for (const k in loadedVoxels) {
                // Ensure correct format for color
                const colorValue = loadedVoxels[k];
                const parts = k.split(',').map(Number);
                if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
                     // Directly add to map, deferring geometry update
                    voxels.set(key(parts[0], parts[1], parts[2]), { color: colorValue });
                }
            }
            updateVoxelGeometry(); // Update geometry once after all voxels are loaded

            // Load settings
            if (loadedSettings) {
                GRID = loadedSettings.gridSize !== undefined ? loadedSettings.gridSize : 10;
                document.getElementById('grid-size-slider').value = GRID;
                document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
                rebuildHelpers(); // Rebuild helpers for new grid size
                updateGridHelperPosition();

                if (loadedSettings.cameraPosition) {
                    cam.position.fromArray(loadedSettings.cameraPosition);
                }
                if (loadedSettings.cameraQuaternion) {
                    cam.quaternion.fromArray(loadedSettings.cameraQuaternion);
                    // Update Euler angles for pointer lock control
                    euler.setFromQuaternion(cam.quaternion, 'YXZ');
                }
                if (loadedSettings.activeDrawingLevel) {
                    activeDrawingLevel = { ...loadedSettings.activeDrawingLevel };
                }
                if (loadedSettings.currentDrawingAxis) {
                    currentDrawingAxis = loadedSettings.currentDrawingAxis;
                }
                updateGridHelperPosition(); // Rebuild with correct drawing axis

                currentColor = loadedSettings.currentColor || '#ffffff';
                document.getElementById('color-picker').value = currentColor;

                if (loadedSettings.presetColors) {
                    for(let i = 0; i < loadedSettings.presetColors.length && i < presetColors.length; i++) {
                        presetColors[i] = loadedSettings.presetColors[i];
                        document.getElementById(`color-preset-${i + 1}`).style.backgroundColor = presetColors[i];
                    }
                }
                // Re-apply active preset status
                setActivePreset(loadedSettings.activePresetIndex !== undefined ? loadedSettings.activePresetIndex : -1);

                // Load terrain parameters
                terrainHeightScale = loadedSettings.terrainHeightScale !== undefined ? loadedSettings.terrainHeightScale : 10;
                terrainFrequency = loadedSettings.terrainFrequency !== undefined ? loadedSettings.terrainFrequency : 0.05;
                terrainOctaves = loadedSettings.terrainOctaves !== undefined  ? loadedSettings.octaves : 4;
                terrainLacunarity = loadedSettings.lacunarity !== undefined ? loadedSettings.lacunarity : 2.0;
                terrainGain = loadedSettings.terrainGain !== undefined ? loadedSettings.gain : 0.5;
                terrainSeed = loadedSettings.terrainSeed !== undefined ? loadedSettings.terrainSeed : '';

                document.getElementById('terrain-height-scale').value = terrainHeightScale;
                document.getElementById('terrain-frequency').value = terrainFrequency;
                document.getElementById('terrain-octaves').value = terrainOctaves;
                document.getElementById('terrain-lacunarity').value = terrainLacunarity;
                document.getElementById('terrain-gain').value = terrainGain;
                document.getElementById('terrain-seed').value = terrainSeed;
                // Update hasUserTypedSeed based on loaded terrainSeed
                hasUserTypedSeed = (terrainSeed !== '');


                // Load fly speed
                if (loadedSettings.moveSpeed !== undefined) {
                    moveSpeed = loadedSettings.moveSpeed;
                    document.getElementById('fly-speed-slider').value = moveSpeed;
                    document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
                }

                // Re-initialize noise generator with loaded seed
                noise2D = new ValueNoise2D(terrainSeed);
            }

            // After loading, ensure history is reset or cleared to avoid issues with old state
            history.length = 0;
            historyPointer = -1;

            console.log('Project loaded successfully.');
            resetCameraPosition(); // Reset camera to view loaded terrain/voxels
        } catch (error) {
            console.error('Error loading JSON file:', error);
            alert('Fehler beim Laden der Datei. Stellen Sie sicher, dass es sich um eine gültige Voxel-Projekt-JSON-Datei handelt.');
        }
    };
    reader.readAsText(file);
}


function exportSTL() {
    if (!voxelMesh || voxelMesh.geometry.attributes.position.count === 0) {
        alert('Keine Voxel zum Exportieren vorhanden!');
        return;
    }

    const exporter = new THREE.STLExporter();
    const result = exporter.parse(voxelMesh); // Parse the combined mesh

    const blob = new Blob([result], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'voxel_model.stl';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function generateTerrain() {
    const oldState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });

    clearAllInternal(true, false); // Clear existing voxels without history and without immediate geometry update

    // Re-initialize noise generator with current seed before generating terrain
    noise2D = new ValueNoise2D(terrainSeed);

    for (let x = 0; x < GRID; x++) {
        for (let z = 0; z < GRID; z++) {
            // Get noise value for this (x,z) coordinate
            // Noise output is typically -1 to 1, scale it to 0 to 1, then to desired height
            const noiseVal = (noise2D.fbm(x, z, terrainOctaves, terrainLacunarity, terrainGain) + 1) * 0.5;
            let terrainHeight = Math.floor(noiseVal * terrainHeightScale);

            // Ensure terrainHeight is at least 1, so there's always a base layer
            terrainHeight = Math.max(1, Math.min(GRID, terrainHeight));

            for (let y = 0; y < terrainHeight; y++) {
                let voxelColor;
                // Placeholder colors - user needs to provide actual ranges
                // Adjusted these thresholds to be relative to the actual terrainHeightScale
                if (y < terrainHeightScale * 0.2) { // Example: Water
                    voxelColor = 0x6495ED; // CornflowerBlue
                } else if (y < terrainHeightScale * 0.6) { // Example: Earth
                    voxelColor = 0x8B4513; // SaddleBrown
                } else { // Example: Grass
                    voxelColor = 0x708237; // OliveDrab
                }
                voxels.set(key(x, y, z), { color: voxelColor }); // Add directly to map
            }
        }
    }
    updateVoxelGeometry(); // Update geometry once after all voxels are added
    rebuildHelpers(); // Update helpers to new terrain size
    resetCameraPosition(); // Reset camera to view new terrain

    // Capture the state after terrain generation
    const newState = [...voxels.entries()].map(([id, data]) => {
        const parts = id.split(',').map(Number);
        return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
    });
    addCommand('terrainGenerate', null, null, null, null, null, oldState, newState);
}

function resetCameraPosition() {
    cam.position.set(GRID * 1.0, GRID * 1.2, GRID * 1.5);
    cam.lookAt(GRID / 2, GRID / 2, GRID / 2);
    // Ensure Euler angles are also reset to match the new camera orientation for pointer lock
    if (euler) { // Check if euler is defined before using
        euler.setFromQuaternion(cam.quaternion, 'YXZ');
    }
}


/* ---------- Initialisierung bei Fensterladung ---------- */
window.onload = function() {
    cvs = document.getElementById('voxelCanvas');
    containerDiv = document.getElementById('container'); // Get reference to the container div

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x282c34);

    // Camera
    const aspect = containerDiv.clientWidth / containerDiv.clientHeight;
    cam = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    resetCameraPosition(); // Set initial camera position and look-at
    euler = new THREE.Euler(0, 0, 0, 'YXZ'); // Initialize euler with 'YXZ' order for consistent rotation

    // Renderer
    ren = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
    ren.setSize(containerDiv.clientWidth, containerDiv.clientHeight);
    ren.setPixelRatio(window.devicePixelRatio);
    ren.shadowMap.enabled = true; // Enable shadow maps
    ren.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
    scene.add(ambientLight);

    mainDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainDirectionalLight.position.set(10, 20, 15);
    mainDirectionalLight.castShadow = true;
    mainDirectionalLight.shadow.mapSize.width = 2048; // Increased for better shadow quality
    mainDirectionalLight.shadow.mapSize.height = 2048;
    mainDirectionalLight.shadow.camera.near = 0.5;
    mainDirectionalLight.shadow.camera.far = 50;
    mainDirectionalLight.shadow.camera.left = -30; // Adjust shadow camera volume
    mainDirectionalLight.shadow.camera.right = 30;
    mainDirectionalLight.shadow.camera.top = 30;
    mainDirectionalLight.shadow.camera.bottom = -30;
    scene.add(mainDirectionalLight);

    // Initial Material for combined mesh (now supports vertex colors)
    meshMaterial = new THREE.MeshLambertMaterial({ vertexColors: true });

    // Add initial empty voxel mesh to scene
    voxelGeometry = new THREE.BufferGeometry();
    voxelMesh = new THREE.Mesh(voxelGeometry, meshMaterial);
    voxelMesh.castShadow = true;
    voxelMesh.receiveShadow = true;
    scene.add(voxelMesh);

    // NEU: Vorschau-Voxel zur Szene hinzufügen
    scene.add(previewVoxelMesh);
    updatePreviewVoxel(0,0,0,false); // Initial verstecken

    // NEW: Initialize rectangle preview mesh
    rectanglePreviewMesh = new THREE.Mesh(new THREE.BufferGeometry(), rectanglePreviewMaterial);
    scene.add(rectanglePreviewMesh);
    rectanglePreviewMesh.visible = false; // Initially hidden

    // Helpers
    rebuildHelpers(); // Build initial grid and box helpers

    // Event Listeners
    window.addEventListener('resize', onResize);
    // Use containerDiv for pointer events to allow controls to be clickable
    containerDiv.addEventListener('pointerdown', onPointerDown);
    containerDiv.addEventListener('pointermove', onPointerMove);
    containerDiv.addEventListener('pointerup', onPointerUp);
    containerDiv.addEventListener('pointercancel', onPointerUp); // Treat cancel as up
    containerDiv.addEventListener('wheel', onMouseWheel, { passive: false }); // Prevent default scroll

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    // NEW: Listen for pointer lock changes
    document.addEventListener('pointerlockchange', onPointerLockChange, false);


    // Prevent context menu on right click
    containerDiv.addEventListener('contextmenu', (e) => e.preventDefault());

    // UI event listeners
    document.getElementById('grid-size-slider').addEventListener('input', (e) => {
        const oldGrid = GRID; // Capture old GRID size for history
        GRID = parseInt(e.target.value);
        document.getElementById('grid-size-display').textContent = `${GRID}×${GRID}×${GRID}`;
        localStorage.setItem('voxelEditorGridSize', GRID);

        // Capture current voxel state before clear for history
        const oldVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = id.split(',').map(Number);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        // Clear voxels outside new bounds and update geometry
        const newVoxelsMap = new Map();
        oldVoxelState.forEach(v => {
            if (v.gx < GRID && v.gy < GRID && v.gz < GRID) {
                newVoxelsMap.set(key(v.gx, v.gy, v.gz), { color: v.color });
            }
        });
        voxels.clear();
        newVoxelsMap.forEach((data, k) => voxels.set(k, data));
        updateVoxelGeometry();

        // Capture new voxel state after resize for history
        const newVoxelState = [...voxels.entries()].map(([id, data]) => {
            const parts = id.split(',').map(Number);
            return { gx: parts[0], gy: parts[1], gz: parts[2], color: data.color };
        });

        addCommand('resizeGrid', null, null, null, null, null, oldVoxelState, newVoxelState, { oldGrid: oldGrid, newGrid: GRID });

        rebuildHelpers();
        resetCameraPosition(); // Reset camera to new grid center
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        currentColor = e.target.value;
        localStorage.setItem('voxelEditorColor', currentColor);
        // Deactivate all presets when custom color is picked
        presetBoxes.forEach(box => box.classList.remove('active'));
        activePresetIndex = -1;
    });

    // Populate and add listeners for preset color boxes
    presetBoxes = [
        document.getElementById('color-preset-1'),
        document.getElementById('color-preset-2'),
        document.getElementById('color-preset-3')
    ];
    presetColors.forEach((color, index) => {
        const box = presetBoxes[index];
        box.style.backgroundColor = color;
        box.addEventListener('click', () => {
            setActivePreset(index);
        });
    });
    // Set initial active preset if one was loaded
    if (activePresetIndex !== -1) {
        setActivePreset(activePresetIndex);
    } else {
        // If no preset was active, ensure current color is shown on picker and no preset box is active
        document.getElementById('color-picker').value = currentColor;
    }


    document.getElementById('modeToggle').addEventListener('click', cycleMode); // Use new cycleMode
    document.getElementById('current-mode').textContent = `Modus: ${currentMode}`; // Update initial display

    const clearConfirmationModal = document.getElementById('clearConfirmationModal');
    document.getElementById('clearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'flex';
    });
    document.getElementById('saveAndClearBtn').addEventListener('click', () => {
        saveJSON();
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('clearWithoutSaveBtn').addEventListener('click', () => {
        clearAll();
        clearConfirmationModal.style.display = 'none';
    });
    document.getElementById('cancelClearBtn').addEventListener('click', () => {
        clearConfirmationModal.style.display = 'none';
    });


    document.getElementById('fillLevelBtn').addEventListener('click', fillActiveLevel);
    document.getElementById('saveBtn').addEventListener('click', saveJSON);
    document.getElementById('loadBtn').addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    document.getElementById('fileInput').addEventListener('change', loadJSON);
    document.getElementById('exportStlBtn').addEventListener('click', exportSTL);

    document.getElementById('fly-speed-slider').addEventListener('input', (e) => {
        moveSpeed = parseFloat(e.target.value);
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);
    });

    // Info Box (Help) Toggle Logic
    const infoBox = document.getElementById('infoBox');
    const helpToggleBtn = document.getElementById('helpToggleBtn');
    let showInfoBox = localStorage.getItem('showInfoBox') === 'true'; // Default to true if not set

    function updateInfoBoxVisibility() {
        infoBox.style.display = showInfoBox ? 'block' : 'none';
        helpToggleBtn.textContent = showInfoBox ? 'Hilfe ausblenden' : 'Hilfe anzeigen';
        localStorage.setItem('showInfoBox', showInfoBox);
    }
    helpToggleBtn.addEventListener('click', () => {
        showInfoBox = !showInfoBox;
        updateInfoBoxVisibility();
    });
    updateInfoBoxVisibility(); // Set initial visibility on load

    // Terrain Controls Toggle Logic
    const terrainControlsPanel = document.getElementById('terrainControlsPanel');
    const toggleTerrainControlsBtn = document.getElementById('toggleTerrainControlsBtn');
    let showTerrainControls = localStorage.getItem('showTerrainControls') === 'true';

    function updateTerrainControlsVisibility() {
        terrainControlsPanel.style.display = showTerrainControls ? 'flex' : 'none';
        toggleTerrainControlsBtn.textContent = showTerrainControls ? 'Gelände-Optionen ausblenden' : 'Gelände-Optionen anzeigen';
        localStorage.setItem('showTerrainControls', showTerrainControls);
    }
    toggleTerrainControlsBtn.addEventListener('click', () => {
        showTerrainControls = !showTerrainControls;
        updateTerrainControlsVisibility();
    });
    updateTerrainControlsVisibility();

    // Terrain parameter input event listeners
    document.getElementById('terrain-height-scale').addEventListener('input', (e) => terrainHeightScale = parseInt(e.target.value));
    document.getElementById('terrain-frequency').addEventListener('input', (e) => terrainFrequency = parseFloat(e.target.value));
    document.getElementById('terrain-octaves').addEventListener('input', (e) => terrainOctaves = parseInt(e.target.value));
    document.getElementById('terrain-lacunarity').addEventListener('input', (e) => terrainLacunarity = parseFloat(e.target.value));
    document.getElementById('terrain-gain').addEventListener('input', (e) => terrainGain = parseFloat(e.target.value));
    document.getElementById('terrain-seed').addEventListener('input', (e) => {
        terrainSeed = e.target.value;
        hasUserTypedSeed = (terrainSeed !== '');
    });

    document.getElementById('generateTerrainBtn').addEventListener('click', generateTerrain);

    // Shift-Lock Button
    const shiftLockBtn = document.getElementById('shiftLockBtn');
    shiftLockBtn.addEventListener('click', () => {
        shiftLock = !shiftLock;
        shiftLockBtn.textContent = `Shift-Lock ✱ ${shiftLock ? 'an' : 'aus'}`;
        shiftLockBtn.classList.toggle('active', shiftLock); // Add/remove 'active' class
    });


    // Hamburger menu toggle for mobile
    const menuToggle = document.getElementById('menuToggle');
    menuToggle.addEventListener('click', () => {
        const controlsPanel = document.getElementById('controls');
        if (controlsPanel.style.display === 'none' || controlsPanel.style.display === '') {
            controlsPanel.style.display = 'flex';
        } else {
            controlsPanel.style.display = 'none';
        }
    });

    // Check media query on load and resize
    const mediaQuery = window.matchMedia('(max-width: 768px)');
    function handleMediaQueryChange(e) {
        const controlsPanel = document.getElementById('controls');
        if (e.matches) {
            // Mobile view: hide controls by default, show menu toggle
            controlsPanel.style.display = 'none';
            menuToggle.style.display = 'block';
        } else {
            // Desktop view: show controls by default, hide menu toggle
            controlsPanel.style.display = 'flex';
            menuToggle.style.display = 'none';
        }
    }
    mediaQuery.addListener(handleMediaQueryChange); // Add listener for changes
    handleMediaQueryChange(mediaQuery); // Call once on load

    // Initialisiere noise2D mit dem aktuellen Seed
    noise2D = new ValueNoise2D(terrainSeed);

    // Start animation loop
    animate();
}; // END window.onload

/* ---------- Animations-Loop ---------- */
function animate() {
    requestAnimationFrame(animate);

    // Continuous keyboard movement when pointer is locked (fly mode)
    if (isPointerLocked) {
        const forward = cam.getWorldDirection(new THREE.Vector3());
        const right = new THREE.Vector3().crossVectors(forward, cam.up).normalize();
        const up = new THREE.Vector3(0, 1, 0); // World up direction

        const currentMoveSpeed = moveSpeed * 5; // Adjust this multiplier for desired feel

        if (keyboard['w']) cam.position.addScaledVector(forward, currentMoveSpeed);
        if (keyboard['s']) cam.position.addScaledVector(forward, -currentMoveSpeed);
        if (keyboard['a']) cam.position.addScaledVector(right, -currentMoveSpeed);
        if (keyboard['d']) cam.position.addScaledVector(right, currentMoveSpeed);
        if (keyboard['q']) cam.position.addScaledVector(up, -currentMoveSpeed);
        if (keyboard['e']) cam.position.addScaledVector(up, currentMoveSpeed);
    }

    ren.render(scene, cam);
}

/* ---------- Mouse / Pointer Input ---------- */
let pointerIsDown = false;
let lastX, lastY;
let isPointerOverCanvas = false;
let currentHoveredVoxel = null; // Store {x, y, z} of the voxel currently hovered by the mouse

// NEW: Variables for rectangle drawing
let isDrawingRectangle = false;
let rectangleStartCoords = null; // {gx, gy, gz}
let rectanglePreviewMesh = null; // THREE.Mesh for the preview
const rectanglePreviewMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, depthTest: false });


function onPointerDown(e) {
    if (e.pointerType === 'mouse' && e.button === 2) { // Right-click (mouse only)
        rotate = true;
        // Request pointer lock only on right click down
        cvs.requestPointerLock();
        e.preventDefault(); // Prevent context menu
        return;
    }

    // Only proceed with voxel actions if not in fly mode (pointer not locked)
    if (!isPointerLocked) {
        pointerIsDown = true;
        lastX = e.clientX;
        lastY = e.clientY;
        lastActionVoxelCoords = null; // NEW: Reset last acted-upon voxel on pointer down

        // Store initial position for drag detection (to differentiate click from drag)
        initialClickPos = { x: e.clientX, y: e.clientY };

        // Start long-press timer
        longPressTimer = setTimeout(() => {
            isHoldDrawingActive = true;
            // No immediate action here, it will be handled by onPointerMove or onPointerUp
        }, LONG_PRESS_DELAY_MS);

        // Check for double-tap start (for dblTapDragDraw)
        const now = performance.now();
        if (now - lastTap < DT_MS && tapCandidate && Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y) < TAP_DIST_TH) {
            dblTapActive = true;
            isDblTapDragActive = true; // Activate double-tap-drag mode
            activeGestureMode = 'dblTapDragDraw';

            const rect = cvs.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1,
                                            -((e.clientY - rect.top) / rect.height) * 2 + 1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cam);
            const intersects = raycaster.intersectObject(voxelMesh);
            currentShiftDragLevel = intersects.length ? Math.floor(intersects[0].point.y / VS) : activeDrawingLevel.y;

        } else {
            dblTapActive = false;
            isDblTapDragActive = false;
            activeGestureMode = 'none';
            tapCandidate = { x: e.clientX, y: e.clientY, time: now };
        }

        // NEW: Determine fixed drawing plane for Shift-drag or Ctrl-drag (if not stacking)
        // This needs to be done *before* any potential drag logic in onPointerMove
        if (e.buttons === 1 && (e.shiftKey || shiftLock)) { // Left mouse button + Shift key or Shift-Lock
            const rect = cvs.getBoundingClientRect();
            const mouse = new THREE.Vector2(((e.clientX - rect.left) / rect.width) * 2 - 1,
                                            -((e.clientY - rect.top) / rect.height) * 2 + 1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cam);
            const intersects = raycaster.intersectObject(voxelMesh);

            // If a voxel is hit, set the fixed level based on the hit point and normal
            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitNormal = hit.face.normal;
                // Determine the dominant axis of the hit face normal to set the drawing plane
                if (Math.abs(hitNormal.y) > Math.abs(hitNormal.x) && Math.abs(hitNormal.y) > Math.abs(hitNormal.z)) {
                    currentDrawingAxis = 'y';
                    // Calculate the plane level. If adding, it's the plane *above* the hit voxel.
                    // If deleting/drawing, it's the plane *of* the hit voxel.
                    if (currentMode === Modes.ADD || currentMode === Modes.RECTANGLE_ADD) {
                        currentShiftDragLevel = Math.floor(hit.point.y / VS) + Math.round(hitNormal.y);
                    } else { // DELETE or DRAW
                        currentShiftDragLevel = Math.floor(hit.point.y / VS);
                    }
                } else if (Math.abs(hitNormal.x) > Math.abs(hitNormal.y) && Math.abs(hitNormal.x) > Math.abs(hitNormal.z)) {
                    currentDrawingAxis = 'x';
                    if (currentMode === Modes.ADD || currentMode === Modes.RECTANGLE_ADD) {
                        currentShiftDragLevel = Math.floor(hit.point.x / VS) + Math.round(hitNormal.x);
                    } else {
                        currentShiftDragLevel = Math.floor(hit.point.x / VS);
                    }
                } else { // Z-axis dominant
                    currentDrawingAxis = 'z';
                    if (currentMode === Modes.ADD || currentMode === Modes.RECTANGLE_ADD) {
                        currentShiftDragLevel = Math.floor(hit.point.z / VS) + Math.round(hitNormal.z);
                    } else {
                        currentShiftDragLevel = Math.floor(hit.point.z / VS);
                    }
                }
            } else {
                // If no voxel is hit, default to the current active drawing level and axis
                // This assumes the user wants to draw on the currently visible grid plane.
                currentShiftDragLevel = activeDrawingLevel[currentDrawingAxis];
            }
            rebuildHelpers(); // Update grid helper to show the fixed plane
        } else {
            // Reset fixed level and axis if not shift-dragging
            currentShiftDragLevel = null;
            // currentDrawingAxis remains as set by Alt+Mousewheel
        }


        // NEW: Handle start of rectangle drawing
        if (currentMode === Modes.RECTANGLE_ADD) {
            const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false);
            if (clickedVoxel) {
                isDrawingRectangle = true;
                rectangleStartCoords = { ...clickedVoxel };
                lastActionVoxelCoords = { ...clickedVoxel }; // Set initial anchor for line drawing
                rectanglePreviewMesh.visible = true; // Show preview
            }
        }

        if (e.pointerType === 'touch') {
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
            handleGesture(); // Process gesture immediately for touch
        } else {
            // For mouse, do NOT do a single action on click here. It's handled by onPointerUp.
            // This prevents the "draws two" issue when a click is followed by a tiny drag.
        }
    }
}

function onPointerMove(e) {
    // Update pointer position for multi-touch gestures
    if (e.pointerType === 'touch') {
        activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
        handleGesture();
    } else if (isPointerLocked) { // Mouse right-click rotation (Unreal Engine style)
        // Use movementX/Y for rotation when pointer is locked
        const dx = e.movementX || 0;
        const dy = e.movementY || 0;

        // Rotation
        euler.y -= dx * rotSpeed; // Invert X-axis rotation for more intuitive feel
        euler.x -= dy * rotSpeed;
        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x)); // Clamp vertical rotation
        cam.quaternion.setFromEuler(euler);

        // No direct camera position update here; it's handled in animate() loop via keyboard input
    } else { // Not pointer locked
        const currentTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, true, isControlDragging, currentShiftDragLevel, currentDrawingAxis);

        if (currentTargetVoxel) {
            // Update preview voxel for single-voxel modes, hide if drawing rectangle
            let shouldShowPreview = false;
            if (currentMode !== Modes.RECTANGLE_ADD) {
                if (currentMode === Modes.ADD && !voxels.has(key(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz))) {
                    shouldShowPreview = true;
                } else if ((currentMode === Modes.DELETE || currentMode === Modes.DRAW) && voxels.has(key(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz))) {
                    shouldShowPreview = true;
                }
            }
            updatePreviewVoxel(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, shouldShowPreview && !isDrawingRectangle);
        } else {
            updatePreviewVoxel(0, 0, 0, false); // Hide single preview
        }

        if (pointerIsDown) { // LMB is held down (drag or long-press drag)
            // Check if it's a drag (moved more than a few pixels from initial click)
            const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
            const isActualDrag = movedDistance > MOVE_PX; // MOVE_PX is already defined (6px)

            if (isActualDrag || isHoldDrawingActive || isDblTapDragActive) { // If it's a drag, or a special drag mode
                if (currentTargetVoxel) {
                    if (currentMode === Modes.RECTANGLE_ADD && isDrawingRectangle) {
                        // Update rectangle preview
                        updateRectanglePreview(rectangleStartCoords, currentTargetVoxel);
                    } else { // For other modes (ADD, DELETE, DRAW)
                        // If this is a shift-drag or control-drag or dblTapDrag, draw a line segment
                        if (shiftActive() || isControlDragging || isDblTapDragActive) {
                            // Only draw if the target voxel has changed from the last action voxel
                            if (!lastActionVoxelCoords ||
                                lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                                lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                                lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {

                                if (lastActionVoxelCoords) { // Draw line from last acted-upon to current
                                    drawLineOfVoxels(lastActionVoxelCoords, currentTargetVoxel, currentMode, currentColor);
                                } else { // First point of the drag, just act on it
                                    performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor);
                                }
                                lastActionVoxelCoords = { ...currentTargetVoxel }; // Update last acted-upon voxel
                            }
                        } else { // Normal drag (not fixed plane, not stacking)
                            // Only perform modification if the target voxel has changed
                            if (!lastActionVoxelCoords ||
                                lastActionVoxelCoords.gx !== currentTargetVoxel.gx ||
                                lastActionVoxelCoords.gy !== currentTargetVoxel.gy ||
                                lastActionVoxelCoords.gz !== currentTargetVoxel.gz) {
                                performVoxelModification(currentTargetVoxel.gx, currentTargetVoxel.gy, currentTargetVoxel.gz, currentMode, currentColor);
                                lastActionVoxelCoords = { ...currentTargetVoxel };
                            }
                        }
                    }
                }
            }
        }
    }
}

function onPointerUp(e) {
    if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
    }
    isHoldDrawingActive = false;

    if (e.pointerType === 'mouse' && e.button === 2) { // Right-click up
        rotate = false;
        document.exitPointerLock();
    }

    if (e.pointerType === 'touch') {
        releasePointer(e.pointerId);
    } else {
        // Handle single click (no drag occurred)
        const movedDistance = initialClickPos ? Math.hypot(e.clientX - initialClickPos.x, e.clientY - initialClickPos.y) : 0;
        const wasSingleClick = movedDistance <= MOVE_PX; // Use MOVE_PX for click threshold

        if (pointerIsDown && !isPointerLocked) { // Ensure pointer was down and not in fly mode
            if (currentMode === Modes.RECTANGLE_ADD && isDrawingRectangle) {
                const finalTargetVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false);
                if (rectangleStartCoords && finalTargetVoxel) {
                    fillRectangle(rectangleStartCoords, finalTargetVoxel, currentColor);
                }
                isDrawingRectangle = false;
                rectangleStartCoords = null;
                rectanglePreviewMesh.visible = false; // Hide preview
                if (rectanglePreviewMesh.geometry) {
                    rectanglePreviewMesh.geometry.dispose(); // Dispose old geometry
                }
                rectanglePreviewMesh.geometry = new THREE.BufferGeometry(); // Reset to empty
            } else if (wasSingleClick) { // Single click for other modes
                const clickedVoxel = calculateTargetVoxelCoords(e.clientX, e.clientY, currentMode, false, false);
                if (clickedVoxel) {
                    performVoxelModification(clickedVoxel.gx, clickedVoxel.gy, clickedVoxel.gz, currentMode, currentColor);
                }
            }
        }

        pointerIsDown = false;
        updatePreviewVoxel(0, 0, 0, false);
    }
    isControlDragging = false;
    isShiftDragging = false;
    dblTapDrag = false;
    isDblTapDragActive = false;
    activeGestureMode = 'none';
    lastActionVoxelCoords = null; // Reset for next click/drag
    initialClickPos = null; // Reset initial click position

    lastTap = performance.now();
}

function onPointerLockChange() {
    if (document.pointerLockElement === cvs) {
        isPointerLocked = true;
        // When pointer is locked, hide the preview voxel
        updatePreviewVoxel(0,0,0,false);
        rectanglePreviewMesh.visible = false; // Hide rectangle preview too
    } else {
        isPointerLocked = false;
        rotate = false; // Ensure rotate is false if pointer lock is lost
    }
}

function onMouseWheel(e) {
    e.preventDefault(); // Prevent page scrolling

    const sensitivity = 0.005; // Adjust as needed for desired speed
    let zoomAmount = e.deltaY * sensitivity;

    if (e.altKey) {
        // Alt + Scroll for activeDrawingLevel on Y-axis
        if (e.shiftKey) { // Alt + Shift + Scroll for Z-axis
            activeDrawingLevel.z = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.z - Math.sign(e.deltaY)));
            currentDrawingAxis = 'z';
        } else if (e.ctrlKey) { // Alt + Ctrl + Scroll for X-axis
            activeDrawingLevel.x = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.x - Math.sign(e.deltaY)));
            currentDrawingAxis = 'x';
        } else { // Alt + Scroll for Y-axis
            activeDrawingLevel.y = Math.max(0, Math.min(GRID - 1, activeDrawingLevel.y - Math.sign(e.deltaY)));
            currentDrawingAxis = 'y';
        }
        updateGridHelperPosition(); // Rebuild grid helper to reflect new level/axis
    } else {
        // NEW: Adjust fly speed with mouse wheel when not holding Alt
        const speedChange = -Math.sign(e.deltaY) * 0.01; // Adjust speed by 0.01 per scroll tick
        moveSpeed = Math.max(0.01, Math.min(2.0, moveSpeed + speedChange)); // Clamp speed
        document.getElementById('fly-speed-slider').value = moveSpeed;
        document.getElementById('fly-speed-display').textContent = moveSpeed.toFixed(2);
        localStorage.setItem('voxelEditorFlySpeed', moveSpeed);

        // Existing regular scroll for camera zoom (moving along camera's look direction)
        cam.position.addScaledVector(
            cam.getWorldDirection(new THREE.Vector3()),
            zoomAmount * moveSpeed * 5 // Faster zoom for mouse wheel
        );
    }
}

// NEW: Function to update the rectangle preview mesh
function updateRectanglePreview(start, end) {
    if (!rectanglePreviewMesh) return;

    const minX = Math.min(start.gx, end.gx);
    const minY = Math.min(start.gy, end.gy);
    const minZ = Math.min(start.gz, end.gz);
    const maxX = Math.max(start.gx, end.gx);
    const maxY = Math.max(start.gy, end.gy);
    const maxZ = Math.max(start.gz, end.gz);

    // Calculate dimensions of the bounding box
    const width = maxX - minX + 1;
    const height = maxY - minY + 1;
    const depth = maxZ - minZ + 1;

    // Create a temporary BoxGeometry for the preview
    const tempGeometry = new THREE.BoxGeometry(width * VS, height * VS, depth * VS);

    // Position the geometry correctly: center of the bounding box
    tempGeometry.translate(
        (minX + maxX) * HALF * VS,
        (minY + maxY) * HALF * VS,
        (minZ + maxZ) * HALF * VS
    );

    // Dispose old geometry and assign new one
    if (rectanglePreviewMesh.geometry) {
        rectanglePreviewMesh.geometry.dispose();
    }
    rectanglePreviewMesh.geometry = tempGeometry;
    rectanglePreviewMesh.visible = true;
    rectanglePreviewMaterial.color.set(currentColor); // Set preview color to current color
}

// NEW: Function to fill a rectangle of voxels
function fillRectangle(start, end, color) {
    const oldState = [];
    const newState = [];

    const minX = Math.min(start.gx, end.gx);
    const minY = Math.min(start.gy, end.gy);
    const minZ = Math.min(start.gz, end.gz);
    const maxX = Math.max(start.gx, end.gx);
    const maxY = Math.max(start.gy, end.gy);
    const maxZ = Math.max(start.gz, end.gz);

    for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
            for (let z = minZ; z <= maxZ; z++) {
                const k = key(x, y, z);
                // Capture old state if voxel exists before modification
                if (voxels.has(k)) {
                    oldState.push({ gx: x, gy: y, gz: z, color: voxels.get(k).color });
                }
                // Add new state for the filled voxel
                newState.push({ gx: x, gy: y, gz: z, color: color });
                // Directly set voxel in the map
                voxels.set(k, { color: color });
            }
        }
    }
    updateVoxelGeometry(); // Update geometry once after all changes

    // Add a custom command type for rectangle fill to history
    addCommand('fillRectangle', null, null, null, null, null, oldState, newState, { start, end, color });
}


/* ---------- Keyboard Input ---------- */
const keyboard = {};
function onKeyDown(e) {
    keyboard[e.key] = true;

    // Modifier keys for dragging (Shift and Control)
    if (e.key === 'Shift') {
        isShiftDragging = true;
    }
    if (e.key === 'Control' || e.key === 'Meta') { // Meta for Mac Command key
        isControlDragging = true;
    }

    // Undo/Redo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { // Ctrl+Z or Cmd+Z
        e.preventDefault(); // Prevent browser undo
        undo();
    }
    if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'Z')) { // Ctrl+Y or Cmd+Y, or Ctrl+Shift+Z / Cmd+Shift+Z
        e.preventDefault(); // Prevent browser redo
        redo();
    }

    // Other Shortcuts
    switch (e.key) {
        case 'Tab':
            e.preventDefault(); // Prevent tabbing through elements
            cycleMode();
            break; // Text content updated in cycleMode function
        case '1': setActivePreset(0); break;
        case '2': setActivePreset(1); break;
        case '3': setActivePreset(2); break;
    }
}

function onKeyUp(e) {
    keyboard[e.key] = false;

    if (e.key === 'Shift') {
        isShiftDragging = false;
    }
    if (e.key === 'Control' || e.key === 'Meta') {
        isControlDragging = false;
    }
}
</script>
</body>
</html>
